import {
  __commonJS,
  __export,
  __publicField,
  __require
} from "./chunk-FM7WUVZV.js";

// browser-external:crypto
var require_crypto = __commonJS({
  "browser-external:crypto"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "crypto" has been externalized for browser compatibility. Cannot access "crypto.${key}" in client code. See https://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// browser-external:https
var require_https = __commonJS({
  "browser-external:https"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "https" has been externalized for browser compatibility. Cannot access "https.${key}" in client code. See https://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/@bsv/sdk/dist/esm/src/primitives/BigNumber.js
var _BigNumber = class _BigNumber {
  /**
   * @constructor
   *
   * @param number - The number (various types accepted) to construct a BigNumber from. Default is 0.
   *
   * @param base - The base of number provided. By default is 10.
   *
   * @param endian - The endianness provided. By default is 'big endian'.
   *
   * @example
   * import BigNumber from './BigNumber';
   * const bn = new BigNumber('123456', 10, 'be');
   */
  constructor(number = 0, base = 10, endian = "be") {
    /**
     * Negative flag. Indicates whether the big number is a negative number.
     * - If 0, the number is positive.
     * - If 1, the number is negative.
     *
     * @property negative
     *
     * @example
     * let num = new BigNumber("-10");
     * console.log(num.negative);  // output: 1
     */
    __publicField(this, "negative");
    /**
     * Array of numbers, where each number represents a part of the value of the big number.
     *
     * @property words
     *
     * @example
     * let num = new BigNumber(50000);
     * console.log(num.words);  // output: [ 50000 ]
     */
    __publicField(this, "words");
    /**
     * Length of the words array.
     *
     * @property length
     *
     * @example
     * let num = new BigNumber(50000);
     * console.log(num.length);  // output: 1
     */
    __publicField(this, "length");
    /**
     * Reduction context of the big number.
     *
     * @property red
     */
    __publicField(this, "red");
    this.negative = 0;
    this.words = [];
    this.length = 0;
    this.red = null;
    if (number !== null) {
      if (base === "le" || base === "be") {
        endian = base;
        base = 10;
      }
      if (typeof number === "number") {
        return this.initNumber(number, base, endian);
      }
      if (typeof number === "object") {
        return this.initArray(number, endian);
      }
      if (base === "hex") {
        base = 16;
      }
      this.assert(base === (base | 0) && base >= 2 && base <= 36);
      number = number.toString().replace(/\s+/g, "");
      let start = 0;
      if (number[0] === "-") {
        start++;
        this.negative = 1;
      }
      if (start < number.length) {
        if (base === 16) {
          this.parseHex(number, start, endian);
        } else {
          this.parseBase(number, base, start);
          if (endian === "le") {
            this.initArray(this.toArray(), endian);
          }
        }
      }
    }
  }
  /**
   * Checks whether a value is an instance of BigNumber. If not, then checks the features of the input to determine potential compatibility. Regular JS numbers fail this check.
   *
   * @method isBN
   * @param num - The value to be checked.
   * @returns - Returns a boolean value determining whether or not the checked num parameter is a BigNumber.
   *
   * @example
   * const validNum = new BigNumber(5);
   * BigNumber.isBN(validNum); // returns true
   *
   * const invalidNum = 5;
   * BigNumber.isBN(invalidNum); // returns false
   */
  static isBN(num) {
    if (num instanceof _BigNumber) {
      return true;
    }
    return num !== null && typeof num === "object" && num.constructor.wordSize === _BigNumber.wordSize && Array.isArray(num.words);
  }
  /**
   * Returns the bigger value between two BigNumbers
   *
   * @method max
   * @param left - The first BigNumber to be compared.
   * @param right - The second BigNumber to be compared.
   * @returns - Returns the bigger BigNumber between left and right.
   *
   * @example
   * const bn1 = new BigNumber(5);
   * const bn2 = new BigNumber(10);
   * BigNumber.max(bn1, bn2); // returns bn2
   */
  static max(left, right) {
    if (left.cmp(right) > 0)
      return left;
    return right;
  }
  /**
   * Returns the smaller value between two BigNumbers
   *
   * @method min
   * @param left - The first BigNumber to be compared.
   * @param right - The second BigNumber to be compared.
   * @returns - Returns the smaller value between left and right.
   *
   * @example
   * const bn1 = new BigNumber(5);
   * const bn2 = new BigNumber(10);
   * BigNumber.min(bn1, bn2); // returns bn1
   */
  static min(left, right) {
    if (left.cmp(right) < 0)
      return left;
    return right;
  }
  /**
   * Asserts that a certain condition is true. If it is not, throws an error with the provided message.
   *
   * @method assert
   * @private
   * @param val - The condition to be checked.
   * @param msg - The error message to throw if the condition is not satisfied. Default is 'Assertion failed'.
   */
  assert(val, msg = "Assertion failed") {
    if (!val)
      throw new Error(msg);
  }
  /**
   * Function to initialize a BigNumber from a regular number. It also determines if the number is negative and sets the negative property accordingly.
   * If the endianness provided is little endian ('le'), it reverses the bytes.
   *
   * @method initNumber
   * @private
   * @param number - The number to initialize the BigNumber from.
   * @param base - The base of the number provided.
   * @param endian - The endianness ('be' for big-endian, 'le' for little-endian).
   * @returns The current BigNumber instance.
   */
  initNumber(number, base, endian) {
    if (number < 0) {
      this.negative = 1;
      number = -number;
    }
    if (number < 67108864) {
      this.words = [number & 67108863];
      this.length = 1;
    } else if (number < 4503599627370496) {
      this.words = [
        number & 67108863,
        number / 67108864 & 67108863
      ];
      this.length = 2;
    } else {
      this.assert(number < 9007199254740992, "The number is larger than 2 ^ 53 (unsafe)");
      this.words = [
        number & 67108863,
        number / 67108864 & 67108863,
        1
      ];
      this.length = 3;
    }
    if (endian !== "le")
      return this;
    this.initArray(this.toArray(), endian);
    return this;
  }
  /**
   * Creates a new BigNumber from the provided number array and initializes it based on the base and endian provided.
   *
   * @method initArray
   * @private
   * @param number - The array of numbers to initialize the BigNumber from. Each number represents a part of the value of the big number.
   * @param endian - The endianness ('be' for big-endian, 'le' for little-endian).
   * @return The current BigNumber instance.
   */
  initArray(number, endian) {
    this.assert(typeof number.length === "number", "The number must have a length");
    if (number.length <= 0) {
      this.words = [0];
      this.length = 1;
      return this;
    }
    this.length = Math.ceil(number.length / 3);
    this.words = new Array(this.length);
    let i = 0;
    for (; i < this.length; i++) {
      this.words[i] = 0;
    }
    let j, w;
    let off = 0;
    if (endian === "be") {
      for (i = number.length - 1, j = 0; i >= 0; i -= 3) {
        w = number[i] | number[i - 1] << 8 | number[i - 2] << 16;
        this.words[j] |= w << off & 67108863;
        this.words[j + 1] = w >>> 26 - off & 67108863;
        off += 24;
        if (off >= 26) {
          off -= 26;
          j++;
        }
      }
    } else if (endian === "le") {
      for (i = 0, j = 0; i < number.length; i += 3) {
        w = number[i] | number[i + 1] << 8 | number[i + 2] << 16;
        this.words[j] |= w << off & 67108863;
        this.words[j + 1] = w >>> 26 - off & 67108863;
        off += 24;
        if (off >= 26) {
          off -= 26;
          j++;
        }
      }
    }
    return this.strip();
  }
  /**
   * Function to extract the 4-bit number from a hexadecimal character
   *
   * @method parseHex4Bits
   * @private
   * @param string - The string containing the hexadecimal character.
   * @param index - The index of the hexadecimal character in the string.
   * @return The decimal value corresponding to the hexadecimal character.
   */
  parseHex4Bits(string, index) {
    const c = string.charCodeAt(index);
    if (c >= 48 && c <= 57) {
      return c - 48;
    } else if (c >= 65 && c <= 70) {
      return c - 55;
    } else if (c >= 97 && c <= 102) {
      return c - 87;
    } else {
      throw new Error("Invalid character in " + string);
    }
  }
  /**
   * Function to extract the 8-bit number from two hexadecimal characters
   *
   * @method parseHexByte
   * @private
   * @param string - The string containing the hexadecimal characters.
   * @param lowerBound - The lower bound of the index to start parsing from.
   * @param index - The index of the second hexadecimal character in the string.
   * @return The decimal value corresponding to the two hexadecimal characters.
   */
  parseHexByte(string, lowerBound, index) {
    let r2 = this.parseHex4Bits(string, index);
    if (index - 1 >= lowerBound) {
      r2 |= this.parseHex4Bits(string, index - 1) << 4;
    }
    return r2;
  }
  /**
   * Function to parse and convert a specific string portion into a big number in hexadecimal base.
   *
   * @method parseHex
   * @private
   * @param number - The string to parse.
   * @param start - The index to start parsing from.
   * @param endian - The endianness ('be', 'le').
   * @return The current BigNumber instance.
   */
  parseHex(number, start, endian) {
    this.length = Math.ceil((number.length - start) / 6);
    this.words = new Array(this.length);
    let i = 0;
    for (; i < this.length; i++) {
      this.words[i] = 0;
    }
    let off = 0;
    let j = 0;
    let w;
    if (endian === "be") {
      for (i = number.length - 1; i >= start; i -= 2) {
        w = this.parseHexByte(number, start, i) << off;
        this.words[j] |= w & 67108863;
        if (off >= 18) {
          off -= 18;
          j += 1;
          this.words[j] |= w >>> 26;
        } else {
          off += 8;
        }
      }
    } else {
      const parseLength = number.length - start;
      for (i = parseLength % 2 === 0 ? start + 1 : start; i < number.length; i += 2) {
        w = this.parseHexByte(number, start, i) << off;
        this.words[j] |= w & 67108863;
        if (off >= 18) {
          off -= 18;
          j += 1;
          this.words[j] |= w >>> 26;
        } else {
          off += 8;
        }
      }
    }
    return this.strip();
  }
  /**
   * Function to convert a particular string portion into a base word.
   *
   * @method parseBaseWord
   * @private
   * @param str - The string to parse.
   * @param start - The index to start parsing from.
   * @param end - The index to stop parsing at.
   * @param mul - The base to be used for the conversion.
   * @return The decimal value of the parsed base word.
   */
  parseBaseWord(str, start, end, mul) {
    let r2 = 0;
    let b = 0;
    const len = Math.min(str.length, end);
    for (let i = start; i < len; i++) {
      const c = str.charCodeAt(i) - 48;
      r2 *= mul;
      if (c >= 49) {
        b = c - 49 + 10;
      } else if (c >= 17) {
        b = c - 17 + 10;
      } else {
        b = c;
      }
      this.assert(c >= 0 && b < mul, "Invalid character");
      r2 += b;
    }
    return r2;
  }
  /**
   * Function to convert a string into a big number in a specific base.
   *
   * @method parseBase
   * @private
   * @param number - The string to be converted into a big number.
   * @param base - The base to be used for conversion.
   * @param start - The index to start conversion from.
   * @return The current BigNumber instance.
   */
  parseBase(number, base, start) {
    this.words = [0];
    this.length = 1;
    let limbLen = 0;
    let limbPow = 1;
    for (; limbPow <= 67108863; limbPow *= base) {
      limbLen++;
    }
    limbLen--;
    limbPow = limbPow / base | 0;
    const total = number.length - start;
    const mod = total % limbLen;
    const end = Math.min(total, total - mod) + start;
    let word = 0;
    let i = start;
    for (; i < end; i += limbLen) {
      word = this.parseBaseWord(number, i, i + limbLen, base);
      this.imuln(limbPow);
      if (this.words[0] + word < 67108864) {
        this.words[0] += word;
      } else {
        this._iaddn(word);
      }
    }
    if (mod !== 0) {
      let pow = 1;
      word = this.parseBaseWord(number, i, number.length, base);
      for (i = 0; i < mod; i++) {
        pow *= base;
      }
      this.imuln(pow);
      if (this.words[0] + word < 67108864) {
        this.words[0] += word;
      } else {
        this._iaddn(word);
      }
    }
    return this.strip();
  }
  /**
   * The copy method copies the state of this BigNumber into an exsiting `dest` BigNumber.
   *
   * @method copy
   * @param dest - The BigNumber instance that will be updated to become a copy.
   *
   * @example
   * const bn1 = new BigNumber('123456', 10, 'be');
   * const bn2 = new BigNumber();
   * bn1.copy(bn2);
   * // bn2 is now a BigNumber representing 123456
   */
  copy(dest) {
    dest.words = new Array(this.length);
    for (let i = 0; i < this.length; i++) {
      dest.words[i] = this.words[i];
    }
    dest.length = this.length;
    dest.negative = this.negative;
    dest.red = this.red;
  }
  /**
   *
   * Directly transfers the attributes of the source BigNumber to the destination BigNumber.
   *
   * @method move
   * @param dest - The BigNumber that attributes will be moved into.
   * @param src - The BigNumber that attributes will be moved from.
   *
   * @example
   * const src = new BigNumber('123456', 10, 'be');
   * const dest = new BigNumber();
   * BigNumber.move(dest, src);
   * // dest is now a BigNumber representing 123456
   */
  static move(dest, src) {
    dest.words = src.words;
    dest.length = src.length;
    dest.negative = src.negative;
    dest.red = src.red;
  }
  /**
   * Creates a copy of the current BigNumber instance.
   *
   * @method clone
   * @returns A new BigNumber instance, identical to the original.
   *
   * @example
   * const bn = new BigNumber('123456', 10, 'be');
   * const bnClone = bn.clone();
   */
  clone() {
    const r2 = new _BigNumber();
    this.copy(r2);
    return r2;
  }
  /**
   * Increases the BigNumber length up to a certain size and initializes new elements with 0.
   *
   * @method expand
   * @param size - The desired size to grow the BigNumber length.
   * @returns The BigNumber instance after expansion.
   *
   * @example
   * const bn = new BigNumber('123456', 10, 'be');
   * bn.expand(10);
   */
  expand(size) {
    while (this.length < size) {
      this.words[this.length++] = 0;
    }
    return this;
  }
  /**
   * Removes leading zeros.
   *
   * @method strip
   * @returns - Returns the BigNumber after stripping leading zeros.
   *
   * @example
   * const bn = new BigNumber("000000", 2, "be");
   * bn.strip();
   * // bn now represents 0
   */
  strip() {
    while (this.length > 1 && this.words[this.length - 1] === 0) {
      this.length--;
    }
    return this.normSign();
  }
  /**
   * Normalizes the sign of the BigNumber. Changes -0 to 0.
   *
   * @method normSign
   * @returns The normalized BigNumber instance.
   *
   * @example
   * const bn = new BigNumber('-0', 10, 'be');
   * bn.normSign();
   */
  normSign() {
    if (this.length === 1 && this.words[0] === 0) {
      this.negative = 0;
    }
    return this;
  }
  /**
   * Utility for inspecting the current BigNumber instance. Accompanied with a prefix '<BN: ' or '<BN-R: '.
   *
   * @method inspect
   * @returns A string representation to inspect the BigNumber instance.
   *
   * @example
   * const bn = new BigNumber('123456', 10, 'be');
   * bn.inspect();
   */
  inspect() {
    return (this.red !== null ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
  }
  /**
   * Converts the BigNumber instance to a string representation.
   *
   * @method toString
   * @param base - The base for representing number. Default is 10. Other accepted values are 16 and 'hex'.
   * @param padding - Represents the minimum number of digits to represent the BigNumber as a string. Default is 1.
   * @throws If base is not between 2 and 36.
   * @returns The string representation of the BigNumber instance
   *
   * @example
   * const bn = new BigNumber('123456', 10, 'be');
   * bn.toString(16); // Converts the BigNumber to a hexadecimal string.
   */
  toString(base = 10, padding = 1) {
    let out;
    if (base === 16 || base === "hex") {
      out = "";
      let off = 0;
      let carry = 0;
      for (let i = 0; i < this.length; i++) {
        const w = this.words[i];
        const word = ((w << off | carry) & 16777215).toString(16);
        carry = w >>> 24 - off & 16777215;
        off += 2;
        if (off >= 26) {
          off -= 26;
          i--;
        }
        if (carry !== 0 || i !== this.length - 1) {
          out = _BigNumber.zeros[6 - word.length] + word + out;
        } else {
          out = word + out;
        }
      }
      if (carry !== 0) {
        out = carry.toString(16) + out;
      }
      if (padding === 0 && out === "0") {
        return "";
      }
      while (out.length % padding !== 0 && padding !== 0) {
        out = "0" + out;
      }
      if (this.negative !== 0) {
        out = "-" + out;
      }
      return out;
    }
    if (base === (base | 0) && base >= 2 && base <= 36) {
      const groupSize = _BigNumber.groupSizes[base];
      const groupBase = _BigNumber.groupBases[base];
      out = "";
      let c = this.clone();
      c.negative = 0;
      while (!c.isZero()) {
        const r2 = c.modrn(groupBase).toString(base);
        c = c.idivn(groupBase);
        if (!c.isZero()) {
          out = _BigNumber.zeros[groupSize - r2.length] + r2 + out;
        } else {
          out = r2 + out;
        }
      }
      if (this.isZero()) {
        out = "0" + out;
      }
      while (out.length % padding !== 0) {
        out = "0" + out;
      }
      if (this.negative !== 0) {
        out = "-" + out;
      }
      return out;
    }
    throw new Error("Base should be between 2 and 36");
  }
  /**
   * Converts the BigNumber instance to a JavaScript number.
   * Please note that JavaScript numbers are only precise up to 53 bits.
   *
   * @method toNumber
   * @throws If the BigNumber instance cannot be safely stored in a JavaScript number
   * @returns The JavaScript number representation of the BigNumber instance.
   *
   * @example
   * const bn = new BigNumber('123456', 10, 'be');
   * bn.toNumber();
   */
  toNumber() {
    let ret = this.words[0];
    if (this.length === 2) {
      ret += this.words[1] * 67108864;
    } else if (this.length === 3 && this.words[2] === 1) {
      ret += 4503599627370496 + this.words[1] * 67108864;
    } else if (this.length > 2) {
      throw new Error("Number can only safely store up to 53 bits");
    }
    return this.negative !== 0 ? -ret : ret;
  }
  /**
   * Converts the BigNumber instance to a JSON-formatted string.
   *
   * @method toJSON
   * @returns The JSON string representation of the BigNumber instance.
   *
   * @example
   * const bn = new BigNumber('123456', 10, 'be');
   * bn.toJSON();
   */
  toJSON() {
    return this.toString(16);
  }
  /**
   * An internal method to format the BigNumber instance into ArrayTypes of Little Endian Type.
   * This is a private method.
   *
   * @method toArrayLikeLE
   * @private
   * @param res - The resultant ArrayType instance
   * @param byteLength - The byte length to define the size of ArrayType
   */
  toArrayLikeLE(res, byteLength) {
    let position = 0;
    let carry = 0;
    for (let i = 0, shift = 0; i < this.length; i++) {
      const word = this.words[i] << shift | carry;
      res[position++] = word & 255;
      if (position < res.length) {
        res[position++] = word >> 8 & 255;
      }
      if (position < res.length) {
        res[position++] = word >> 16 & 255;
      }
      if (shift === 6) {
        if (position < res.length) {
          res[position++] = word >> 24 & 255;
        }
        carry = 0;
        shift = 0;
      } else {
        carry = word >>> 24;
        shift += 2;
      }
    }
    if (position < res.length) {
      res[position++] = carry;
      while (position < res.length) {
        res[position++] = 0;
      }
    }
  }
  /**
   * An internal method to format the BigNumber instance into ArrayTypes of Big Endian Type.
   * This is a private method.
   *
   * @method toArrayLikeBE
   * @private
   * @param res - The resultant ArrayType instance
   * @param byteLength - The byte length to define the size of ArrayType
   */
  toArrayLikeBE(res, byteLength) {
    let position = res.length - 1;
    let carry = 0;
    for (let i = 0, shift = 0; i < this.length; i++) {
      const word = this.words[i] << shift | carry;
      res[position--] = word & 255;
      if (position >= 0) {
        res[position--] = word >> 8 & 255;
      }
      if (position >= 0) {
        res[position--] = word >> 16 & 255;
      }
      if (shift === 6) {
        if (position >= 0) {
          res[position--] = word >> 24 & 255;
        }
        carry = 0;
        shift = 0;
      } else {
        carry = word >>> 24;
        shift += 2;
      }
    }
    if (position >= 0) {
      res[position--] = carry;
      while (position >= 0) {
        res[position--] = 0;
      }
    }
  }
  /**
   * Converts the BigNumber instance to a JavaScript number array.
   *
   * @method toArray
   * @param endian - The endian for converting BigNumber to array. Default value is 'be'.
   * @param length - The length for the resultant array. Default value is undefined.
   * @returns The JavaScript array representation of the BigNumber instance.
   *
   * @example
   * const bn = new BigNumber('123456', 10, 'be');
   * bn.toArray('be', 8);
   */
  toArray(endian = "be", length) {
    this.strip();
    const byteLength = this.byteLength();
    const reqLength = length ?? Math.max(1, byteLength);
    this.assert(byteLength <= reqLength, "byte array longer than desired length");
    this.assert(reqLength > 0, "Requested array length <= 0");
    const res = new Array(reqLength);
    if (endian === "le") {
      this.toArrayLikeLE(res, byteLength);
    } else {
      this.toArrayLikeBE(res, byteLength);
    }
    return res;
  }
  /**
   * A utility method to count the word bits.
   * This is a private method.
   *
   * @method countWordBits
   * @private
   * @param w - The input number to count the word bits.
   * @returns The number of word bits
   */
  countWordBits(w) {
    if (typeof Math.clz32 === "function") {
      return 32 - Math.clz32(w);
    }
    let t = w;
    let r2 = 0;
    if (t >= 4096) {
      r2 += 13;
      t >>>= 13;
    }
    if (t >= 64) {
      r2 += 7;
      t >>>= 7;
    }
    if (t >= 8) {
      r2 += 4;
      t >>>= 4;
    }
    if (t >= 2) {
      r2 += 2;
      t >>>= 2;
    }
    return r2 + t;
  }
  /**
   * A utility method to compute the number of zero bits.
   * This is a private method.
   *
   * @method zeroWordBits
   * @private
   * @param w - The input number to count the zero bits.
   * @returns The number of zero bits
   */
  zeroWordBits(w) {
    if (w === 0)
      return 26;
    let t = w;
    let r2 = 0;
    if ((t & 8191) === 0) {
      r2 += 13;
      t >>>= 13;
    }
    if ((t & 127) === 0) {
      r2 += 7;
      t >>>= 7;
    }
    if ((t & 15) === 0) {
      r2 += 4;
      t >>>= 4;
    }
    if ((t & 3) === 0) {
      r2 += 2;
      t >>>= 2;
    }
    if ((t & 1) === 0) {
      r2++;
    }
    return r2;
  }
  /**
   * Returns the number of used bits in this big number.
   *
   * @method bitLength
   * @returns The number of used bits
   */
  bitLength() {
    const w = this.words[this.length - 1];
    const hi = this.countWordBits(w);
    return (this.length - 1) * 26 + hi;
  }
  /**
   * Convert a big number to a boolean array representing
   * a binary number, where each array index is a bit.
   * @static
   * @method toBitArray
   * @param num - The big number to convert.
   * @returns Returns an array of booleans representing
   * a binary number, with each array index being a bit.
   * @example
   * const BigNumber = require("./BigNumber");
   * const bn = new BigNumber('6'); // binary: 110
   * const bits = BigNumber.toBitArray(bn); // [1,1,0]
   */
  static toBitArray(num) {
    const w = new Array(num.bitLength());
    for (let bit = 0; bit < w.length; bit++) {
      const off = bit / 26 | 0;
      const wbit = bit % 26;
      w[bit] = num.words[off] >>> wbit & 1;
    }
    return w;
  }
  /**
   * Convert this big number to a boolean array representing
   * a binary number, where each array index is a bit.
   * @method toBitArray
   * @returns Returns an array of booleans representing a binary number.
   *
   * @example
   * const BigNumber = require("./BigNumber");
   * const bn = new BigNumber('6'); // binary: 110
   * const bits = bn.toBitArray(); // [ 1, 1, 0 ]
   */
  toBitArray() {
    return _BigNumber.toBitArray(this);
  }
  /**
   * Returns the number of trailing zero bits in the big number.
   * @method zeroBits
   * @returns Returns the number of trailing zero bits
   * in the binary representation of the big number.
   * @example
   * const BigNumber = require("./BigNumber");
   * const bn = new BigNumber('8'); // binary: 1000
   * const zeroBits = bn.zeroBits(); // 3
   */
  zeroBits() {
    if (this.isZero())
      return 0;
    let r2 = 0;
    for (let i = 0; i < this.length; i++) {
      const b = this.zeroWordBits(this.words[i]);
      r2 += b;
      if (b !== 26)
        break;
    }
    return r2;
  }
  /**
   * Get the byte length of the BigNumber
   *
   * @method byteLength
   * @returns Returns the byte length of the big number.
   * @example
   * const BigNumber = require("./BigNumber");
   * const bn = new BigNumber('1234');
   * const byteLen = bn.byteLength();
   */
  byteLength() {
    return Math.ceil(this.bitLength() / 8);
  }
  /**
   * Converts this big number to two's complement with a specified bit width.
   * @method toTwos
   * @param width - The bit width.
   * @returns Returns the two's complement of the big number.
   *
   * @example
   * const BigNumber = require("./BigNumber");
   * const bn = new BigNumber('-1234');
   * const twosComp = bn.toTwos(16);
   */
  toTwos(width) {
    if (this.negative !== 0) {
      return this.abs().inotn(width).iaddn(1);
    }
    return this.clone();
  }
  /**
   * Converts this big number from two's complement with a specified bit width.
   * @method fromTwos
   * @param width - The bit width.
   * @returns Returns the big number converted from two's complement.
   *
   * @example
   * const BigNumber = require("./BigNumber");
   * const bn = new BigNumber('-1234');
   * const fromTwos = bn.fromTwos(16);
   */
  fromTwos(width) {
    if (this.testn(width - 1)) {
      return this.notn(width).iaddn(1).ineg();
    }
    return this.clone();
  }
  /**
   * Checks if the big number is negative.
   * @method isNeg
   * @returns Returns true if the big number is negative, otherwise false.
   *
   * @example
   * const BigNumber = require("./BigNumber");
   * const bn = new BigNumber('-1234');
   * const isNegative = bn.isNeg(); // true
   */
  isNeg() {
    return this.negative !== 0;
  }
  /**
   * Negates the big number and returns a new instance.
   * @method neg
   * @returns Returns a new BigNumber that is the negation of this big number.
   *
   * @example
   * const BigNumber = require("./BigNumber");
   * const bn = new BigNumber('1234');
   * const neg = bn.neg(); // -1234
   */
  neg() {
    return this.clone().ineg();
  }
  /**
   * Negates the big number in-place.
   * @method ineg
   * @returns Returns this big number as the negation of itself.
   *
   * @example
   * const BigNumber = require("./BigNumber");
   * const bn = new BigNumber('1234');
   * bn.ineg(); // bn is now -1234
   */
  ineg() {
    if (!this.isZero()) {
      this.negative ^= 1;
    }
    return this;
  }
  /**
   * Performs a bitwise OR operation with another BigNumber and stores
   * the result in this BigNumber.
   * @method iuor
   * @param num - The other BigNumber.
   * @returns Returns this BigNumber after performing the bitwise OR operation.
   *
   * @example
   * const BigNumber = require("./BigNumber");
   * const bn1 = new BigNumber('10'); // binary: 1010
   * const bn2 = new(num: BigNumber): BigNumber BigNumber('6'); // binary: 0110
   * bn1.iuor(bn2); // now, bn1 binary: 1110
   */
  iuor(num) {
    while (this.length < num.length) {
      this.words[this.length++] = 0;
    }
    for (let i = 0; i < num.length; i++) {
      this.words[i] = this.words[i] | num.words[i];
    }
    return this.strip();
  }
  /**
   * Performs a bitwise OR operation with another BigNumber, considering
   * that neither of the numbers can be negative. Stores the result in this BigNumber.
   * @method ior
   * @param num - The other BigNumber.
   * @returns Returns this BigNumber after performing the bitwise OR operation.
   *
   * @example
   * const BigNumber = require("./BigNumber");
   * const bn1 = new BigNumber('10'); // binary: 1010
   * const bn2 = new BigNumber('6'); // binary: 0110
   * bn1.ior(bn2); // now, bn1 binary: 1110
   */
  ior(num) {
    this.assert((this.negative | num.negative) === 0);
    return this.iuor(num);
  }
  /**
   * Performs a bitwise OR operation on the current instance and given
   * BigNumber and returns a new BigNumber, in such a way that if either
   * the corresponding bit in the first operand or the second operand is
   * 1, then the output is also 1.
   *
   * @method or
   * @param num - The BigNumber to perform the bitwise OR operation with.
   * @returns Returns a new BigNumber resulting from the bitwise OR operation.
   *
   * @example
   * const num1 = new BigNumber('10');
   * const num2 = new BigNumber('20');
   * console.log(num1.or(num2).toString());
   */
  or(num) {
    if (this.length > num.length)
      return this.clone().ior(num);
    return num.clone().ior(this);
  }
  /**
   * Performs a bitwise OR operation on the current instance and given
   * BigNumber without considering signed bit(no negative values) and returns a new BigNumber,
   * similar to the `or` method.
   *
   * @method uor
   * @param num - The BigNumber to perform the bitwise OR operation with.
   * @returns Returns a new BigNumber resulting from the bitwise OR operation without sign consideration.
   *
   * @example
   * const num1 = new BigNumber('10');
   * const num2 = new BigNumber('20');
   * console.log(num1.uor(num2).toString());
   */
  uor(num) {
    if (this.length > num.length)
      return this.clone().iuor(num);
    return num.clone().iuor(this);
  }
  /**
   * Performs a bitwise AND operation in-place(this method changes the calling object)
   * on the current instance and given BigNumber such that it modifies the current
   * instance and keeps the bits set in the result only if the corresponding bit is set
   * in both operands.
   *
   * @method iuand
   * @param num - The BigNumber to perform the bitwise AND operation with.
   * @returns Returns the current BigNumber instance after performing the bitwise AND operation.
   *
   * @example
   * const num1 = new BigNumber('10');
   * const num2 = new BigNumber('20');
   * console.log(num1.iuand(num2).toString());
   */
  iuand(num) {
    const minLength = Math.min(this.length, num.length);
    for (let i = 0; i < minLength; i++) {
      this.words[i] = this.words[i] & num.words[i];
    }
    this.length = minLength;
    return this.strip();
  }
  /**
   * Performs an in-place operation that does a bitwise AND operation in-place,
   * on the current instance and given BigNumber such that it modifies the current
   * instance only if neither operand is negative. This method is similar to the iuand method but
   * checks for negative values before operation.
   *
   * @method iand
   * @param num - The BigNumber to perform the bitwise AND operation with.
   * @returns Returns the current BigNumber instance after performing the bitwise AND operation.
   *
   * @example
   * const num1 = new BigNumber('10');
   * const num2 = new BigNumber('20');
   * console.log(num1.iand(num2).toString());
   */
  iand(num) {
    this.assert((this.negative | num.negative) === 0);
    return this.iuand(num);
  }
  /**
   * Performs a bitwise AND operation that returns a new BigNumber, and keeps the bits
   * set in the result only if the corresponding bit is set in both operands.
   *
   * @method and
   * @param num - The BigNumber to perform the bitwise AND operation with.
   * @returns Returns new BigNumber resulting from the bitwise AND operation.
   *
   * @example
   * const num1 = new BigNumber('10');
   * const num2 = new BigNumber('20');
   * console.log(num1.and(num2).toString());
   */
  and(num) {
    if (this.length > num.length)
      return this.clone().iand(num);
    return num.clone().iand(this);
  }
  /**
   * Performs a bitwise AND operation without considering signed bit
   * (no negative values) which returns a new BigNumber, similar to the `and` method.
   *
   * @method uand
   * @param num - The BigNumber to perform the bitwise AND operation with.
   * @returns Returns new BigNumber resulting from the bitwise AND operation without sign consideration.
   *
   * @example
   * const num1 = new BigNumber('10');
   * const num2 = new BigNumber('20');
   * console.log(num1.uand(num2).toString());
   */
  uand(num) {
    if (this.length > num.length)
      return this.clone().iuand(num);
    return num.clone().iuand(this);
  }
  /**
   * Modifies the current instance by performing a bitwise XOR operation
   * in-place with the provided BigNumber. It keeps the bits set in the result only if the
   * corresponding bits in the operands are different.
   *
   * @method iuxor
   * @param num - The BigNumber to perform the bitwise XOR operation with.
   * @returns Returns the current BigNumber instance after performing the bitwise XOR operation.
   *
   * @example
   * const num1 = new BigNumber('10');
   * const num2 = new BigNumber('20');
   * console.log(num1.iuxor(num2).toString());
   */
  iuxor(num) {
    if (this.length > num.length) {
      for (let i = 0; i < num.length; i++) {
        this.words[i] = this.words[i] ^ num.words[i];
      }
    } else {
      for (let i = 0; i < this.length; i++) {
        this.words[i] = this.words[i] ^ num.words[i];
      }
      for (let i = this.length; i < num.length; i++) {
        this.words[i] = num.words[i];
      }
      this.length = num.length;
    }
    return this.strip();
  }
  /**
   * Performs an in-place operation that does a bitwise XOR operation in-place,
   * on the current instance and given BigNumber such that it modifies the current
   * instance only if neither operand is negative. This method is similar to the iuxor method but
   * checks for negative values before operation.
   *
   * @method ixor
   * @param num - The BigNumber to perform the bitwise XOR operation with.
   * @returns Returns the current BigNumber instance after performing the bitwise XOR operation.
   *
   * @example
   * const num1 = new BigNumber('10');
   * const num2 = new BigNumber('20');
   * console.log(num1.ixor(num2).toString());
   */
  ixor(num) {
    this.assert((this.negative | num.negative) === 0, "Neither number can be negative");
    return this.iuxor(num);
  }
  /**
   * Performs a bitwise XOR operation which returns a new BigNumber, and keeps the bits
   * set in the result only if the corresponding bits in the operands are different.
   *
   * @method xor
   * @param num - The BigNumber to perform the bitwise XOR operation with.
   * @returns Returns a new BigNumber resulting from the bitwise XOR operation.
   *
   * @example
   * const num1 = new BigNumber('10');
   * const num2 = new BigNumber('20');
   * console.log(num1.xor(num2).toString());
   */
  xor(num) {
    if (this.length > num.length)
      return this.clone().ixor(num);
    return num.clone().ixor(this);
  }
  /**
   * Performs an unsigned XOR operation on this BigNumber with the supplied BigNumber. Returns a new BigNumber.
   *
   * @method uxor
   * @param num - The BigNumber with which the unsigned bitwise XOR operation is to be performed.
   * @returns Returns a new BigNumber resulting from the unsigned bitwise XOR operation.
   *
   * @example
   * const num1 = new BigNumber('30');
   * const num2 = new BigNumber('40');
   * console.log(num1.uxor(num2).toString()); // Output will be the result of unsigned XOR operation
   */
  uxor(num) {
    if (this.length > num.length)
      return this.clone().iuxor(num);
    return num.clone().iuxor(this);
  }
  /**
   * In-place method that performs a bitwise NOT operation on a BigNumber up to a specified bit width.
   *
   * @method inotn
   * @param width - The number of bits to perform the NOT operation on.
   * @returns Returns the BigNumber after performing the bitwise NOT operation.
   *
   * @example
   * const num = new BigNumber('42');
   * num.inotn(10);
   * console.log(num.toString());
   */
  inotn(width) {
    this.assert(typeof width === "number" && width >= 0, "The width needs to be a number greater than zero");
    let bytesNeeded = Math.ceil(width / 26) | 0;
    const bitsLeft = width % 26;
    this.expand(bytesNeeded);
    if (bitsLeft > 0) {
      bytesNeeded--;
    }
    let i = 0;
    for (; i < bytesNeeded; i++) {
      this.words[i] = ~this.words[i] & 67108863;
    }
    if (bitsLeft > 0) {
      this.words[i] = ~this.words[i] & 67108863 >> 26 - bitsLeft;
    }
    return this.strip();
  }
  /**
   * Performs a bitwise NOT operation on a BigNumber up to a specified bit width. Returns a new BigNumber.
   *
   * @method notn
   * @param width - The number of bits to perform the NOT operation on.
   * @returns Returns a new BigNumber resulting from the bitwise NOT operation.
   *
   * @example
   * const num = new BigNumber('42');
   * const notnResult = num.notn(10);
   * console.log(notnResult.toString());
   */
  notn(width) {
    return this.clone().inotn(width);
  }
  /**
   * Set `bit` of `this` BigNumber. The `bit` is a position in the binary representation,
   * and `val` is the value to be set at that position (`0` or `1`).
   *
   * @method setn
   * @param bit - The bit position to set.
   * @param val - The value to set at the bit position.
   * @returns Returns the BigNumber after setting the value at the bit position.
   *
   * @example
   * const num = new BigNumber('42');
   * num.setn(2, 1);
   * console.log(num.toString());
   */
  setn(bit, val) {
    this.assert(typeof bit === "number" && bit >= 0);
    const off = bit / 26 | 0;
    const wbit = bit % 26;
    this.expand(off + 1);
    if (val === 1 || val === true) {
      this.words[off] = this.words[off] | 1 << wbit;
    } else {
      this.words[off] = this.words[off] & ~(1 << wbit);
    }
    return this.strip();
  }
  /**
   * Add `num` to `this` BigNumber in-place.
   *
   * @method iadd
   * @param num - The BigNumber to add to `this` BigNumber.
   * @returns Returns the BigNumber after performing the addition.
   *
   * @example
   * const num1 = new BigNumber('10');
   * num1.iadd(new BigNumber('20'));
   * console.log(num1.toString());
   */
  iadd(num) {
    let r2;
    if (this.negative !== 0 && num.negative === 0) {
      this.negative = 0;
      r2 = this.isub(num);
      this.negative ^= 1;
      return this.normSign();
    } else if (this.negative === 0 && num.negative !== 0) {
      num.negative = 0;
      r2 = this.isub(num);
      num.negative = 1;
      return r2.normSign();
    }
    let a, b;
    if (this.length > num.length) {
      a = this;
      b = num;
    } else {
      a = num;
      b = this;
    }
    let carry = 0;
    let i = 0;
    for (; i < b.length; i++) {
      r2 = (a.words[i] | 0) + (b.words[i] | 0) + carry;
      this.words[i] = r2 & 67108863;
      carry = r2 >>> 26;
    }
    for (; carry !== 0 && i < a.length; i++) {
      r2 = (a.words[i] | 0) + carry;
      this.words[i] = r2 & 67108863;
      carry = r2 >>> 26;
    }
    this.length = a.length;
    if (carry !== 0) {
      this.words[this.length] = carry;
      this.length++;
    } else if (a !== this) {
      for (; i < a.length; i++) {
        this.words[i] = a.words[i];
      }
    }
    return this;
  }
  /**
   * Add `num` to `this` BigNumber.
   *
   * @method add
   * @param num - The BigNumber to add to `this` BigNumber.
   * @returns Returns a new BigNumber which is the result of the addition.
   *
   * @example
   * const num1 = new BigNumber('10');
   * const addResult = num1.add(new BigNumber('20'));
   * console.log(addResult.toString());
   */
  add(num) {
    let res;
    if (num.negative !== 0 && this.negative === 0) {
      num.negative = 0;
      res = this.sub(num);
      num.negative ^= 1;
      return res;
    } else if (num.negative === 0 && this.negative !== 0) {
      this.negative = 0;
      res = num.sub(this);
      this.negative = 1;
      return res;
    }
    if (this.length > num.length)
      return this.clone().iadd(num);
    return num.clone().iadd(this);
  }
  /**
   * Subtract `num` from `this` BigNumber in-place.
   *
   * @method isub
   * @param num - The BigNumber to be subtracted from `this` BigNumber.
   * @returns Returns the BigNumber after performing the subtraction.
   *
   * @example
   * const num1 = new BigNumber('20');
   * num1.isub(new BigNumber('10'));
   * console.log(num1.toString());
   */
  isub(num) {
    let r2;
    if (num.negative !== 0) {
      num.negative = 0;
      r2 = this.iadd(num);
      num.negative = 1;
      return r2.normSign();
    } else if (this.negative !== 0) {
      this.negative = 0;
      this.iadd(num);
      this.negative = 1;
      return this.normSign();
    }
    const cmp = this.cmp(num);
    if (cmp === 0) {
      this.negative = 0;
      this.length = 1;
      this.words[0] = 0;
      return this;
    }
    let a, b;
    if (cmp > 0) {
      a = this;
      b = num;
    } else {
      a = num;
      b = this;
    }
    let carry = 0;
    let i = 0;
    for (; i < b.length; i++) {
      r2 = (a.words[i] | 0) - (b.words[i] | 0) + carry;
      carry = r2 >> 26;
      this.words[i] = r2 & 67108863;
    }
    for (; carry !== 0 && i < a.length; i++) {
      r2 = (a.words[i] | 0) + carry;
      carry = r2 >> 26;
      this.words[i] = r2 & 67108863;
    }
    if (carry === 0 && i < a.length && a !== this) {
      for (; i < a.length; i++) {
        this.words[i] = a.words[i];
      }
    }
    this.length = Math.max(this.length, i);
    if (a !== this) {
      this.negative = 1;
    }
    return this.strip();
  }
  /**
   * Subtract `num` from `this` BigNumber.
   *
   * @method sub
   * @param num - The BigNumber to be subtracted from `this` BigNumber.
   * @returns Returns a new BigNumber which is the result of the subtraction.
   *
   * @example
   * const num1 = new BigNumber('20');
   * const subResult = num1.sub(new BigNumber('10'));
   * console.log(subResult.toString());
   */
  sub(num) {
    return this.clone().isub(num);
  }
  smallMulTo(self2, num, out) {
    out.negative = num.negative ^ self2.negative;
    let len = self2.length + num.length | 0;
    out.length = len;
    len = len - 1 | 0;
    let a = self2.words[0] | 0;
    let b = num.words[0] | 0;
    let r2 = a * b;
    const lo = r2 & 67108863;
    let carry = r2 / 67108864 | 0;
    out.words[0] = lo;
    let k = 1;
    for (; k < len; k++) {
      let ncarry = carry >>> 26;
      let rword = carry & 67108863;
      const maxJ = Math.min(k, num.length - 1);
      for (let j = Math.max(0, k - self2.length + 1); j <= maxJ; j++) {
        const i = k - j | 0;
        a = self2.words[i] | 0;
        b = num.words[j] | 0;
        r2 = a * b + rword;
        ncarry += r2 / 67108864 | 0;
        rword = r2 & 67108863;
      }
      out.words[k] = rword | 0;
      carry = ncarry | 0;
    }
    if (carry !== 0) {
      out.words[k] = carry | 0;
    } else {
      out.length--;
    }
    return out.strip();
  }
  comb10MulTo(self2, num, out) {
    const a = self2.words;
    const b = num.words;
    const o = out.words;
    let c = 0;
    let lo;
    let mid;
    let hi;
    const a0 = a[0] | 0;
    const al0 = a0 & 8191;
    const ah0 = a0 >>> 13;
    const a1 = a[1] | 0;
    const al1 = a1 & 8191;
    const ah1 = a1 >>> 13;
    const a2 = a[2] | 0;
    const al2 = a2 & 8191;
    const ah2 = a2 >>> 13;
    const a3 = a[3] | 0;
    const al3 = a3 & 8191;
    const ah3 = a3 >>> 13;
    const a4 = a[4] | 0;
    const al4 = a4 & 8191;
    const ah4 = a4 >>> 13;
    const a5 = a[5] | 0;
    const al5 = a5 & 8191;
    const ah5 = a5 >>> 13;
    const a6 = a[6] | 0;
    const al6 = a6 & 8191;
    const ah6 = a6 >>> 13;
    const a7 = a[7] | 0;
    const al7 = a7 & 8191;
    const ah7 = a7 >>> 13;
    const a8 = a[8] | 0;
    const al8 = a8 & 8191;
    const ah8 = a8 >>> 13;
    const a9 = a[9] | 0;
    const al9 = a9 & 8191;
    const ah9 = a9 >>> 13;
    const b0 = b[0] | 0;
    const bl0 = b0 & 8191;
    const bh0 = b0 >>> 13;
    const b1 = b[1] | 0;
    const bl1 = b1 & 8191;
    const bh1 = b1 >>> 13;
    const b2 = b[2] | 0;
    const bl2 = b2 & 8191;
    const bh2 = b2 >>> 13;
    const b3 = b[3] | 0;
    const bl3 = b3 & 8191;
    const bh3 = b3 >>> 13;
    const b4 = b[4] | 0;
    const bl4 = b4 & 8191;
    const bh4 = b4 >>> 13;
    const b5 = b[5] | 0;
    const bl5 = b5 & 8191;
    const bh5 = b5 >>> 13;
    const b6 = b[6] | 0;
    const bl6 = b6 & 8191;
    const bh6 = b6 >>> 13;
    const b7 = b[7] | 0;
    const bl7 = b7 & 8191;
    const bh7 = b7 >>> 13;
    const b8 = b[8] | 0;
    const bl8 = b8 & 8191;
    const bh8 = b8 >>> 13;
    const b9 = b[9] | 0;
    const bl9 = b9 & 8191;
    const bh9 = b9 >>> 13;
    out.negative = self2.negative ^ num.negative;
    out.length = 19;
    lo = Math.imul(al0, bl0);
    mid = Math.imul(al0, bh0);
    mid = mid + Math.imul(ah0, bl0) | 0;
    hi = Math.imul(ah0, bh0);
    let w0 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w0 >>> 26) | 0;
    w0 &= 67108863;
    lo = Math.imul(al1, bl0);
    mid = Math.imul(al1, bh0);
    mid = mid + Math.imul(ah1, bl0) | 0;
    hi = Math.imul(ah1, bh0);
    lo = lo + Math.imul(al0, bl1) | 0;
    mid = mid + Math.imul(al0, bh1) | 0;
    mid = mid + Math.imul(ah0, bl1) | 0;
    hi = hi + Math.imul(ah0, bh1) | 0;
    let w1 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w1 >>> 26) | 0;
    w1 &= 67108863;
    lo = Math.imul(al2, bl0);
    mid = Math.imul(al2, bh0);
    mid = mid + Math.imul(ah2, bl0) | 0;
    hi = Math.imul(ah2, bh0);
    lo = lo + Math.imul(al1, bl1) | 0;
    mid = mid + Math.imul(al1, bh1) | 0;
    mid = mid + Math.imul(ah1, bl1) | 0;
    hi = hi + Math.imul(ah1, bh1) | 0;
    lo = lo + Math.imul(al0, bl2) | 0;
    mid = mid + Math.imul(al0, bh2) | 0;
    mid = mid + Math.imul(ah0, bl2) | 0;
    hi = hi + Math.imul(ah0, bh2) | 0;
    let w2 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w2 >>> 26) | 0;
    w2 &= 67108863;
    lo = Math.imul(al3, bl0);
    mid = Math.imul(al3, bh0);
    mid = mid + Math.imul(ah3, bl0) | 0;
    hi = Math.imul(ah3, bh0);
    lo = lo + Math.imul(al2, bl1) | 0;
    mid = mid + Math.imul(al2, bh1) | 0;
    mid = mid + Math.imul(ah2, bl1) | 0;
    hi = hi + Math.imul(ah2, bh1) | 0;
    lo = lo + Math.imul(al1, bl2) | 0;
    mid = mid + Math.imul(al1, bh2) | 0;
    mid = mid + Math.imul(ah1, bl2) | 0;
    hi = hi + Math.imul(ah1, bh2) | 0;
    lo = lo + Math.imul(al0, bl3) | 0;
    mid = mid + Math.imul(al0, bh3) | 0;
    mid = mid + Math.imul(ah0, bl3) | 0;
    hi = hi + Math.imul(ah0, bh3) | 0;
    let w3 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w3 >>> 26) | 0;
    w3 &= 67108863;
    lo = Math.imul(al4, bl0);
    mid = Math.imul(al4, bh0);
    mid = mid + Math.imul(ah4, bl0) | 0;
    hi = Math.imul(ah4, bh0);
    lo = lo + Math.imul(al3, bl1) | 0;
    mid = mid + Math.imul(al3, bh1) | 0;
    mid = mid + Math.imul(ah3, bl1) | 0;
    hi = hi + Math.imul(ah3, bh1) | 0;
    lo = lo + Math.imul(al2, bl2) | 0;
    mid = mid + Math.imul(al2, bh2) | 0;
    mid = mid + Math.imul(ah2, bl2) | 0;
    hi = hi + Math.imul(ah2, bh2) | 0;
    lo = lo + Math.imul(al1, bl3) | 0;
    mid = mid + Math.imul(al1, bh3) | 0;
    mid = mid + Math.imul(ah1, bl3) | 0;
    hi = hi + Math.imul(ah1, bh3) | 0;
    lo = lo + Math.imul(al0, bl4) | 0;
    mid = mid + Math.imul(al0, bh4) | 0;
    mid = mid + Math.imul(ah0, bl4) | 0;
    hi = hi + Math.imul(ah0, bh4) | 0;
    let w4 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w4 >>> 26) | 0;
    w4 &= 67108863;
    lo = Math.imul(al5, bl0);
    mid = Math.imul(al5, bh0);
    mid = mid + Math.imul(ah5, bl0) | 0;
    hi = Math.imul(ah5, bh0);
    lo = lo + Math.imul(al4, bl1) | 0;
    mid = mid + Math.imul(al4, bh1) | 0;
    mid = mid + Math.imul(ah4, bl1) | 0;
    hi = hi + Math.imul(ah4, bh1) | 0;
    lo = lo + Math.imul(al3, bl2) | 0;
    mid = mid + Math.imul(al3, bh2) | 0;
    mid = mid + Math.imul(ah3, bl2) | 0;
    hi = hi + Math.imul(ah3, bh2) | 0;
    lo = lo + Math.imul(al2, bl3) | 0;
    mid = mid + Math.imul(al2, bh3) | 0;
    mid = mid + Math.imul(ah2, bl3) | 0;
    hi = hi + Math.imul(ah2, bh3) | 0;
    lo = lo + Math.imul(al1, bl4) | 0;
    mid = mid + Math.imul(al1, bh4) | 0;
    mid = mid + Math.imul(ah1, bl4) | 0;
    hi = hi + Math.imul(ah1, bh4) | 0;
    lo = lo + Math.imul(al0, bl5) | 0;
    mid = mid + Math.imul(al0, bh5) | 0;
    mid = mid + Math.imul(ah0, bl5) | 0;
    hi = hi + Math.imul(ah0, bh5) | 0;
    let w5 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w5 >>> 26) | 0;
    w5 &= 67108863;
    lo = Math.imul(al6, bl0);
    mid = Math.imul(al6, bh0);
    mid = mid + Math.imul(ah6, bl0) | 0;
    hi = Math.imul(ah6, bh0);
    lo = lo + Math.imul(al5, bl1) | 0;
    mid = mid + Math.imul(al5, bh1) | 0;
    mid = mid + Math.imul(ah5, bl1) | 0;
    hi = hi + Math.imul(ah5, bh1) | 0;
    lo = lo + Math.imul(al4, bl2) | 0;
    mid = mid + Math.imul(al4, bh2) | 0;
    mid = mid + Math.imul(ah4, bl2) | 0;
    hi = hi + Math.imul(ah4, bh2) | 0;
    lo = lo + Math.imul(al3, bl3) | 0;
    mid = mid + Math.imul(al3, bh3) | 0;
    mid = mid + Math.imul(ah3, bl3) | 0;
    hi = hi + Math.imul(ah3, bh3) | 0;
    lo = lo + Math.imul(al2, bl4) | 0;
    mid = mid + Math.imul(al2, bh4) | 0;
    mid = mid + Math.imul(ah2, bl4) | 0;
    hi = hi + Math.imul(ah2, bh4) | 0;
    lo = lo + Math.imul(al1, bl5) | 0;
    mid = mid + Math.imul(al1, bh5) | 0;
    mid = mid + Math.imul(ah1, bl5) | 0;
    hi = hi + Math.imul(ah1, bh5) | 0;
    lo = lo + Math.imul(al0, bl6) | 0;
    mid = mid + Math.imul(al0, bh6) | 0;
    mid = mid + Math.imul(ah0, bl6) | 0;
    hi = hi + Math.imul(ah0, bh6) | 0;
    let w6 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w6 >>> 26) | 0;
    w6 &= 67108863;
    lo = Math.imul(al7, bl0);
    mid = Math.imul(al7, bh0);
    mid = mid + Math.imul(ah7, bl0) | 0;
    hi = Math.imul(ah7, bh0);
    lo = lo + Math.imul(al6, bl1) | 0;
    mid = mid + Math.imul(al6, bh1) | 0;
    mid = mid + Math.imul(ah6, bl1) | 0;
    hi = hi + Math.imul(ah6, bh1) | 0;
    lo = lo + Math.imul(al5, bl2) | 0;
    mid = mid + Math.imul(al5, bh2) | 0;
    mid = mid + Math.imul(ah5, bl2) | 0;
    hi = hi + Math.imul(ah5, bh2) | 0;
    lo = lo + Math.imul(al4, bl3) | 0;
    mid = mid + Math.imul(al4, bh3) | 0;
    mid = mid + Math.imul(ah4, bl3) | 0;
    hi = hi + Math.imul(ah4, bh3) | 0;
    lo = lo + Math.imul(al3, bl4) | 0;
    mid = mid + Math.imul(al3, bh4) | 0;
    mid = mid + Math.imul(ah3, bl4) | 0;
    hi = hi + Math.imul(ah3, bh4) | 0;
    lo = lo + Math.imul(al2, bl5) | 0;
    mid = mid + Math.imul(al2, bh5) | 0;
    mid = mid + Math.imul(ah2, bl5) | 0;
    hi = hi + Math.imul(ah2, bh5) | 0;
    lo = lo + Math.imul(al1, bl6) | 0;
    mid = mid + Math.imul(al1, bh6) | 0;
    mid = mid + Math.imul(ah1, bl6) | 0;
    hi = hi + Math.imul(ah1, bh6) | 0;
    lo = lo + Math.imul(al0, bl7) | 0;
    mid = mid + Math.imul(al0, bh7) | 0;
    mid = mid + Math.imul(ah0, bl7) | 0;
    hi = hi + Math.imul(ah0, bh7) | 0;
    let w7 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w7 >>> 26) | 0;
    w7 &= 67108863;
    lo = Math.imul(al8, bl0);
    mid = Math.imul(al8, bh0);
    mid = mid + Math.imul(ah8, bl0) | 0;
    hi = Math.imul(ah8, bh0);
    lo = lo + Math.imul(al7, bl1) | 0;
    mid = mid + Math.imul(al7, bh1) | 0;
    mid = mid + Math.imul(ah7, bl1) | 0;
    hi = hi + Math.imul(ah7, bh1) | 0;
    lo = lo + Math.imul(al6, bl2) | 0;
    mid = mid + Math.imul(al6, bh2) | 0;
    mid = mid + Math.imul(ah6, bl2) | 0;
    hi = hi + Math.imul(ah6, bh2) | 0;
    lo = lo + Math.imul(al5, bl3) | 0;
    mid = mid + Math.imul(al5, bh3) | 0;
    mid = mid + Math.imul(ah5, bl3) | 0;
    hi = hi + Math.imul(ah5, bh3) | 0;
    lo = lo + Math.imul(al4, bl4) | 0;
    mid = mid + Math.imul(al4, bh4) | 0;
    mid = mid + Math.imul(ah4, bl4) | 0;
    hi = hi + Math.imul(ah4, bh4) | 0;
    lo = lo + Math.imul(al3, bl5) | 0;
    mid = mid + Math.imul(al3, bh5) | 0;
    mid = mid + Math.imul(ah3, bl5) | 0;
    hi = hi + Math.imul(ah3, bh5) | 0;
    lo = lo + Math.imul(al2, bl6) | 0;
    mid = mid + Math.imul(al2, bh6) | 0;
    mid = mid + Math.imul(ah2, bl6) | 0;
    hi = hi + Math.imul(ah2, bh6) | 0;
    lo = lo + Math.imul(al1, bl7) | 0;
    mid = mid + Math.imul(al1, bh7) | 0;
    mid = mid + Math.imul(ah1, bl7) | 0;
    hi = hi + Math.imul(ah1, bh7) | 0;
    lo = lo + Math.imul(al0, bl8) | 0;
    mid = mid + Math.imul(al0, bh8) | 0;
    mid = mid + Math.imul(ah0, bl8) | 0;
    hi = hi + Math.imul(ah0, bh8) | 0;
    let w8 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w8 >>> 26) | 0;
    w8 &= 67108863;
    lo = Math.imul(al9, bl0);
    mid = Math.imul(al9, bh0);
    mid = mid + Math.imul(ah9, bl0) | 0;
    hi = Math.imul(ah9, bh0);
    lo = lo + Math.imul(al8, bl1) | 0;
    mid = mid + Math.imul(al8, bh1) | 0;
    mid = mid + Math.imul(ah8, bl1) | 0;
    hi = hi + Math.imul(ah8, bh1) | 0;
    lo = lo + Math.imul(al7, bl2) | 0;
    mid = mid + Math.imul(al7, bh2) | 0;
    mid = mid + Math.imul(ah7, bl2) | 0;
    hi = hi + Math.imul(ah7, bh2) | 0;
    lo = lo + Math.imul(al6, bl3) | 0;
    mid = mid + Math.imul(al6, bh3) | 0;
    mid = mid + Math.imul(ah6, bl3) | 0;
    hi = hi + Math.imul(ah6, bh3) | 0;
    lo = lo + Math.imul(al5, bl4) | 0;
    mid = mid + Math.imul(al5, bh4) | 0;
    mid = mid + Math.imul(ah5, bl4) | 0;
    hi = hi + Math.imul(ah5, bh4) | 0;
    lo = lo + Math.imul(al4, bl5) | 0;
    mid = mid + Math.imul(al4, bh5) | 0;
    mid = mid + Math.imul(ah4, bl5) | 0;
    hi = hi + Math.imul(ah4, bh5) | 0;
    lo = lo + Math.imul(al3, bl6) | 0;
    mid = mid + Math.imul(al3, bh6) | 0;
    mid = mid + Math.imul(ah3, bl6) | 0;
    hi = hi + Math.imul(ah3, bh6) | 0;
    lo = lo + Math.imul(al2, bl7) | 0;
    mid = mid + Math.imul(al2, bh7) | 0;
    mid = mid + Math.imul(ah2, bl7) | 0;
    hi = hi + Math.imul(ah2, bh7) | 0;
    lo = lo + Math.imul(al1, bl8) | 0;
    mid = mid + Math.imul(al1, bh8) | 0;
    mid = mid + Math.imul(ah1, bl8) | 0;
    hi = hi + Math.imul(ah1, bh8) | 0;
    lo = lo + Math.imul(al0, bl9) | 0;
    mid = mid + Math.imul(al0, bh9) | 0;
    mid = mid + Math.imul(ah0, bl9) | 0;
    hi = hi + Math.imul(ah0, bh9) | 0;
    let w9 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w9 >>> 26) | 0;
    w9 &= 67108863;
    lo = Math.imul(al9, bl1);
    mid = Math.imul(al9, bh1);
    mid = mid + Math.imul(ah9, bl1) | 0;
    hi = Math.imul(ah9, bh1);
    lo = lo + Math.imul(al8, bl2) | 0;
    mid = mid + Math.imul(al8, bh2) | 0;
    mid = mid + Math.imul(ah8, bl2) | 0;
    hi = hi + Math.imul(ah8, bh2) | 0;
    lo = lo + Math.imul(al7, bl3) | 0;
    mid = mid + Math.imul(al7, bh3) | 0;
    mid = mid + Math.imul(ah7, bl3) | 0;
    hi = hi + Math.imul(ah7, bh3) | 0;
    lo = lo + Math.imul(al6, bl4) | 0;
    mid = mid + Math.imul(al6, bh4) | 0;
    mid = mid + Math.imul(ah6, bl4) | 0;
    hi = hi + Math.imul(ah6, bh4) | 0;
    lo = lo + Math.imul(al5, bl5) | 0;
    mid = mid + Math.imul(al5, bh5) | 0;
    mid = mid + Math.imul(ah5, bl5) | 0;
    hi = hi + Math.imul(ah5, bh5) | 0;
    lo = lo + Math.imul(al4, bl6) | 0;
    mid = mid + Math.imul(al4, bh6) | 0;
    mid = mid + Math.imul(ah4, bl6) | 0;
    hi = hi + Math.imul(ah4, bh6) | 0;
    lo = lo + Math.imul(al3, bl7) | 0;
    mid = mid + Math.imul(al3, bh7) | 0;
    mid = mid + Math.imul(ah3, bl7) | 0;
    hi = hi + Math.imul(ah3, bh7) | 0;
    lo = lo + Math.imul(al2, bl8) | 0;
    mid = mid + Math.imul(al2, bh8) | 0;
    mid = mid + Math.imul(ah2, bl8) | 0;
    hi = hi + Math.imul(ah2, bh8) | 0;
    lo = lo + Math.imul(al1, bl9) | 0;
    mid = mid + Math.imul(al1, bh9) | 0;
    mid = mid + Math.imul(ah1, bl9) | 0;
    hi = hi + Math.imul(ah1, bh9) | 0;
    let w10 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
    w10 &= 67108863;
    lo = Math.imul(al9, bl2);
    mid = Math.imul(al9, bh2);
    mid = mid + Math.imul(ah9, bl2) | 0;
    hi = Math.imul(ah9, bh2);
    lo = lo + Math.imul(al8, bl3) | 0;
    mid = mid + Math.imul(al8, bh3) | 0;
    mid = mid + Math.imul(ah8, bl3) | 0;
    hi = hi + Math.imul(ah8, bh3) | 0;
    lo = lo + Math.imul(al7, bl4) | 0;
    mid = mid + Math.imul(al7, bh4) | 0;
    mid = mid + Math.imul(ah7, bl4) | 0;
    hi = hi + Math.imul(ah7, bh4) | 0;
    lo = lo + Math.imul(al6, bl5) | 0;
    mid = mid + Math.imul(al6, bh5) | 0;
    mid = mid + Math.imul(ah6, bl5) | 0;
    hi = hi + Math.imul(ah6, bh5) | 0;
    lo = lo + Math.imul(al5, bl6) | 0;
    mid = mid + Math.imul(al5, bh6) | 0;
    mid = mid + Math.imul(ah5, bl6) | 0;
    hi = hi + Math.imul(ah5, bh6) | 0;
    lo = lo + Math.imul(al4, bl7) | 0;
    mid = mid + Math.imul(al4, bh7) | 0;
    mid = mid + Math.imul(ah4, bl7) | 0;
    hi = hi + Math.imul(ah4, bh7) | 0;
    lo = lo + Math.imul(al3, bl8) | 0;
    mid = mid + Math.imul(al3, bh8) | 0;
    mid = mid + Math.imul(ah3, bl8) | 0;
    hi = hi + Math.imul(ah3, bh8) | 0;
    lo = lo + Math.imul(al2, bl9) | 0;
    mid = mid + Math.imul(al2, bh9) | 0;
    mid = mid + Math.imul(ah2, bl9) | 0;
    hi = hi + Math.imul(ah2, bh9) | 0;
    let w11 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
    w11 &= 67108863;
    lo = Math.imul(al9, bl3);
    mid = Math.imul(al9, bh3);
    mid = mid + Math.imul(ah9, bl3) | 0;
    hi = Math.imul(ah9, bh3);
    lo = lo + Math.imul(al8, bl4) | 0;
    mid = mid + Math.imul(al8, bh4) | 0;
    mid = mid + Math.imul(ah8, bl4) | 0;
    hi = hi + Math.imul(ah8, bh4) | 0;
    lo = lo + Math.imul(al7, bl5) | 0;
    mid = mid + Math.imul(al7, bh5) | 0;
    mid = mid + Math.imul(ah7, bl5) | 0;
    hi = hi + Math.imul(ah7, bh5) | 0;
    lo = lo + Math.imul(al6, bl6) | 0;
    mid = mid + Math.imul(al6, bh6) | 0;
    mid = mid + Math.imul(ah6, bl6) | 0;
    hi = hi + Math.imul(ah6, bh6) | 0;
    lo = lo + Math.imul(al5, bl7) | 0;
    mid = mid + Math.imul(al5, bh7) | 0;
    mid = mid + Math.imul(ah5, bl7) | 0;
    hi = hi + Math.imul(ah5, bh7) | 0;
    lo = lo + Math.imul(al4, bl8) | 0;
    mid = mid + Math.imul(al4, bh8) | 0;
    mid = mid + Math.imul(ah4, bl8) | 0;
    hi = hi + Math.imul(ah4, bh8) | 0;
    lo = lo + Math.imul(al3, bl9) | 0;
    mid = mid + Math.imul(al3, bh9) | 0;
    mid = mid + Math.imul(ah3, bl9) | 0;
    hi = hi + Math.imul(ah3, bh9) | 0;
    let w12 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
    w12 &= 67108863;
    lo = Math.imul(al9, bl4);
    mid = Math.imul(al9, bh4);
    mid = mid + Math.imul(ah9, bl4) | 0;
    hi = Math.imul(ah9, bh4);
    lo = lo + Math.imul(al8, bl5) | 0;
    mid = mid + Math.imul(al8, bh5) | 0;
    mid = mid + Math.imul(ah8, bl5) | 0;
    hi = hi + Math.imul(ah8, bh5) | 0;
    lo = lo + Math.imul(al7, bl6) | 0;
    mid = mid + Math.imul(al7, bh6) | 0;
    mid = mid + Math.imul(ah7, bl6) | 0;
    hi = hi + Math.imul(ah7, bh6) | 0;
    lo = lo + Math.imul(al6, bl7) | 0;
    mid = mid + Math.imul(al6, bh7) | 0;
    mid = mid + Math.imul(ah6, bl7) | 0;
    hi = hi + Math.imul(ah6, bh7) | 0;
    lo = lo + Math.imul(al5, bl8) | 0;
    mid = mid + Math.imul(al5, bh8) | 0;
    mid = mid + Math.imul(ah5, bl8) | 0;
    hi = hi + Math.imul(ah5, bh8) | 0;
    lo = lo + Math.imul(al4, bl9) | 0;
    mid = mid + Math.imul(al4, bh9) | 0;
    mid = mid + Math.imul(ah4, bl9) | 0;
    hi = hi + Math.imul(ah4, bh9) | 0;
    let w13 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
    w13 &= 67108863;
    lo = Math.imul(al9, bl5);
    mid = Math.imul(al9, bh5);
    mid = mid + Math.imul(ah9, bl5) | 0;
    hi = Math.imul(ah9, bh5);
    lo = lo + Math.imul(al8, bl6) | 0;
    mid = mid + Math.imul(al8, bh6) | 0;
    mid = mid + Math.imul(ah8, bl6) | 0;
    hi = hi + Math.imul(ah8, bh6) | 0;
    lo = lo + Math.imul(al7, bl7) | 0;
    mid = mid + Math.imul(al7, bh7) | 0;
    mid = mid + Math.imul(ah7, bl7) | 0;
    hi = hi + Math.imul(ah7, bh7) | 0;
    lo = lo + Math.imul(al6, bl8) | 0;
    mid = mid + Math.imul(al6, bh8) | 0;
    mid = mid + Math.imul(ah6, bl8) | 0;
    hi = hi + Math.imul(ah6, bh8) | 0;
    lo = lo + Math.imul(al5, bl9) | 0;
    mid = mid + Math.imul(al5, bh9) | 0;
    mid = mid + Math.imul(ah5, bl9) | 0;
    hi = hi + Math.imul(ah5, bh9) | 0;
    let w14 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
    w14 &= 67108863;
    lo = Math.imul(al9, bl6);
    mid = Math.imul(al9, bh6);
    mid = mid + Math.imul(ah9, bl6) | 0;
    hi = Math.imul(ah9, bh6);
    lo = lo + Math.imul(al8, bl7) | 0;
    mid = mid + Math.imul(al8, bh7) | 0;
    mid = mid + Math.imul(ah8, bl7) | 0;
    hi = hi + Math.imul(ah8, bh7) | 0;
    lo = lo + Math.imul(al7, bl8) | 0;
    mid = mid + Math.imul(al7, bh8) | 0;
    mid = mid + Math.imul(ah7, bl8) | 0;
    hi = hi + Math.imul(ah7, bh8) | 0;
    lo = lo + Math.imul(al6, bl9) | 0;
    mid = mid + Math.imul(al6, bh9) | 0;
    mid = mid + Math.imul(ah6, bl9) | 0;
    hi = hi + Math.imul(ah6, bh9) | 0;
    let w15 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
    w15 &= 67108863;
    lo = Math.imul(al9, bl7);
    mid = Math.imul(al9, bh7);
    mid = mid + Math.imul(ah9, bl7) | 0;
    hi = Math.imul(ah9, bh7);
    lo = lo + Math.imul(al8, bl8) | 0;
    mid = mid + Math.imul(al8, bh8) | 0;
    mid = mid + Math.imul(ah8, bl8) | 0;
    hi = hi + Math.imul(ah8, bh8) | 0;
    lo = lo + Math.imul(al7, bl9) | 0;
    mid = mid + Math.imul(al7, bh9) | 0;
    mid = mid + Math.imul(ah7, bl9) | 0;
    hi = hi + Math.imul(ah7, bh9) | 0;
    let w16 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
    w16 &= 67108863;
    lo = Math.imul(al9, bl8);
    mid = Math.imul(al9, bh8);
    mid = mid + Math.imul(ah9, bl8) | 0;
    hi = Math.imul(ah9, bh8);
    lo = lo + Math.imul(al8, bl9) | 0;
    mid = mid + Math.imul(al8, bh9) | 0;
    mid = mid + Math.imul(ah8, bl9) | 0;
    hi = hi + Math.imul(ah8, bh9) | 0;
    let w17 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
    w17 &= 67108863;
    lo = Math.imul(al9, bl9);
    mid = Math.imul(al9, bh9);
    mid = mid + Math.imul(ah9, bl9) | 0;
    hi = Math.imul(ah9, bh9);
    let w18 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
    w18 &= 67108863;
    o[0] = w0;
    o[1] = w1;
    o[2] = w2;
    o[3] = w3;
    o[4] = w4;
    o[5] = w5;
    o[6] = w6;
    o[7] = w7;
    o[8] = w8;
    o[9] = w9;
    o[10] = w10;
    o[11] = w11;
    o[12] = w12;
    o[13] = w13;
    o[14] = w14;
    o[15] = w15;
    o[16] = w16;
    o[17] = w17;
    o[18] = w18;
    if (c !== 0) {
      o[19] = c;
      out.length++;
    }
    return out;
  }
  bigMulTo(self2, num, out) {
    out.negative = num.negative ^ self2.negative;
    out.length = self2.length + num.length;
    let carry = 0;
    let hncarry = 0;
    let k = 0;
    for (; k < out.length - 1; k++) {
      let ncarry = hncarry;
      hncarry = 0;
      let rword = carry & 67108863;
      const maxJ = Math.min(k, num.length - 1);
      for (let j = Math.max(0, k - self2.length + 1); j <= maxJ; j++) {
        const i = k - j;
        const a = self2.words[i] | 0;
        const b = num.words[j] | 0;
        const r2 = a * b;
        let lo = r2 & 67108863;
        ncarry = ncarry + (r2 / 67108864 | 0) | 0;
        lo = lo + rword | 0;
        rword = lo & 67108863;
        ncarry = ncarry + (lo >>> 26) | 0;
        hncarry += ncarry >>> 26;
        ncarry &= 67108863;
      }
      out.words[k] = rword;
      carry = ncarry;
      ncarry = hncarry;
    }
    if (carry !== 0) {
      out.words[k] = carry;
    } else {
      out.length--;
    }
    return out.strip();
  }
  /**
   * Performs multiplication between the BigNumber instance and a given BigNumber.
   * It chooses the multiplication method based on the lengths of the numbers to optimize execution time.
   *
   * @method mulTo
   * @param num - The BigNumber multiply with.
   * @param out - The BigNumber where to store the result.
   * @returns The BigNumber resulting from the multiplication operation.
   *
   * @example
   * const bn1 = new BigNumber('12345');
   * const bn2 = new BigNumber('23456');
   * const output = new BigNumber();
   * bn1.mulTo(bn2, output);
   */
  mulTo(num, out) {
    let res;
    const len = this.length + num.length;
    if (this.length === 10 && num.length === 10) {
      res = this.comb10MulTo(this, num, out);
    } else if (len < 63) {
      res = this.smallMulTo(this, num, out);
    } else {
      res = this.bigMulTo(this, num, out);
    }
    return res;
  }
  /**
   * Performs multiplication between the BigNumber instance and a given BigNumber.
   * It creates a new BigNumber to store the result.
   *
   * @method mul
   * @param num - The BigNumber to multiply with.
   * @returns The BigNumber resulting from the multiplication operation.
   *
   * @example
   * const bn1 = new BigNumber('12345');
   * const bn2 = new BigNumber('23456');
   * const result = bn1.mul(bn2);
   */
  mul(num) {
    const out = new _BigNumber();
    out.words = new Array(this.length + num.length);
    return this.mulTo(num, out);
  }
  /**
   * Performs an in-place multiplication of the BigNumber instance by a given BigNumber.
   *
   * @method imul
   * @param num - The BigNumber to multiply with.
   * @returns The BigNumber itself after the multiplication.
   *
   * @example
   * const bn1 = new BigNumber('12345');
   * const bn2 = new BigNumber('23456');
   * bn1.imul(bn2);
   */
  imul(num) {
    return this.clone().mulTo(num, this);
  }
  /**
   * Performs an in-place multiplication of the BigNumber instance by a number.
   * This method asserts the input to be a number less than 0x4000000 to prevent overflowing.
   * If negavtive number is provided, the resulting BigNumber will be inversely negative.
   *
   * @method imuln
   * @param num - The number to multiply with.
   * @returns The BigNumber itself after the multiplication.
   *
   * @example
   * const bn = new BigNumber('12345');
   * bn.imuln(23456);
   */
  imuln(num) {
    const isNegNum = num < 0;
    if (isNegNum)
      num = -num;
    this.assert(typeof num === "number");
    this.assert(num < 67108864);
    let carry = 0;
    let i = 0;
    for (; i < this.length; i++) {
      const w = (this.words[i] | 0) * num;
      const lo = (w & 67108863) + (carry & 67108863);
      carry >>= 26;
      carry += w / 67108864 | 0;
      carry += lo >>> 26;
      this.words[i] = lo & 67108863;
    }
    if (carry !== 0) {
      this.words[i] = carry;
      this.length++;
    }
    return isNegNum ? this.ineg() : this;
  }
  /**
   * Performs multiplication between the BigNumber instance and a number.
   * It performs the multiplication operation in-place to a cloned BigNumber.
   *
   * @method muln
   * @param num - The number to multiply with.
   * @returns The resulting BigNumber from the multiplication operation.
   *
   * @example
   * const bn = new BigNumber('12345');
   * const result = bn.muln(23456);
   */
  muln(num) {
    return this.clone().imuln(num);
  }
  /**
   * Squares the BigNumber instance.
   *
   * @method sqr
   * @returns The BigNumber squared.
   *
   * @example
   * const bn = new BigNumber('12345');
   * const result = bn.sqr();
   */
  sqr() {
    return this.mul(this);
  }
  /**
   * Performs in-place multiplication of the BigNumber instance by itself.
   *
   * @method isqr
   * @returns The result of multiplying the BigNumber instance by itself.
   *
   * @example
   * let myNumber = new BigNumber(4);
   * myNumber.isqr(); // Returns BigNumber of value 16
   */
  isqr() {
    return this.imul(this.clone());
  }
  /**
   * Raises the BigNumber instance to the power of the specified BigNumber.
   *
   * @method pow
   * @param num - The exponent to raise the BigNumber instance to.
   * @returns The result of raising the BigNumber instance to the power of num.
   *
   * @example
   * let base = new BigNumber(2);
   * let exponent = new BigNumber(3);
   * base.pow(exponent); // Returns BigNumber of value 8
   */
  pow(num) {
    const w = _BigNumber.toBitArray(num);
    if (w.length === 0)
      return new _BigNumber(1);
    let res = this;
    let i = 0;
    for (; i < w.length; i++, res = res.sqr()) {
      if (w[i] !== 0)
        break;
    }
    if (++i < w.length) {
      for (let q = res.sqr(); i < w.length; i++, q = q.sqr()) {
        if (w[i] === 0)
          continue;
        res = res.mul(q);
      }
    }
    return res;
  }
  /**
   * Performs in-place bitwise left shift operation on the BigNumber instance.
   *
   * @method iushln
   * @param bits - The number of positions to shift.
   * @returns The BigNumber instance after performing the shift operation.
   *
   * @example
   * let myNumber = new BigNumber(4);
   * myNumber.iushln(2); // Returns BigNumber of value 16
   */
  iushln(bits) {
    this.assert(typeof bits === "number" && bits >= 0);
    const r2 = bits % 26;
    const s2 = (bits - r2) / 26;
    const carryMask = 67108863 >>> 26 - r2 << 26 - r2;
    let i;
    if (r2 !== 0) {
      let carry = 0;
      for (i = 0; i < this.length; i++) {
        const newCarry = this.words[i] & carryMask;
        const c = (this.words[i] | 0) - newCarry << r2;
        this.words[i] = c | carry;
        carry = newCarry >>> 26 - r2;
      }
      if (carry !== 0) {
        this.words[i] = carry;
        this.length++;
      }
    }
    if (s2 !== 0) {
      for (i = this.length - 1; i >= 0; i--) {
        this.words[i + s2] = this.words[i];
      }
      for (i = 0; i < s2; i++) {
        this.words[i] = 0;
      }
      this.length += s2;
    }
    return this.strip();
  }
  /**
   * Performs an in-place left shift operation on the BigNumber instance only if it is non-negative.
   *
   * @method ishln
   * @param bits - The number of positions to shift.
   * @returns The BigNumber instance after performing the shift operation.
   *
   * @example
   * let myNumber = new BigNumber(4);
   * myNumber.ishln(2); // Returns BigNumber of value 16
   */
  ishln(bits) {
    this.assert(this.negative === 0);
    return this.iushln(bits);
  }
  /**
   * Performs an in-place unsigned bitwise right shift operation on the BigNumber instance.
   *
   * @method iushrn
   * @param bits - The number of positions to shift.
   * @param hint - Lowest bit before trailing zeroes.
   * @param extended - To be filled with the bits that are shifted out.
   * @returns The BigNumber instance after performing the shift operation.
   *
   * @example
   * let myNumber = new BigNumber(16);
   * myNumber.iushrn(2); // Returns BigNumber of value 4
   */
  iushrn(bits, hint, extended) {
    this.assert(typeof bits === "number" && bits >= 0);
    let h;
    if (typeof hint === "number" && hint !== 0) {
      h = (hint - hint % 26) / 26;
    } else {
      h = 0;
    }
    const r2 = bits % 26;
    const s2 = Math.min((bits - r2) / 26, this.length);
    const mask = 67108863 ^ 67108863 >>> r2 << r2;
    const maskedWords = extended;
    h -= s2;
    h = Math.max(0, h);
    let i = 0;
    if (typeof maskedWords !== "undefined") {
      for (; i < s2; i++) {
        maskedWords.words[i] = this.words[i];
      }
      maskedWords.length = s2;
    }
    if (s2 === 0) {
    } else if (this.length > s2) {
      this.length -= s2;
      for (i = 0; i < this.length; i++) {
        this.words[i] = this.words[i + s2];
      }
    } else {
      this.words[0] = 0;
      this.length = 1;
    }
    let carry = 0;
    for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {
      const word = this.words[i] | 0;
      this.words[i] = carry << 26 - r2 | word >>> r2;
      carry = word & mask;
    }
    if (maskedWords != null && carry !== 0) {
      maskedWords.words[maskedWords.length++] = carry;
    }
    if (this.length === 0) {
      this.words[0] = 0;
      this.length = 1;
    }
    return this.strip();
  }
  /**
   * Performs an in-place right shift operation on the BigNumber instance only if it is non-negative.
   *
   * @method ishrn
   * @param bits - The number of positions to shift.
   * @param hint - Lowest bit before trailing zeroes.
   * @param extended - To be filled with the bits that are shifted out.
   * @returns The BigNumber instance after performing the shift operation.
   *
   * @example
   * let myNumber = new BigNumber(16);
   * myNumber.ishrn(2); // Returns BigNumber of value 4
   */
  ishrn(bits, hint, extended) {
    this.assert(this.negative === 0);
    return this.iushrn(bits, hint, extended);
  }
  /**
   * Performs a bitwise left shift operation on a clone of the BigNumber instance.
   *
   * @method shln
   * @param bits - The number of positions to shift.
   * @returns A new BigNumber, which is the result of the shift operation.
   *
   * @example
   * let myNumber = new BigNumber(4);
   * let shiftedNumber = myNumber.shln(2);
   * console.log(shiftedNumber.toString()); // Outputs "16"
   */
  shln(bits) {
    return this.clone().ishln(bits);
  }
  /**
   * Performs an unsigned bitwise shift left operation on a clone of the BigNumber instance.
   *
   * @method ushln
   * @param bits - The number of bits to shift.
   * @returns A new BigNumber resulting from the shift operation.
   *
   * @example
   * let myNumber = new BigNumber(4);
   * let shiftedNumber = myNumber.ushln(2);
   * console.log(shiftedNumber.toString()); // Outputs "16"
   */
  ushln(bits) {
    return this.clone().iushln(bits);
  }
  /**
   * Performs a bitwise right shift operation on a clone of the BigNumber instance.
   *
   * @method shrn
   * @param bits - The number of bits to shift.
   * @returns A new BigNumber resulting from the shift operation.
   *
   * @example
   * let myNumber = new BigNumber(16);
   * let shiftedNumber = myNumber.shrn(3);
   * console.log(shiftedNumber.toString()); // Outputs "2"
   */
  shrn(bits) {
    return this.clone().ishrn(bits);
  }
  /**
   * Performs an unsigned bitwise shift right operation on a clone of the BigNumber instance.
   *
   * @method ushrn
   * @param bits - The number of bits to shift.
   * @returns A new BigNumber resulting from the shift operation.
   *
   * @example
   * let myNumber = new BigNumber(20);
   * let shiftedNumber = myNumber.ushrn(2);
   * console.log(shiftedNumber.toString()); // Outputs "5"
   */
  ushrn(bits) {
    return this.clone().iushrn(bits);
  }
  /**
   * Tests if the nth bit of the BigNumber is set.
   *
   * @method testn
   * @param bit - The position of the bit to test.
   * @returns A boolean indicating whether the nth bit is set.
   *
   * @example
   * let myNumber = new BigNumber(10); // 1010 in binary
   * myNumber.testn(1); // Returns true (indicating that the second bit from right is set)
   */
  testn(bit) {
    this.assert(typeof bit === "number" && bit >= 0);
    const r2 = bit % 26;
    const s2 = (bit - r2) / 26;
    const q = 1 << r2;
    if (this.length <= s2)
      return false;
    const w = this.words[s2];
    return Boolean(w & q);
  }
  /**
   * Performs an in-place operation to keep only the lower bits of the number.
   * @method imaskn
   * @param bits - The number of lower bits to keep.
   * @returns Returns the BigNumber with only the specified lower bits.
   * @throws Will throw an error if bits is not a positive number.
   * @throws Will throw an error if initial BigNumber is negative as imaskn only works with positive numbers.
   * @example
   * const myNumber = new BigNumber(52);
   * myNumber.imaskn(2); // myNumber becomes 0 because lower 2 bits of 52 (110100) are 00.
   */
  imaskn(bits) {
    this.assert(typeof bits === "number" && bits >= 0);
    const r2 = bits % 26;
    let s2 = (bits - r2) / 26;
    this.assert(this.negative === 0, "imaskn works only with positive numbers");
    if (this.length <= s2) {
      return this;
    }
    if (r2 !== 0) {
      s2++;
    }
    this.length = Math.min(s2, this.length);
    if (r2 !== 0) {
      const mask = 67108863 ^ 67108863 >>> r2 << r2;
      this.words[this.length - 1] &= mask;
    }
    return this.strip();
  }
  /**
   * Returns a new BigNumber that keeps only the lower bits of the original number.
   * @method maskn
   * @param bits - The number of lower bits to keep.
   * @returns Returns a new BigNumber with only the specified lower bits of the original number.
   * @example
   * const myNumber = new BigNumber(52);
   * const newNumber = myNumber.maskn(2); // newNumber becomes 0, myNumber doesn't change.
   */
  maskn(bits) {
    return this.clone().imaskn(bits);
  }
  /**
   * Performs an in-place addition of a plain number to the BigNumber.
   * @method iaddn
   * @param num - The plain number to add.
   * @returns Returns the BigNumber after the addition.
   * @throws Will throw an error if num is not a number or is larger than 0x4000000.
   * @example
   * const myNumber = new BigNumber(50);
   * myNumber.iaddn(2); // myNumber becomes 52.
   */
  iaddn(num) {
    this.assert(typeof num === "number");
    this.assert(num < 67108864, "num is too large");
    if (num < 0)
      return this.isubn(-num);
    if (this.negative !== 0) {
      if (this.length === 1 && (this.words[0] | 0) <= num) {
        this.words[0] = num - (this.words[0] | 0);
        this.negative = 0;
        return this;
      }
      this.negative = 0;
      this.isubn(num);
      this.negative = 1;
      return this;
    }
    return this._iaddn(num);
  }
  /**
   * A helper method for in-place addition, used when there are no sign changes or size checks needed.
   * @private
   * @method _iaddn
   * @param num - The plain number to add.
   * @returns Returns the BigNumber after the addition.
   */
  _iaddn(num) {
    this.words[0] += num;
    let i = 0;
    for (; i < this.length && this.words[i] >= 67108864; i++) {
      this.words[i] -= 67108864;
      if (i === this.length - 1) {
        this.words[i + 1] = 1;
      } else {
        this.words[i + 1]++;
      }
    }
    this.length = Math.max(this.length, i + 1);
    return this;
  }
  /**
   * Performs an in-place subtraction of a plain number from the BigNumber.
   * @method isubn
   * @param num - The plain number to subtract.
   * @returns Returns the BigNumber after the subtraction.
   * @throws Will throw an error if num is not a number or is larger than 0x4000000.
   * @example
   * const myNumber = new BigNumber(52);
   * myNumber.isubn(2); // myNumber becomes 50.
   */
  isubn(num) {
    this.assert(typeof num === "number");
    this.assert(num < 67108864);
    if (num < 0)
      return this.iaddn(-num);
    if (this.negative !== 0) {
      this.negative = 0;
      this.iaddn(num);
      this.negative = 1;
      return this;
    }
    this.words[0] -= num;
    if (this.length === 1 && this.words[0] < 0) {
      this.words[0] = -this.words[0];
      this.negative = 1;
    } else {
      for (let i = 0; i < this.length && this.words[i] < 0; i++) {
        this.words[i] += 67108864;
        this.words[i + 1] -= 1;
      }
    }
    return this.strip();
  }
  /**
   * Returns a new BigNumber that is the result of adding a plain number to the original BigNumber.
   * @method addn
   * @param num - The plain number to add.
   * @returns Returns a new BigNumber which is the sum of the original BigNumber and the plain number.
   * @example
   * const myNumber = new BigNumber(50);
   * const newNumber = myNumber.addn(2); // newNumber becomes 52, myNumber doesn't change.
   */
  addn(num) {
    return this.clone().iaddn(num);
  }
  /**
   * Returns a new BigNumber that is the result of subtracting a plain number from the original BigNumber.
   * @method subn
   * @param num - The plain number to subtract.
   * @returns Returns a new BigNumber which is the difference of the original BigNumber and the plain number.
   * @example
   * const myNumber = new BigNumber(52);
   * const newNumber = myNumber.subn(2);  // newNumber becomes 50, myNumber doesn't change.
   */
  subn(num) {
    return this.clone().isubn(num);
  }
  /**
   * Performs an in-place operation to make the BigNumber an absolute value.
   * @method iabs
   * @returns Returns the BigNumber as an absolute value.
   * @example
   * const myNumber = new BigNumber(-50);
   * myNumber.iabs(); // myNumber becomes 50.
   */
  iabs() {
    this.negative = 0;
    return this;
  }
  /**
   * Obtains the absolute value of a BigNumber instance.
   * This operation does not affect the actual object but instead returns a new instance of BigNumber.
   *
   * @method abs
   * @returns a new BigNumber instance with the absolute value of the current instance.
   *
   * @example
   * let negativeNumber = new BigNumber(-10);
   * let absolute = negativeNumber.abs();
   * console.log(absolute.toString()); // Outputs: "10"
   */
  abs() {
    return this.clone().iabs();
  }
  /**
   * Perform an in-place shift left, subtract, and multiply operation on a BigNumber instance.
   * This method modifies the existing BigNumber instance.
   *
   * @method _ishlnsubmul
   * @param num - The BigNumber to be operated on.
   * @param mul - The multiplication factor.
   * @param shift - The number of places to shift left.
   * @returns the updated BigNumber instance after performing the in-place shift, subtract, and multiply operations.
   *
   * @example
   * let number = new BigNumber(10);
   * number._ishlnsubmul(new BigNumber(2), 3, 1);
   * console.log(number.toString()); // Outputs result after performing operations
   */
  _ishlnsubmul(num, mul, shift) {
    const len = num.length + shift;
    let i;
    this.expand(len);
    let w;
    let carry = 0;
    for (i = 0; i < num.length; i++) {
      w = (this.words[i + shift] | 0) + carry;
      const right = (num.words[i] | 0) * mul;
      w -= right & 67108863;
      carry = (w >> 26) - (right / 67108864 | 0);
      this.words[i + shift] = w & 67108863;
    }
    for (; i < this.length - shift; i++) {
      w = (this.words[i + shift] | 0) + carry;
      carry = w >> 26;
      this.words[i + shift] = w & 67108863;
    }
    if (carry === 0)
      return this.strip();
    this.assert(carry === -1, "carry must be -1");
    carry = 0;
    for (i = 0; i < this.length; i++) {
      w = -(this.words[i] | 0) + carry;
      carry = w >> 26;
      this.words[i] = w & 67108863;
    }
    this.negative = 1;
    return this.strip();
  }
  /**
   * Performs a division on a BigNumber instance word-wise.
   *
   * This is a private method and should not be directly accessed.
   *
   * @method wordDiv
   * @private
   * @param num - The BigNumber to divide by.
   * @param mode - Specifies the operation mode as 'mod' for modulus or 'div' for division.
   * @returns Object with division (div) and modulo (mod) results, subject to the 'mode' specified.
   */
  wordDiv(num, mode) {
    let shift = this.length - num.length;
    let a = this.clone();
    let b = num;
    let bhi = b.words[b.length - 1] | 0;
    const bhiBits = this.countWordBits(bhi);
    shift = 26 - bhiBits;
    if (shift !== 0) {
      b = b.ushln(shift);
      a.iushln(shift);
      bhi = b.words[b.length - 1] | 0;
    }
    const m = a.length - b.length;
    let q;
    if (mode !== "mod") {
      q = new _BigNumber();
      q.length = m + 1;
      q.words = new Array(q.length);
      for (let i = 0; i < q.length; i++) {
        q.words[i] = 0;
      }
    }
    const diff = a.clone()._ishlnsubmul(b, 1, m);
    if (diff.negative === 0) {
      a = diff;
      if (typeof q !== "undefined") {
        q.words[m] = 1;
      }
    }
    for (let j = m - 1; j >= 0; j--) {
      let qj = (a.words[b.length + j] | 0) * 67108864 + (a.words[b.length + j - 1] | 0);
      qj = Math.min(qj / bhi | 0, 67108863);
      a._ishlnsubmul(b, qj, j);
      while (a.negative !== 0) {
        qj--;
        a.negative = 0;
        a._ishlnsubmul(b, 1, j);
        if (!a.isZero()) {
          a.negative ^= 1;
        }
      }
      if (typeof q !== "undefined") {
        q.words[j] = qj;
      }
    }
    if (typeof q !== "undefined") {
      q.strip();
    }
    a.strip();
    if (mode !== "div" && shift !== 0) {
      a.iushrn(shift);
    }
    return {
      div: q ?? null,
      mod: a
    };
  }
  /**
   * Performs division and/or modulus operation on a BigNumber instance depending on the 'mode' parameter.
   * If the mode parameter is not provided, both division and modulus results are returned.
   *
   * @method divmod
   * @param num - The BigNumber to divide by.
   * @param mode - Specifies operation as 'mod' for modulus, 'div' for division, or both if not specified.
   * @param positive - Specifies if unsigned modulus is requested.
   * @returns Object with properties for division (div) and modulo (mod) results.
   *
   * @example
   * let number = new BigNumber(10);
   * let result = number.divmod(new BigNumber(3));
   * console.log(result.div.toString()); // Outputs: "3"
   * console.log(result.mod.toString()); // Outputs: "1"
   */
  divmod(num, mode, positive) {
    this.assert(!num.isZero());
    if (this.isZero()) {
      return {
        div: new _BigNumber(0),
        mod: new _BigNumber(0)
      };
    }
    let div, mod, res;
    if (this.negative !== 0 && num.negative === 0) {
      res = this.neg().divmod(num, mode);
      if (mode !== "mod") {
        div = res.div.neg();
      }
      if (mode !== "div") {
        mod = res.mod.neg();
        if (positive && mod.negative !== 0) {
          mod.iadd(num);
        }
      }
      return {
        div,
        mod
      };
    }
    if (this.negative === 0 && num.negative !== 0) {
      res = this.divmod(num.neg(), mode);
      if (mode !== "mod") {
        div = res.div.neg();
      }
      return {
        div,
        mod: res.mod
      };
    }
    if ((this.negative & num.negative) !== 0) {
      res = this.neg().divmod(num.neg(), mode);
      if (mode !== "div") {
        mod = res.mod.neg();
        if (positive && mod.negative !== 0) {
          mod.isub(num);
        }
      }
      return {
        div: res.div,
        mod
      };
    }
    if (num.length > this.length || this.cmp(num) < 0) {
      return {
        div: new _BigNumber(0),
        mod: this
      };
    }
    if (num.length === 1) {
      if (mode === "div") {
        return {
          div: this.divn(num.words[0]),
          mod: null
        };
      }
      if (mode === "mod") {
        return {
          div: null,
          mod: new _BigNumber(this.modrn(num.words[0]))
        };
      }
      return {
        div: this.divn(num.words[0]),
        mod: new _BigNumber(this.modrn(num.words[0]))
      };
    }
    return this.wordDiv(num, mode);
  }
  /**
   * Divides a BigNumber instance by another BigNumber and returns result. This does not modify the actual object.
   *
   * @method div
   * @param num - The BigNumber to divide by.
   * @returns A new BigNumber instance of the division result.
   *
   * @example
   * let number = new BigNumber(10);
   * let result = number.div(new BigNumber(2));
   * console.log(result.toString()); // Outputs: "5"
   */
  div(num) {
    return this.divmod(num, "div", false).div;
  }
  /**
   * Returns the remainder after division of one `BigNumber` by another `BigNumber`.
   *
   * @method mod
   * @param num - The divisor `BigNumber`.
   * @returns The remainder `BigNumber` after division.
   *
   * @example
   * const bigNum1 = new BigNumber('100');
   * const bigNum2 = new BigNumber('45');
   * const remainder = bigNum1.mod(bigNum2); // remainder here would be '10'
   */
  mod(num) {
    return this.divmod(num, "mod", false).mod;
  }
  /**
   * Returns the remainder after unsigned division of one `BigNumber` by another `BigNumber`.
   *
   * @method umod
   * @param num - The divisor `BigNumber`.
   * @returns The remainder `BigNumber` after unsigned division.
   * Note: Here 'unsigned division' means that signs of the numbers are ignored.
   *
   * @example
   * const bigNum1 = new BigNumber('-100');
   * const bigNum2 = new BigNumber('45');
   * const remainder = bigNum1.umod(bigNum2); // remainder here would be '10' as signs are ignored.
   */
  umod(num) {
    return this.divmod(num, "mod", true).mod;
  }
  /**
   * Returns the rounded quotient after division of one `BigNumber` by another `BigNumber`.
   *
   * @method divRound
   * @param num - The divisor `BigNumber`.
   * @returns The rounded quotient `BigNumber` after division.
   *
   * @example
   * const bigNum1 = new BigNumber('100');
   * const bigNum2 = new BigNumber('45');
   * const quotient = bigNum1.divRound(bigNum2); // quotient here would be '2'
   */
  divRound(num) {
    const dm = this.divmod(num);
    if (dm.mod.isZero())
      return dm.div;
    const mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;
    const half = num.ushrn(1);
    const r2 = num.andln(1);
    const cmp = mod.cmp(half);
    if (cmp < 0 || r2 === 1 && cmp === 0)
      return dm.div;
    return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
  }
  /**
   * Returns the remainder after division of a `BigNumber` by a primitive number.
   *
   * @method modrn
   * @param num - The divisor primitive number.
   * @returns The remainder number after division.
   *
   * @example
   * const bigNum = new BigNumber('100');
   * const num = 45;
   * const remainder = bigNum.modrn(num); // remainder here would be '10'
   */
  modrn(num) {
    const isNegNum = num < 0;
    if (isNegNum)
      num = -num;
    this.assert(num <= 67108863);
    const p = (1 << 26) % num;
    let acc = 0;
    for (let i = this.length - 1; i >= 0; i--) {
      acc = (p * acc + (this.words[i] | 0)) % num;
    }
    return isNegNum ? -acc : acc;
  }
  /**
   * Performs an in-place division of a `BigNumber` by a primitive number.
   *
   * @method idivn
   * @param num - The divisor primitive number.
   * @returns The `BigNumber` itself after being divided.
   * Note: 'in-place' means that this operation modifies the original `BigNumber`.
   *
   * @example
   * const bigNum = new BigNumber('100');
   * const num = 45;
   * bigNum.idivn(num); // the bigNum here directly becomes '2'
   */
  idivn(num) {
    const isNegNum = num < 0;
    if (isNegNum)
      num = -num;
    this.assert(num <= 67108863);
    let carry = 0;
    for (let i = this.length - 1; i >= 0; i--) {
      const w = (this.words[i] | 0) + carry * 67108864;
      this.words[i] = w / num | 0;
      carry = w % num;
    }
    this.strip();
    return isNegNum ? this.ineg() : this;
  }
  /**
   * Returns the quotient `BigNumber` after division of one `BigNumber` by a primitive number.
   *
   * @method divn
   * @param num - The divisor primitive number.
   * @returns A new quotient `BigNumber` after division.
   *
   * @example
   * const bigNum = new BigNumber('100');
   * const num = 45;
   * const quotient = bigNum.divn(num); // quotient here would be '2'
   */
  divn(num) {
    return this.clone().idivn(num);
  }
  /**
   * Computes the Extended Euclidean Algorithm for this BigNumber and provided BigNumber `p`.
   * The Extended Euclidean Algorithm is a method to find the GCD (Greatest Common Divisor) and the multiplicative inverse in a modulus field.
   *
   * @method egcd
   * @param p - The `BigNumber` with which the Extended Euclidean Algorithm will be computed.
   * @returns An object `{a: BigNumber, b: BigNumber, gcd: BigNumber}` where `gcd` is the GCD of the numbers, `a` is the coefficient of `this`, and `b` is the coefficient of `p` in Bzout's identity.
   *
   * @example
   * const bigNum1 = new BigNumber('100');
   * const bigNum2 = new BigNumber('45');
   * const result = bigNum1.egcd(bigNum2);
   */
  egcd(p) {
    this.assert(p.negative === 0, "p must not be negative");
    this.assert(!p.isZero(), "p must not be zero");
    let x = this;
    const y = p.clone();
    if (x.negative !== 0) {
      x = x.umod(p);
    } else {
      x = x.clone();
    }
    const A = new _BigNumber(1);
    const B = new _BigNumber(0);
    const C = new _BigNumber(0);
    const D = new _BigNumber(1);
    let g = 0;
    while (x.isEven() && y.isEven()) {
      x.iushrn(1);
      y.iushrn(1);
      ++g;
    }
    const yp = y.clone();
    const xp = x.clone();
    while (!x.isZero()) {
      let i = 0;
      let im = 1;
      for (; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1)
        ;
      if (i > 0) {
        x.iushrn(i);
        while (i-- > 0) {
          if (A.isOdd() || B.isOdd()) {
            A.iadd(yp);
            B.isub(xp);
          }
          A.iushrn(1);
          B.iushrn(1);
        }
      }
      let j = 0;
      let jm = 1;
      for (; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1)
        ;
      if (j > 0) {
        y.iushrn(j);
        while (j-- > 0) {
          if (C.isOdd() || D.isOdd()) {
            C.iadd(yp);
            D.isub(xp);
          }
          C.iushrn(1);
          D.iushrn(1);
        }
      }
      if (x.cmp(y) >= 0) {
        x.isub(y);
        A.isub(C);
        B.isub(D);
      } else {
        y.isub(x);
        C.isub(A);
        D.isub(B);
      }
    }
    return {
      a: C,
      b: D,
      gcd: y.iushln(g)
    };
  }
  /**
   * Compute the multiplicative inverse of the current BigNumber in the modulus field specified by `p`.
   * The multiplicative inverse is a number which when multiplied with the current BigNumber gives '1' in the modulus field.
   *
   * @method _invmp
   * @param p - The `BigNumber` specifying the modulus field.
   * @returns The multiplicative inverse `BigNumber` in the modulus field specified by `p`.
   *
   * @example
   * const bigNum = new BigNumber('45');
   * const p = new BigNumber('100');
   * const inverse = bigNum._invmp(p); // inverse here would be a BigNumber such that (inverse*bigNum) % p = '1'
   */
  _invmp(p) {
    this.assert(p.negative === 0, "p must not be negative");
    this.assert(!p.isZero(), "p must not be zero");
    let a = this;
    const b = p.clone();
    if (a.negative !== 0) {
      a = a.umod(p);
    } else {
      a = a.clone();
    }
    const x1 = new _BigNumber(1);
    const x2 = new _BigNumber(0);
    const delta = b.clone();
    while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
      let i = 0;
      let im = 1;
      for (; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1)
        ;
      if (i > 0) {
        a.iushrn(i);
        while (i-- > 0) {
          if (x1.isOdd()) {
            x1.iadd(delta);
          }
          x1.iushrn(1);
        }
      }
      let j = 0;
      let jm = 1;
      for (; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1)
        ;
      if (j > 0) {
        b.iushrn(j);
        while (j-- > 0) {
          if (x2.isOdd()) {
            x2.iadd(delta);
          }
          x2.iushrn(1);
        }
      }
      if (a.cmp(b) >= 0) {
        a.isub(b);
        x1.isub(x2);
      } else {
        b.isub(a);
        x2.isub(x1);
      }
    }
    let res;
    if (a.cmpn(1) === 0) {
      res = x1;
    } else {
      res = x2;
    }
    if (res.cmpn(0) < 0) {
      res.iadd(p);
    }
    return res;
  }
  /**
   * Computes and returns the greatest common divisor (GCD) of this BigNumber and the provided BigNumber.
   *
   * @method gcd
   * @param num - The BigNumber with which to compute the GCD.
   * @returns The GCD of this BigNumber and the provided BigNumber.
   *
   * @example
   * let a = new BigNumber(48);
   * let b = new BigNumber(18);
   * let gcd = a.gcd(b);
   */
  gcd(num) {
    if (this.isZero())
      return num.abs();
    if (num.isZero())
      return this.abs();
    let a = this.clone();
    let b = num.clone();
    a.negative = 0;
    b.negative = 0;
    let shift = 0;
    for (; a.isEven() && b.isEven(); shift++) {
      a.iushrn(1);
      b.iushrn(1);
    }
    do {
      while (a.isEven()) {
        a.iushrn(1);
      }
      while (b.isEven()) {
        b.iushrn(1);
      }
      const r2 = a.cmp(b);
      if (r2 < 0) {
        const t = a;
        a = b;
        b = t;
      } else if (r2 === 0 || b.cmpn(1) === 0) {
        break;
      }
      a.isub(b);
    } while (true);
    return b.iushln(shift);
  }
  /**
   * Computes and returns the modular multiplicative inverse of this BigNumber in the field defined by the provided BigNumber.
   *
   * @method invm
   * @param num - The BigNumber that defines the field.
   * @returns The modular multiplicative inverse of this BigNumber.
   *
   * @example
   * let a = new BigNumber(3);
   * let field = new BigNumber(7);
   * let inverse = a.invm(field);
   */
  invm(num) {
    return this.egcd(num).a.umod(num);
  }
  /**
   * Checks if this BigNumber is even.
   * An even number is an integer which is evenly divisible by two.
   *
   * @method isEven
   * @returns true if this BigNumber is even, else false.
   *
   * @example
   * let a = new BigNumber(4);
   * let isEven = a.isEven(); // true
   */
  isEven() {
    return (this.words[0] & 1) === 0;
  }
  /**
   * Checks if this BigNumber is Odd.
   * An odd number is an integer which is not evenly divisible by two.
   *
   * @method isOdd
   * @returns true if this BigNumber is Odd, else false.
   *
   * @example
   * let a = new BigNumber(3);
   * let isOdd = a.isOdd(); // true
   */
  isOdd() {
    return (this.words[0] & 1) === 1;
  }
  /**
   * Returns the result of bitwise AND operation between the least significant 26 bits of
   * this BigNumber and the provided number.
   * This method is mostly used to mask-off less significant bits.
   *
   * @method andln
   * @param num - The number to AND with.
   * @returns The result of the AND operation.
   *
   * @example
   * let a = new BigNumber(60);
   * let result = a.andln(13); // 12
   */
  andln(num) {
    return this.words[0] & num;
  }
  /**
   * Increments the value at the bit position specified by the input parameter.
   *
   * @method bincn
   * @param bit - The bit position to increment at.
   * @returns This BigNumber after incrementing at the specific bit position.
   *
   * @example
   * let a = new BigNumber(5);
   * a.bincn(2); // a = 7
   */
  bincn(bit) {
    this.assert(typeof bit === "number");
    const r2 = bit % 26;
    const s2 = (bit - r2) / 26;
    const q = 1 << r2;
    if (this.length <= s2) {
      this.expand(s2 + 1);
      this.words[s2] |= q;
      return this;
    }
    let carry = q;
    let i = s2;
    for (; carry !== 0 && i < this.length; i++) {
      let w = this.words[i] | 0;
      w += carry;
      carry = w >>> 26;
      w &= 67108863;
      this.words[i] = w;
    }
    if (carry !== 0) {
      this.words[i] = carry;
      this.length++;
    }
    return this;
  }
  /**
   * Checks if this BigNumber is Zero.
   * A BigNumber is zero if it only contains one word and that word is 0.
   *
   * @method isZero
   * @returns true if this BigNumber is Zero, else false.
   *
   * @example
   * let a = new BigNumber(0);
   * let isZero = a.isZero(); // true
   */
  isZero() {
    return this.length === 1 && this.words[0] === 0;
  }
  /**
   * Compares this BigNumber with the given number.
   * It returns -1 if this BigNumber is less than the number, 0 if they're equal, and 1 if the BigNumber is greater than the number.
   *
   * @method cmpn
   * @param num - The number to compare with.
   * @returns -1, 0, or 1 based on the comparison result.
   *
   * @example
   * let a = new BigNumber(15);
   * let result = a.cmpn(10); // 1
   */
  cmpn(num) {
    const negative = num < 0;
    if (this.negative !== 0 && !negative)
      return -1;
    if (this.negative === 0 && negative)
      return 1;
    this.strip();
    let res;
    if (this.length > 1) {
      res = 1;
    } else {
      if (negative) {
        num = -num;
      }
      this.assert(num <= 67108863, "Number is too big");
      const w = this.words[0] | 0;
      res = w === num ? 0 : w < num ? -1 : 1;
    }
    if (this.negative !== 0)
      return -res | 0;
    return res;
  }
  /**
   * Compare this big number with another big number.
   * @method cmp
   * @param num - The big number to compare with.
   * @returns Returns:
   * 1 if this big number is greater,
   * -1 if it's less,
   * 0 if they are equal.
   *
   * @example
   * import BigNumber from './BigNumber';
   * const bn1 = new BigNumber('10');
   * const bn2 = new BigNumber('6');
   * const comparisonResult = bn1.cmp(bn2); // 1 - because 10 is greater than 6
   */
  cmp(num) {
    if (this.negative !== 0 && num.negative === 0)
      return -1;
    if (this.negative === 0 && num.negative !== 0)
      return 1;
    const res = this.ucmp(num);
    if (this.negative !== 0)
      return -res | 0;
    return res;
  }
  /**
   * Performs an unsigned comparison between this BigNumber instance and another.
   *
   * @method ucmp
   * @param num - The BigNumber instance to compare with.
   * @returns Returns 1 if this BigNumber is bigger, -1 if it is smaller, and 0 if they are equal.
   *
   * @example
   * let bigNumber1 = new BigNumber('1234');
   * let bigNumber2 = new BigNumber('2345');
   * let comparisonResult = bigNumber1.ucmp(bigNumber2); // Returns -1
   */
  ucmp(num) {
    if (this.length > num.length)
      return 1;
    if (this.length < num.length)
      return -1;
    let res = 0;
    for (let i = this.length - 1; i >= 0; i--) {
      const a = this.words[i] | 0;
      const b = num.words[i] | 0;
      if (a === b)
        continue;
      if (a < b) {
        res = -1;
      } else if (a > b) {
        res = 1;
      }
      break;
    }
    return res;
  }
  /**
   * Checks if this BigNumber instance is greater than a number.
   *
   * @method gtn
   * @param num - The number to compare with.
   * @returns Returns true if this BigNumber is greater than the number, false otherwise.
   *
   * @example
   * let bigNumber = new BigNumber('2345');
   * let isGreater = bigNumber.gtn(1234); // Returns true
   */
  gtn(num) {
    return this.cmpn(num) === 1;
  }
  /**
   * Checks if this BigNumber instance is greater than another BigNumber.
   *
   * @method gt
   * @param num - The BigNumber to compare with.
   * @returns Returns true if this BigNumber is greater than the other BigNumber, false otherwise.
   *
   * @example
   * let bigNumber1 = new BigNumber('2345');
   * let bigNumber2 = new BigNumber('1234');
   * let isGreater = bigNumber1.gt(bigNumber2); // Returns true
   */
  gt(num) {
    return this.cmp(num) === 1;
  }
  /**
   * Checks if this BigNumber instance is greater than or equal to a number.
   *
   * @method gten
   * @param num - The number to compare with.
   * @returns Returns true if this BigNumber is greater than or equal to the number, false otherwise.
   *
   * @example
   * let bigNumber = new BigNumber('1234');
   * let isGreaterOrEqual = bigNumber.gten(1234); // Returns true
   */
  gten(num) {
    return this.cmpn(num) >= 0;
  }
  /**
   * Checks if this BigNumber instance is greater than or equal to another BigNumber.
   *
   * @method gte
   * @param num - The BigNumber to compare with.
   * @returns Returns true if this BigNumber is greater than or equal to the other BigNumber, false otherwise.
   *
   * @example
   * let bigNumber1 = new BigNumber('1234');
   * let bigNumber2 = new BigNumber('1234');
   * let isGreaterOrEqual = bigNumber1.gte(bigNumber2); // Returns true
   */
  gte(num) {
    return this.cmp(num) >= 0;
  }
  /**
   * Checks if this BigNumber instance is less than a number.
   *
   * @method ltn
   * @param num - The number to compare with.
   * @returns Returns true if this BigNumber is less than the number, false otherwise.
   *
   * @example
   * let bigNumber = new BigNumber('1234');
   * let isLess = bigNumber.ltn(2345); // Returns true
   */
  ltn(num) {
    return this.cmpn(num) === -1;
  }
  /**
   * Checks if this BigNumber instance is less than another BigNumber.
   *
   * @method lt
   * @param num - The BigNumber to compare with.
   * @returns Returns true if this BigNumber is less than the other BigNumber, false otherwise.
   *
   * @example
   * let bigNumber1 = new BigNumber('1234');
   * let bigNumber2 = new BigNumber('2345');
   * let isLess = bigNumber1.lt(bigNumber2); // Returns true
   */
  lt(num) {
    return this.cmp(num) === -1;
  }
  /**
   * Checks if this BigNumber instance is less than or equal to a number.
   *
   * @method lten
   * @param num - The number to compare with.
   * @returns Returns true if this BigNumber is less than or equal to the number, false otherwise.
   *
   * @example
   * let bigNumber = new BigNumber('2345');
   * let isLessOrEqual = bigNumber.lten(2345); // Returns true
   */
  lten(num) {
    return this.cmpn(num) <= 0;
  }
  /**
   * Checks if this BigNumber instance is less than or equal to another BigNumber.
   *
   * @method lte
   * @param num - The BigNumber to compare with.
   * @returns Returns true if this BigNumber is less than or equal to the other BigNumber, false otherwise.
   *
   * @example
   * let bigNumber1 = new BigNumber('2345');
   * let bigNumber2 = new BigNumber('2345');
   * let isLessOrEqual = bigNumber1.lte(bigNumber2); // Returns true
   */
  lte(num) {
    return this.cmp(num) <= 0;
  }
  /**
   * Checks if this BigNumber instance is equal to a number.
   *
   * @method eqn
   * @param num - The number to compare with.
   * @returns Returns true if this BigNumber is equal to the number, false otherwise.
   *
   * @example
   * let bigNumber = new BigNumber('1234');
   * let isEqual = bigNumber.eqn(1234); // Returns true
   */
  eqn(num) {
    return this.cmpn(num) === 0;
  }
  /**
   * Compares the current BigNumber with the given number and returns whether they're equal.
   *
   * @method eq
   * @param num - The number to compare equality with.
   * @returns Returns true if the current BigNumber is equal to the provided number, otherwise false.
   *
   * @example
   * let bigNum = new BigNumber(10);
   * bigNum.eq(new BigNumber(10)); // true
   */
  eq(num) {
    return this.cmp(num) === 0;
  }
  /**
   * Converts a BigNumber to a reduction context ensuring the number is a positive integer and is not already in a reduction context.
   * Throws an error in case the number is either negative or already in a reduction context.
   *
   * @method toRed
   * @param ctx - The ReductionContext to convert the BigNumber to.
   * @returns Returns the BigNumber in the given ReductionContext.
   *
   * @example
   * let bigNum = new BigNumber(10);
   * let redCtx = new ReductionContext();
   * bigNum.toRed(redCtx);
   */
  toRed(ctx) {
    this.assert(this.red == null, "Already a number in reduction context");
    this.assert(this.negative === 0, "red works only with positives");
    return ctx.convertTo(this).forceRed(ctx);
  }
  /**
   * Converts a BigNumber from a reduction context, making sure the number is indeed in a reduction context.
   * Throws an error in case the number is not in a reduction context.
   *
   * @method fromRed
   * @returns Returns the BigNumber out of the ReductionContext.
   *
   * @example
   * let bigNum = new BigNumber(10);
   * let redCtx = new ReductionContext();
   * bigNum.toRed(redCtx);
   * bigNum.fromRed();
   */
  fromRed() {
    this.assert(this.red, "fromRed works only with numbers in reduction context");
    return this.red.convertFrom(this);
  }
  /**
   * Forces the current BigNumber into a reduction context, irrespective of the BigNumber's current state.
   *
   * @method forceRed
   * @param ctx - The ReductionContext to forcefully convert the BigNumber to.
   * @returns Returns the BigNumber in the given ReductionContext.
   *
   * @example
   * let bigNum = new BigNumber(10);
   * let redCtx = new ReductionContext();
   * bigNum.forceRed(redCtx);
   */
  forceRed(ctx) {
    this.red = ctx;
    return this;
  }
  /**
   * Performs addition operation of the current BigNumber with the given number in a reduction context.
   * Throws an error in case the number is not in a reduction context.
   *
   * @method redAdd
   * @param num - The number to add to the current BigNumber.
   * @returns Returns a new BigNumber that's the sum of the current BigNumber and the provided number in the reduction context.
   *
   * @example
   * let bigNum = new BigNumber(10);
   * let redCtx = new ReductionContext();
   * bigNum.toRed(redCtx);
   * bigNum.redAdd(new BigNumber(20)); // returns a BigNumber of 30 in reduction context
   */
  redAdd(num) {
    this.assert(this.red, "redAdd works only with red numbers");
    return this.red.add(this, num);
  }
  /**
   * Performs in-place addition operation of the current BigNumber with the given number in a reduction context.
   * Throws an error in case the number is not in a reduction context.
   *
   * @method redIAdd
   * @param num - The number to add to the current BigNumber.
   * @returns Returns the modified current BigNumber after adding the provided number in the reduction context.
   *
   * @example
   * let bigNum = new BigNumber(10);
   * let redCtx = new ReductionContext();
   * bigNum.toRed(redCtx);
   * bigNum.redIAdd(new BigNumber(20)); // modifies the bigNum to 30 in reduction context
   */
  redIAdd(num) {
    this.assert(this.red, "redIAdd works only with red numbers");
    return this.red.iadd(this, num);
  }
  /**
   * Performs subtraction operation of the current BigNumber with the given number in a reduction context.
   * Throws an error in case the number is not in a reduction context.
   *
   * @method redSub
   * @param num - The number to subtract from the current BigNumber.
   * @returns Returns a new BigNumber that's the subtraction result of the current BigNumber and the provided number in the reduction context.
   *
   * @example
   * let bigNum = new BigNumber(30);
   * let redCtx = new ReductionContext();
   * bigNum.toRed(redCtx);
   * bigNum.redSub(new BigNumber(20)); // returns a BigNumber of 10 in reduction context
   */
  redSub(num) {
    this.assert(this.red, "redSub works only with red numbers");
    return this.red.sub(this, num);
  }
  /**
   * Performs in-place subtraction operation of the current BigNumber with the given number in a reduction context.
   * Throws an error in case the number is not in a reduction context.
   *
   * @method redISub
   * @param num - The number to subtract from the current BigNumber.
   * @returns Returns the modified current BigNumber after subtracting the provided number in the reduction context.
   *
   * @example
   * let bigNum = new BigNumber(30);
   * let redCtx = new ReductionContext();
   * bigNum.toRed(redCtx);
   * bigNum.redISub(new BigNumber(20)); // modifies the bigNum to 10 in reduction context
   */
  redISub(num) {
    this.assert(this.red, "redISub works only with red numbers");
    return this.red.isub(this, num);
  }
  /**
   * Performs the shift left operation on the current BigNumber in the reduction context.
   * Throws an error in case the number is not in a reduction context.
   *
   * @method redShl
   * @param num - The positions to shift left the current BigNumber.
   * @returns Returns a new BigNumber after performing the shift left operation on the current BigNumber in the reduction context.
   *
   * @example
   * let bigNum = new BigNumber(1);
   * let redCtx = new ReductionContext();
   * bigNum.toRed(redCtx);
   * bigNum.redShl(2); // returns a BigNumber of 4 in reduction context
   */
  redShl(num) {
    this.assert(this.red, "redShl works only with red numbers");
    return this.red.shl(this, num);
  }
  /**
   * Performs multiplication operation of the current BigNumber with the given number in a reduction context.
   * Throws an error in case the number is not in a reduction context.
   *
   * @method redMul
   * @param num - The number to multiply with the current BigNumber.
   * @returns Returns a new BigNumber that's the product of the current BigNumber and the provided number in the reduction context.
   *
   * @example
   * let bigNum = new BigNumber(10);
   * let redCtx = new ReductionContext();
   * bigNum.toRed(redCtx);
   * bigNum.redMul(new BigNumber(20)); // returns a BigNumber of 200 in reduction context
   */
  redMul(num) {
    this.assert(this.red, "redMul works only with red numbers");
    this.red.verify2(this, num);
    return this.red.mul(this, num);
  }
  /**
   * Performs an in-place multiplication of this BigNumber instance with another BigNumber within a reduction context.
   * Expects that this BigNumber is within the reduction context i.e., it has been reduced.
   *
   * @method redIMul
   * @param num - The BigNumber to multiply with the current BigNumber.
   * @returns A BigNumber that is the result of the in-place multiplication operation, within the reduction context.
   *
   * @example
   * let bigNum1 = new BigNumber('10').toRed(someRed);
   * let bigNum2 = new BigNumber('5');
   * bigNum1.redIMul(bigNum2);
   */
  redIMul(num) {
    this.assert(this.red, "redMul works only with red numbers");
    this.red.verify2(this, num);
    return this.red.imul(this, num);
  }
  /**
   * Square of a "red" (reduced) BigNumber.
   * This function squares the calling BigNumber and returns the result.
   * It only works if the number is "reduced". A number is considered reduced
   * if it has a `red` field that points to a reduction context object.
   *
   * @method redSqr
   * @throws If the BigNumber is not reduced
   * @returns The square of the BigNumber
   *
   * @example
   * const num = new BigNumber('25').toRed(someRed);
   * const result = num.redSqr();
   * console.log(result.toString()); // Outputs: '625' mod the red value
   */
  redSqr() {
    this.assert(this.red, "redSqr works only with red numbers");
    this.red.verify1(this);
    return this.red.sqr(this);
  }
  /**
   * In-place square of a "red" (reduced) BigNumber.
   * This function squares the calling BigNumber and overwrites it with the result.
   * It only works if the number is "reduced". A number is considered reduced
   * if it has a `red` field that points to a reduction context object.
   *
   * @method redISqr
   * @throws If the BigNumber is not reduced
   * @returns This BigNumber squared in place
   *
   * @example
   * const num = new BigNumber('25').toRed(someRed);
   * num.redISqr();
   * console.log(num.toString()); // Outputs: '625' mod the red value
   */
  redISqr() {
    this.assert(this.red, "redISqr works only with red numbers");
    this.red.verify1(this);
    return this.red.isqr(this);
  }
  /**
   * Square root of a "red" (reduced) BigNumber.
   * This function calculates the square root of the calling BigNumber
   * and returns the result. It only works if the number is "reduced".
   * A number is considered reduced if it has a `red`
   * field that points to a reduction context object.
   *
   * @method redSqrt
   * @throws If the BigNumber is not reduced
   * @returns The square root of the BigNumber
   *
   * @example
   * const num = new BigNumber('4').toRed(someRed);
   * const result = num.redSqrt();
   * console.log(result.toString()); // Outputs: '2' mod the red value
   */
  redSqrt() {
    this.assert(this.red, "redSqrt works only with red numbers");
    this.red.verify1(this);
    return this.red.sqrt(this);
  }
  /**
   * Find multiplicative inverse (reciprocal) in respect to reduction context.
   * The method works only on numbers that have a reduction context set.
   *
   * @method redInvm
   * @returns Returns a BigNumber that is multiplicative inverse in respect to the reduction context.
   * @throws Will throw an error if this number does not have a reduction context.
   *
   * @example
   * let a = new BigNumber('2345', 16);
   * a.red = someReductionContext;
   * let aInverse = a.redInvm();
   */
  redInvm() {
    this.assert(this.red, "redInvm works only with red numbers");
    this.red.verify1(this);
    return this.red.invm(this);
  }
  /**
   * Find negative version of this number in respect to reduction context.
   * The method works only on numbers that have a reduction context set.
   *
   * @method redNeg
   * @returns Returns a BigNumber that is the negative version of this number in respect to the reduction context.
   * @throws Will throw an error if this number does not have a reduction context.
   *
   * @example
   * let a = new BigNumber('2345', 16);
   * a.red = someReductionContext;
   * let aNeg = a.redNeg();
   */
  redNeg() {
    this.assert(this.red, "redNeg works only with red numbers");
    this.red.verify1(this);
    return this.red.neg(this);
  }
  /**
   * Raises this number to the power of 'num', in respect to reduction context.
   * Note that 'num' must not have a reduction context set.
   *
   * @method redPow
   * @param num - The exponent to raise this number to.
   * @returns Returns a BigNumber that is this number raised to the power of 'num', in respect to the reduction context.
   * @throws Will throw an error if this number does not have a reduction context or 'num' has a reduction context.
   *
   * @example
   * let a = new BigNumber(3);
   * a.red = someReductionContext;
   * let b = new BigNumber(3);
   * let result = a.redPow(b);  // equivalent to (a^b) mod red
   */
  redPow(num) {
    this.assert(this.red != null && num.red == null, "redPow(normalNum)");
    this.red.verify1(this);
    return this.red.pow(this, num);
  }
  /**
   * Creates a BigNumber from a hexadecimal string.
   *
   * @static
   * @method fromHex
   * @param hex - The hexadecimal string to create a BigNumber from.
   * @returns Returns a BigNumber created from the hexadecimal input string.
   *
   * @example
   * const exampleHex = 'a1b2c3';
   * const bigNumber = BigNumber.fromHex(exampleHex);
   */
  static fromHex(hex, endian) {
    if (endian === "big") {
      return new _BigNumber(hex, 16);
    } else {
      return new _BigNumber(hex, 16, "le");
    }
  }
  /**
   * Converts this BigNumber to a hexadecimal string.
   *
   * @method toHex
   * @param length - The minimum length of the hex string
   * @returns Returns a string representing the hexadecimal value of this BigNumber.
   *
   * @example
   * const bigNumber = new BigNumber(255);
   * const hex = bigNumber.toHex();
   */
  toHex(length = 0) {
    return this.toString("hex", length * 2);
  }
  /**
   * Creates a BigNumber from a JSON-serialized string.
   *
   * @static
   * @method fromJSON
   * @param str - The JSON-serialized string to create a BigNumber from.
   * @returns Returns a BigNumber created from the JSON input string.
   *
   * @example
   * const serialized = '{"type":"BigNumber","hex":"a1b2c3"}';
   * const bigNumber = BigNumber.fromJSON(serialized);
   */
  static fromJSON(str) {
    return new _BigNumber(str);
  }
  /**
   * Creates a BigNumber from a number.
   *
   * @static
   * @method fromNumber
   * @param n - The number to create a BigNumber from.
   * @returns Returns a BigNumber equivalent to the input number.
   *
   * @example
   * const number = 1234;
   * const bigNumber = BigNumber.fromNumber(number);
   */
  static fromNumber(n) {
    return new _BigNumber(n);
  }
  /**
   * Creates a BigNumber from a string, considering an optional base.
   *
   * @static
   * @method fromString
   * @param str - The string to create a BigNumber from.
   * @param base - The base used for conversion. If not provided, base 10 is assumed.
   * @returns Returns a BigNumber equivalent to the string after conversion from the specified base.
   *
   * @example
   * const str = '1234';
   * const bigNumber = BigNumber.fromString(str, 16);
   */
  static fromString(str, base) {
    return new _BigNumber(str, base);
  }
  /**
   * Creates a BigNumber from a signed magnitude number.
   *
   * @static
   * @method fromSm
   * @param num - The signed magnitude number to convert to a BigNumber.
   * @param endian - Defines endianess. If not provided, big endian is assumed.
   * @returns Returns a BigNumber equivalent to the signed magnitude number interpreted with specified endianess.
   *
   * @example
   * const num = [0x81]
   * const bigNumber = BigNumber.fromSm(num, { endian: 'little' }); // equivalent to BigNumber from '-1'
   */
  static fromSm(num, endian = "big") {
    let n = num;
    if (num.length === 0) {
      return new _BigNumber(0);
    }
    if (endian === "little") {
      n = [...n];
      n = n.reverse();
    }
    if ((n[0] & 128) !== 0) {
      n = [...n];
      n[0] = n[0] & 127;
      return new _BigNumber(n).neg();
    } else {
      return new _BigNumber(n);
    }
  }
  /**
   * Converts this BigNumber to a signed magnitude number.
   *
   * @method toSm
   * @param endian - Defines endianess. If not provided, big endian is assumed.
   * @returns Returns an array equivalent to this BigNumber interpreted as a signed magnitude with specified endianess.
   *
   * @example
   * const bigNumber = new BigNumber(-1);
   * const num = bigNumber.toSm('little'); // [0x81]
   */
  toSm(endian = "big") {
    let num;
    if (this.cmpn(0) === -1) {
      num = this.neg().toArray();
      if ((num[0] & 128) !== 0) {
        num = [128, ...num];
      } else {
        num[0] = num[0] | 128;
      }
    } else {
      num = this.toArray();
      if ((num[0] & 128) !== 0) {
        num = [0, ...num];
      }
    }
    if (num.length === 1 && num[0] === 0) {
      num = [];
    }
    if (endian === "little") {
      num = num.reverse();
    }
    return num;
  }
  /**
   * Creates a BigNumber from a number representing the "bits" value in a block header.
   *
   * @static
   * @method fromBits
   * @param bits - The number representing the bits value in a block header.
   * @param strict - If true, an error is thrown if the number has negative bit set.
   * @returns Returns a BigNumber equivalent to the "bits" value in a block header.
   * @throws Will throw an error if `strict` is `true` and the number has negative bit set.
   *
   * @example
   * const bits = 0x1d00ffff;
   * const bigNumber = BigNumber.fromBits(bits);
   */
  static fromBits(bits, strict = false) {
    bits = bits & 2147483648 ? bits - 4294967296 : bits;
    if (strict && (bits & 8388608) !== 0) {
      throw new Error("negative bit set");
    }
    const nsize = bits >> 24;
    const nword = bits & 8388607;
    let bytes = [
      nword >> 24 & 255,
      nword >> 16 & 255,
      nword >> 8 & 255,
      nword & 255
    ];
    if (nsize <= 3) {
      bytes = bytes.slice(1, 1 + nsize);
    } else {
      for (let i = 0; i < nsize - 3; i++) {
        bytes.push(0);
      }
    }
    if ((bits & 8388608) !== 0) {
      return new _BigNumber(bytes).neg();
    } else {
      return new _BigNumber(bytes);
    }
  }
  /**
   * Converts this BigNumber to a number representing the "bits" value in a block header.
   *
   * @method toBits
   * @returns Returns a number equivalent to the "bits" value in a block header.
   *
   * @example
   * const bigNumber = new BigNumber(1);
   * const bits = bigNumber.toBits();
   */
  toBits() {
    let byteArray;
    if (this.ltn(0)) {
      byteArray = this.neg().toArray("be");
    } else {
      byteArray = this.toArray("be");
    }
    while (byteArray.length < 4) {
      byteArray.unshift(0);
    }
    if (byteArray.every((byte) => byte === 0)) {
      return 0;
    }
    while (byteArray[0] === 0) {
      byteArray.shift();
    }
    let nsize = byteArray.length;
    let nword = byteArray.slice(0, 3).reduce((acc, val) => acc * 256 + val, 0);
    if ((nword & 8388608) !== 0) {
      byteArray.unshift(0);
      nsize += 1;
      nword >>>= 8;
    }
    let bits = nsize << 24 | nword;
    if (this.ltn(0)) {
      bits |= 8388608;
    }
    return bits >>> 0;
  }
  /**
   * Creates a BigNumber from the format used in Bitcoin scripts.
   *
   * @static
   * @method fromScriptNum
   * @param num - The number in the format used in Bitcoin scripts.
   * @param requireMinimal - If true, non-minimally encoded values will throw an error.
   * @param maxNumSize - The maximum allowed size for the number. If not provided, defaults to 4.
   * @returns Returns a BigNumber equivalent to the number used in a Bitcoin script.
   * @throws Will throw an error if `requireMinimal` is `true` and the value is non-minimally encoded. Will throw an error if number length is greater than `maxNumSize`.
   *
   * @example
   * const num = [0x02, 0x01]
   * const bigNumber = BigNumber.fromScriptNum(num, true, 5)
   */
  static fromScriptNum(num, requireMinimal, maxNumSize) {
    if (maxNumSize === void 0) {
      maxNumSize = Number.MAX_SAFE_INTEGER;
    }
    if (num.length > maxNumSize) {
      throw new Error("script number overflow");
    }
    if (requireMinimal && num.length > 0) {
      if ((num[num.length - 1] & 127) === 0) {
        if (num.length <= 1 || (num[num.length - 2] & 128) === 0) {
          throw new Error("non-minimally encoded script number");
        }
      }
    }
    return _BigNumber.fromSm(num, "little");
  }
  /**
   * Converts this BigNumber to a number in the format used in Bitcoin scripts.
   *
   * @method toScriptNum
   * @returns Returns the equivalent to this BigNumber as a Bitcoin script number.
   *
   * @example
   * const bigNumber = new BigNumber(258)
   * const num = bigNumber.toScriptNum() // equivalent to bigNumber.toSm('little')
   */
  toScriptNum() {
    return this.toSm("little");
  }
};
/**
 * @privateinitializer
 */
__publicField(_BigNumber, "zeros", [
  "",
  "0",
  "00",
  "000",
  "0000",
  "00000",
  "000000",
  "0000000",
  "00000000",
  "000000000",
  "0000000000",
  "00000000000",
  "000000000000",
  "0000000000000",
  "00000000000000",
  "000000000000000",
  "0000000000000000",
  "00000000000000000",
  "000000000000000000",
  "0000000000000000000",
  "00000000000000000000",
  "000000000000000000000",
  "0000000000000000000000",
  "00000000000000000000000",
  "000000000000000000000000",
  "0000000000000000000000000"
]);
/**
 * @privateinitializer
 */
__publicField(_BigNumber, "groupSizes", [
  0,
  0,
  25,
  16,
  12,
  11,
  10,
  9,
  8,
  8,
  7,
  7,
  7,
  7,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5
]);
/**
 * @privateinitializer
 */
__publicField(_BigNumber, "groupBases", [
  0,
  0,
  33554432,
  43046721,
  16777216,
  48828125,
  60466176,
  40353607,
  16777216,
  43046721,
  1e7,
  19487171,
  35831808,
  62748517,
  7529536,
  11390625,
  16777216,
  24137569,
  34012224,
  47045881,
  64e6,
  4084101,
  5153632,
  6436343,
  7962624,
  9765625,
  11881376,
  14348907,
  17210368,
  20511149,
  243e5,
  28629151,
  33554432,
  39135393,
  45435424,
  52521875,
  60466176
]);
/**
 * The word size of big number chunks.
 *
 * @property wordSize
 *
 * @example
 * console.log(BigNumber.wordSize);  // output: 26
 */
__publicField(_BigNumber, "wordSize", 26);
var BigNumber = _BigNumber;

// node_modules/@bsv/sdk/dist/esm/src/primitives/Mersenne.js
var Mersenne = class {
  /**
   * @constructor
   * @param name - An identifier for the Mersenne instance.
   * @param p - A string representation of the pseudo-Mersenne prime, expressed in hexadecimal.
   *
   * @example
   * const mersenne = new Mersenne('M31', '7FFFFFFF');
   */
  constructor(name, p) {
    __publicField(this, "name");
    __publicField(this, "p");
    __publicField(this, "k");
    __publicField(this, "n");
    __publicField(this, "tmp");
    this.name = name;
    this.p = new BigNumber(p, 16);
    this.n = this.p.bitLength();
    this.k = new BigNumber(1).iushln(this.n).isub(this.p);
    this.tmp = this._tmp();
  }
  /**
   * Creates a temporary BigNumber structure for computations,
   * ensuring the appropriate number of words are initially allocated.
   *
   * @method _tmp
   * @returns A BigNumber with scaled size depending on prime magnitude.
   */
  _tmp() {
    const tmp = new BigNumber();
    tmp.words = new Array(Math.ceil(this.n / 13));
    return tmp;
  }
  /**
   * Reduces an input BigNumber in place, under the assumption that
   * it is less than the square of the pseudo-Mersenne prime.
   *
   * @method ireduce
   * @param num - The BigNumber to be reduced.
   * @returns The reduced BigNumber.
   *
   * @example
   * const reduced = mersenne.ireduce(new BigNumber('2345', 16));
   */
  ireduce(num) {
    let r2 = num;
    let rlen;
    do {
      this.split(r2, this.tmp);
      r2 = this.imulK(r2);
      r2 = r2.iadd(this.tmp);
      rlen = r2.bitLength();
    } while (rlen > this.n);
    const cmp = rlen < this.n ? -1 : r2.ucmp(this.p);
    if (cmp === 0) {
      r2.words[0] = 0;
      r2.length = 1;
    } else if (cmp > 0) {
      r2.isub(this.p);
    } else {
      if (r2.strip !== void 0) {
        r2.strip();
      } else {
        r2.strip();
      }
    }
    return r2;
  }
  /**
   * Shifts bits of the input BigNumber to the right, in place,
   * to meet the magnitude of the pseudo-Mersenne prime.
   *
   * @method split
   * @param input - The BigNumber to be shifted.
   * @param out - The BigNumber to hold the shifted result.
   *
   * @example
   * mersenne.split(new BigNumber('2345', 16), new BigNumber());
   */
  split(input, out) {
    input.iushrn(this.n, 0, out);
  }
  /**
   * Performs an in-place multiplication of the parameter by constant k.
   *
   * @method imulK
   * @param num - The BigNumber to multiply with k.
   * @returns The result of the multiplication, in BigNumber format.
   *
   * @example
   * const multiplied = mersenne.imulK(new BigNumber('2345', 16));
   */
  imulK(num) {
    return num.imul(this.k);
  }
};

// node_modules/@bsv/sdk/dist/esm/src/primitives/K256.js
var K256 = class extends Mersenne {
  /**
   * Constructor for the K256 class.
   * Creates an instance of K256 using the super constructor from Mersenne.
   *
   * @constructor
   *
   * @example
   * const k256 = new K256();
   */
  constructor() {
    super("k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f");
  }
  /**
   * Splits a BigNumber into a new BigNumber based on specific computation
   * rules. This method modifies the input and output big numbers.
   *
   * @method split
   * @param input - The BigNumber to be split.
   * @param output - The BigNumber that results from the split.
   *
   * @example
   * const input = new BigNumber(3456);
   * const output = new BigNumber(0);
   * k256.split(input, output);
   */
  split(input, output) {
    const mask = 4194303;
    const outLen = Math.min(input.length, 9);
    let i = 0;
    for (; i < outLen; i++) {
      output.words[i] = input.words[i];
    }
    output.length = outLen;
    if (input.length <= 9) {
      input.words[0] = 0;
      input.length = 1;
      return;
    }
    let prev = input.words[9];
    output.words[output.length++] = prev & mask;
    for (i = 10; i < input.length; i++) {
      const next = input.words[i] | 0;
      input.words[i - 10] = (next & mask) << 4 | prev >>> 22;
      prev = next;
    }
    prev >>>= 22;
    input.words[i - 10] = prev;
    if (prev === 0 && input.length > 10) {
      input.length -= 10;
    } else {
      input.length -= 9;
    }
  }
  /**
   * Multiplies a BigNumber ('num') with the constant 'K' in-place and returns the result.
   * 'K' is equal to 0x1000003d1 or in decimal representation: [ 64, 977 ].
   *
   * @method imulK
   * @param num - The BigNumber to multiply with K.
   * @returns Returns the mutated BigNumber after multiplication.
   *
   * @example
   * const number = new BigNumber(12345);
   * const result = k256.imulK(number);
   */
  imulK(num) {
    num.words[num.length] = 0;
    num.words[num.length + 1] = 0;
    num.length += 2;
    let lo = 0;
    for (let i = 0; i < num.length; i++) {
      const w = num.words[i] | 0;
      lo += w * 977;
      num.words[i] = lo & 67108863;
      lo = w * 64 + (lo / 67108864 | 0);
    }
    if (num.words[num.length - 1] === 0) {
      num.length--;
      if (num.words[num.length - 1] === 0) {
        num.length--;
      }
    }
    return num;
  }
};

// node_modules/@bsv/sdk/dist/esm/src/primitives/ReductionContext.js
var ReductionContext = class {
  /**
   * Constructs a new ReductionContext.
   *
   * @constructor
   * @param m - A BigNumber representing the modulus, or 'k256' to create a context for Koblitz curve.
   *
   * @example
   * new ReductionContext(new BigNumber(11));
   * new ReductionContext('k256');
   */
  constructor(m) {
    __publicField(this, "prime");
    __publicField(this, "m");
    if (m === "k256") {
      const prime = new K256();
      this.m = prime.p;
      this.prime = prime;
    } else {
      this.assert(m.gtn(1), "modulus must be greater than 1");
      this.m = m;
      this.prime = null;
    }
  }
  /**
   * Asserts that given value is truthy. Throws an Error with a provided message
   * if the value is falsy.
   *
   * @private
   * @param val - The value to be checked.
   * @param msg - The error message to be thrown if the value is falsy.
   *
   * @example
   * this.assert(1 < 2, '1 is not less than 2');
   * this.assert(2 < 1, '2 is less than 1'); // throws an Error with message '2 is less than 1'
   */
  assert(val, msg = "Assertion failed") {
    if (!val)
      throw new Error(msg);
  }
  /**
   * Verifies that a BigNumber is positive and red. Throws an error if these
   * conditions are not met.
   *
   * @param a - The BigNumber to be verified.
   *
   * @example
   * this.verify1(new BigNumber(10).toRed());
   * this.verify1(new BigNumber(-10).toRed()); //throws an Error
   * this.verify1(new BigNumber(10)); //throws an Error
   */
  verify1(a) {
    this.assert(a.negative === 0, "red works only with positives");
    this.assert(a.red, "red works only with red numbers");
  }
  /**
   * Verifies that two BigNumbers are both positive and red. Also checks
   * that they have the same reduction context. Throws an error if these
   * conditions are not met.
   *
   * @param a - The first BigNumber to be verified.
   * @param b - The second BigNumber to be verified.
   *
   * @example
   * this.verify2(new BigNumber(10).toRed(this), new BigNumber(20).toRed(this));
   * this.verify2(new BigNumber(-10).toRed(this), new BigNumber(20).toRed(this)); //throws an Error
   * this.verify2(new BigNumber(10).toRed(this), new BigNumber(20)); //throws an Error
   */
  verify2(a, b) {
    this.assert((a.negative | b.negative) === 0, "red works only with positives");
    this.assert(a.red != null && a.red === b.red, "red works only with red numbers");
  }
  /**
   * Performs an in-place reduction of the given BigNumber by the modulus of the reduction context, 'm'.
   *
   * @method imod
   *
   * @param a - BigNumber to be reduced.
   *
   * @returns Returns the reduced result.
   *
   * @example
   * const context = new ReductionContext(new BigNumber(7));
   * context.imod(new BigNumber(19)); // Returns 5
   */
  imod(a) {
    if (this.prime != null)
      return this.prime.ireduce(a).forceRed(this);
    BigNumber.move(a, a.umod(this.m).forceRed(this));
    return a;
  }
  /**
   * Negates a BigNumber in the context of the modulus.
   *
   * @method neg
   *
   * @param a - BigNumber to negate.
   *
   * @returns Returns the negation of 'a' in the reduction context.
   *
   * @example
   * const context = new ReductionContext(new BigNumber(7));
   * context.neg(new BigNumber(3)); // Returns 4
   */
  neg(a) {
    if (a.isZero()) {
      return a.clone();
    }
    return this.m.sub(a).forceRed(this);
  }
  /**
   * Performs the addition operation on two BigNumbers in the reduction context.
   *
   * @method add
   *
   * @param a - First BigNumber to add.
   * @param b - Second BigNumber to add.
   *
   * @returns Returns the result of 'a + b' in the reduction context.
   *
   * @example
   * const context = new ReductionContext(new BigNumber(5));
   * context.add(new BigNumber(2), new BigNumber(4)); // Returns 1
   */
  add(a, b) {
    this.verify2(a, b);
    const res = a.add(b);
    if (res.cmp(this.m) >= 0) {
      res.isub(this.m);
    }
    return res.forceRed(this);
  }
  /**
   * Performs an in-place addition operation on two BigNumbers in the reduction context
   * in order to avoid creating a new BigNumber, it modifies the first one with the result.
   *
   * @method iadd
   *
   * @param a - First BigNumber to add.
   * @param b - Second BigNumber to add.
   *
   * @returns Returns the modified 'a' after addition with 'b' in the reduction context.
   *
   * @example
   * const context = new ReductionContext(new BigNumber(5));
   * const a = new BigNumber(2);
   * context.iadd(a, new BigNumber(4)); // Modifies 'a' to be 1
   */
  iadd(a, b) {
    this.verify2(a, b);
    const res = a.iadd(b);
    if (res.cmp(this.m) >= 0) {
      res.isub(this.m);
    }
    return res;
  }
  /**
   * Subtracts one BigNumber from another BigNumber in the reduction context.
   *
   * @method sub
   *
   * @param a - BigNumber to be subtracted from.
   * @param b - BigNumber to subtract.
   *
   * @returns Returns the result of 'a - b' in the reduction context.
   *
   * @example
   * const context = new ReductionContext(new BigNumber(7));
   * context.sub(new BigNumber(3), new BigNumber(2)); // Returns 1
   */
  sub(a, b) {
    this.verify2(a, b);
    const res = a.sub(b);
    if (res.cmpn(0) < 0) {
      res.iadd(this.m);
    }
    return res.forceRed(this);
  }
  /**
   * Performs in-place subtraction of one BigNumber from another in the reduction context,
   * it modifies the first BigNumber with the result.
   *
   * @method isub
   *
   * @param a - BigNumber to be subtracted from.
   * @param b - BigNumber to subtract.
   *
   * @returns Returns the modified 'a' after subtraction of 'b' in the reduction context.
   *
   * @example
   * const context = new ReductionContext(new BigNumber(5));
   * const a = new BigNumber(4);
   * context.isub(a, new BigNumber(2)); // Modifies 'a' to be 2
   */
  isub(a, b) {
    this.verify2(a, b);
    const res = a.isub(b);
    if (res.cmpn(0) < 0) {
      res.iadd(this.m);
    }
    return res;
  }
  /**
   * Performs bitwise shift left operation on a BigNumber in the reduction context.
   *
   * @method shl
   *
   * @param a - BigNumber to perform shift on.
   * @param num - The number of positions to shift.
   *
   * @returns Returns the result of shifting 'a' left by 'num' positions in the reduction context.
   *
   * @example
   * const context = new ReductionContext(new BigNumber(32));
   * context.shl(new BigNumber(4), 2); // Returns 16
   */
  shl(a, num) {
    this.verify1(a);
    return this.imod(a.ushln(num));
  }
  /**
   * Performs in-place multiplication of two BigNumbers in the reduction context,
   * modifying the first BigNumber with the result.
   *
   * @method imul
   *
   * @param a - First BigNumber to multiply.
   * @param b - Second BigNumber to multiply.
   *
   * @returns Returns the modified 'a' after multiplication with 'b' in the reduction context.
   *
   * @example
   * const context = new ReductionContext(new BigNumber(7));
   * const a = new BigNumber(3);
   * context.imul(a, new BigNumber(2)); // Modifies 'a' to be 6
   */
  imul(a, b) {
    this.verify2(a, b);
    return this.imod(a.imul(b));
  }
  /**
   * Multiplies two BigNumbers in the reduction context.
   *
   * @method mul
   *
   * @param a - First BigNumber to multiply.
   * @param b - Second BigNumber to multiply.
   *
   * @returns Returns the result of 'a * b' in the reduction context.
   *
   * @example
   * const context = new ReductionContext(new BigNumber(7));
   * context.mul(new BigNumber(3), new BigNumber(2)); // Returns 6
   */
  mul(a, b) {
    this.verify2(a, b);
    return this.imod(a.mul(b));
  }
  /**
   * Calculates the square of a BigNumber in the reduction context,
   * modifying the original BigNumber with the result.
   *
   * @method isqr
   *
   * @param a - BigNumber to be squared.
   *
   * @returns Returns the squared 'a' in the reduction context.
   *
   * @example
   * const context = new ReductionContext(new BigNumber(7));
   * const a = new BigNumber(3);
   * context.isqr(a); // Modifies 'a' to be 2 (9 % 7 = 2)
   */
  isqr(a) {
    return this.imul(a, a.clone());
  }
  /**
   * Calculates the square of a BigNumber in the reduction context.
   *
   * @method sqr
   *
   * @param a - BigNumber to be squared.
   *
   * @returns Returns the result of 'a^2' in the reduction context.
   *
   * @example
   * const context = new ReductionContext(new BigNumber(7));
   * context.sqr(new BigNumber(3)); // Returns 2 (9 % 7 = 2)
   */
  sqr(a) {
    return this.mul(a, a);
  }
  /**
   * Calculates the square root of a BigNumber in the reduction context.
   *
   * @method sqrt
   *
   * @param a - The BigNumber to calculate the square root of.
   *
   * @returns Returns the square root of 'a' in the reduction context.
   *
   * @example
   * const context = new ReductionContext(new BigNumber(9));
   * context.sqrt(new BigNumber(4)); // Returns 2
   */
  sqrt(a) {
    if (a.isZero())
      return a.clone();
    const mod3 = this.m.andln(3);
    this.assert(mod3 % 2 === 1);
    if (mod3 === 3) {
      const pow = this.m.add(new BigNumber(1)).iushrn(2);
      return this.pow(a, pow);
    }
    const q = this.m.subn(1);
    let s2 = 0;
    while (!q.isZero() && q.andln(1) === 0) {
      s2++;
      q.iushrn(1);
    }
    this.assert(!q.isZero());
    const one = new BigNumber(1).toRed(this);
    const nOne = one.redNeg();
    const lpow = this.m.subn(1).iushrn(1);
    const zl = this.m.bitLength();
    const z = new BigNumber(2 * zl * zl).toRed(this);
    while (this.pow(z, lpow).cmp(nOne) !== 0) {
      z.redIAdd(nOne);
    }
    let c = this.pow(z, q);
    let r2 = this.pow(a, q.addn(1).iushrn(1));
    let t = this.pow(a, q);
    let m = s2;
    while (t.cmp(one) !== 0) {
      let tmp = t;
      let i = 0;
      for (; tmp.cmp(one) !== 0; i++) {
        tmp = tmp.redSqr();
      }
      this.assert(i < m);
      const b = this.pow(c, new BigNumber(1).iushln(m - i - 1));
      r2 = r2.redMul(b);
      c = b.redSqr();
      t = t.redMul(c);
      m = i;
    }
    return r2;
  }
  /**
   * Calculates the multiplicative inverse of a BigNumber in the reduction context.
   *
   * @method invm
   *
   * @param a - The BigNumber to find the multiplicative inverse of.
   *
   * @returns Returns the multiplicative inverse of 'a' in the reduction context.
   *
   * @example
   * const context = new ReductionContext(new BigNumber(11));
   * context.invm(new BigNumber(3)); // Returns 4 (3*4 mod 11 = 1)
   */
  invm(a) {
    const inv = a._invmp(this.m);
    if (inv.negative !== 0) {
      inv.negative = 0;
      return this.imod(inv).redNeg();
    } else {
      return this.imod(inv);
    }
  }
  /**
   * Raises a BigNumber to a power in the reduction context.
   *
   * @method pow
   *
   * @param a - The BigNumber to be raised to a power.
   * @param num - The power to raise the BigNumber to.
   *
   * @returns Returns the result of 'a' raised to the power of 'num' in the reduction context.
   *
   * @example
   * const context = new ReductionContext(new BigNumber(7));
   * context.pow(new BigNumber(3), new BigNumber(2)); // Returns 2 (3^2 % 7)
   */
  pow(a, num) {
    if (num.isZero())
      return new BigNumber(1).toRed(this);
    if (num.cmpn(1) === 0)
      return a.clone();
    const windowSize = 4;
    const wnd = new Array(1 << windowSize);
    wnd[0] = new BigNumber(1).toRed(this);
    wnd[1] = a;
    let i = 2;
    for (; i < wnd.length; i++) {
      wnd[i] = this.mul(wnd[i - 1], a);
    }
    let res = wnd[0];
    let current = 0;
    let currentLen = 0;
    let start = num.bitLength() % 26;
    if (start === 0) {
      start = 26;
    }
    for (i = num.length - 1; i >= 0; i--) {
      const word = num.words[i];
      for (let j = start - 1; j >= 0; j--) {
        const bit = word >> j & 1;
        if (res !== wnd[0]) {
          res = this.sqr(res);
        }
        if (bit === 0 && current === 0) {
          currentLen = 0;
          continue;
        }
        current <<= 1;
        current |= bit;
        currentLen++;
        if (currentLen !== windowSize && (i !== 0 || j !== 0))
          continue;
        res = this.mul(res, wnd[current]);
        currentLen = 0;
        current = 0;
      }
      start = 26;
    }
    return res;
  }
  /**
   * Converts a BigNumber to its equivalent in the reduction context.
   *
   * @method convertTo
   *
   * @param num - The BigNumber to convert to the reduction context.
   *
   * @returns Returns the converted BigNumber compatible with the reduction context.
   *
   * @example
   * const context = new ReductionContext(new BigNumber(7));
   * context.convertTo(new BigNumber(8)); // Returns 1 (8 % 7)
   */
  convertTo(num) {
    const r2 = num.umod(this.m);
    return r2 === num ? r2.clone() : r2;
  }
  /**
   * Converts a BigNumber from reduction context to its regular form.
   *
   * @method convertFrom
   *
   * @param num - The BigNumber to convert from the reduction context.
   *
   * @returns Returns the converted BigNumber in its regular form.
   *
   * @example
   * const context = new ReductionContext(new BigNumber(7));
   * const a = context.convertTo(new BigNumber(8)); // 'a' is now 1 in the reduction context
   * context.convertFrom(a); // Returns 1
   */
  convertFrom(num) {
    const res = num.clone();
    res.red = null;
    return res;
  }
};

// node_modules/@bsv/sdk/dist/esm/src/primitives/MontgomoryMethod.js
var MontgomoryMethod = class extends ReductionContext {
  /**
   * @constructor
   * @param m - The modulus to be used for the Montgomery method reductions.
   */
  constructor(m) {
    super(m);
    __publicField(this, "shift");
    __publicField(this, "r");
    __publicField(this, "r2");
    __publicField(this, "rinv");
    __publicField(this, "minv");
    this.shift = this.m.bitLength();
    if (this.shift % 26 !== 0) {
      this.shift += 26 - this.shift % 26;
    }
    this.r = new BigNumber(1).iushln(this.shift);
    this.r2 = this.imod(this.r.sqr());
    this.rinv = this.r._invmp(this.m);
    this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
    this.minv = this.minv.umod(this.r);
    this.minv = this.r.sub(this.minv);
  }
  /**
   * Converts a number into the Montgomery domain.
   *
   * @method convertTo
   * @param num - The number to be converted into the Montgomery domain.
   * @returns The result of the conversion into the Montgomery domain.
   *
   * @example
   * const montMethod = new MontgomoryMethod(m);
   * const convertedNum = montMethod.convertTo(num);
   */
  convertTo(num) {
    return this.imod(num.ushln(this.shift));
  }
  /**
   * Converts a number from the Montgomery domain back to the original domain.
   *
   * @method convertFrom
   * @param num - The number to be converted from the Montgomery domain.
   * @returns The result of the conversion from the Montgomery domain.
   *
   * @example
   * const montMethod = new MontgomoryMethod(m);
   * const convertedNum = montMethod.convertFrom(num);
   */
  convertFrom(num) {
    const r2 = this.imod(num.mul(this.rinv));
    r2.red = null;
    return r2;
  }
  /**
   * Performs an in-place multiplication of two numbers in the Montgomery domain.
   *
   * @method imul
   * @param a - The first number to multiply.
   * @param b - The second number to multiply.
   * @returns The result of the in-place multiplication.
   *
   * @example
   * const montMethod = new MontgomoryMethod(m);
   * const product = montMethod.imul(a, b);
   */
  imul(a, b) {
    if (a.isZero() || b.isZero()) {
      a.words[0] = 0;
      a.length = 1;
      return a;
    }
    const t = a.imul(b);
    const c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
    const u = t.isub(c).iushrn(this.shift);
    let res = u;
    if (u.cmp(this.m) >= 0) {
      res = u.isub(this.m);
    } else if (u.cmpn(0) < 0) {
      res = u.iadd(this.m);
    }
    return res.forceRed(this);
  }
  /**
   * Performs the multiplication of two numbers in the Montgomery domain.
   *
   * @method mul
   * @param a - The first number to multiply.
   * @param b - The second number to multiply.
   * @returns The result of the multiplication.
   *
   * @example
   * const montMethod = new MontgomoryMethod(m);
   * const product = montMethod.mul(a, b);
   */
  mul(a, b) {
    if (a.isZero() || b.isZero())
      return new BigNumber(0).forceRed(this);
    const t = a.mul(b);
    const c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
    const u = t.isub(c).iushrn(this.shift);
    let res = u;
    if (u.cmp(this.m) >= 0) {
      res = u.isub(this.m);
    } else if (u.cmpn(0) < 0) {
      res = u.iadd(this.m);
    }
    return res.forceRed(this);
  }
  /**
   * Calculates the modular multiplicative inverse of a number in the Montgomery domain.
   *
   * @method invm
   * @param a - The number to compute the modular multiplicative inverse of.
   * @returns The modular multiplicative inverse of 'a'.
   *
   * @example
   * const montMethod = new MontgomoryMethod(m);
   * const inverse = montMethod.invm(a);
   */
  invm(a) {
    const res = this.imod(a._invmp(this.m).mul(this.r2));
    return res.forceRed(this);
  }
};

// node_modules/@bsv/sdk/dist/esm/src/primitives/BasePoint.js
var BasePoint = class {
  constructor(type) {
    __publicField(this, "curve");
    __publicField(this, "type");
    __publicField(this, "precomputed");
    this.curve = new Curve();
    this.type = type;
    this.precomputed = null;
  }
};

// node_modules/@bsv/sdk/dist/esm/src/primitives/JacobianPoint.js
var JacobianPoint = class _JacobianPoint extends BasePoint {
  /**
   * Constructs a new `JacobianPoint` instance.
   *
   * @param x - If `null`, the x-coordinate will default to the curve's defined 'one' constant.
   * If `x` is not a BigNumber, `x` will be converted to a `BigNumber` assuming it is a hex string.
   *
   * @param y - If `null`, the y-coordinate will default to the curve's defined 'one' constant.
   * If `y` is not a BigNumber, `y` will be converted to a `BigNumber` assuming it is a hex string.
   *
   * @param z - If `null`, the z-coordinate will default to 0.
   * If `z` is not a BigNumber, `z` will be converted to a `BigNumber` assuming it is a hex string.
   *
   * @example
   * const pointJ1 = new JacobianPoint(null, null, null); // creates point at infinity
   * const pointJ2 = new JacobianPoint('3', '4', '1'); // creates point (3, 4, 1)
   */
  constructor(x, y, z) {
    super("jacobian");
    __publicField(this, "x");
    __publicField(this, "y");
    __publicField(this, "z");
    __publicField(this, "zOne");
    if (x === null && y === null && z === null) {
      this.x = this.curve.one;
      this.y = this.curve.one;
      this.z = new BigNumber(0);
    } else {
      if (!BigNumber.isBN(x)) {
        x = new BigNumber(x, 16);
      }
      this.x = x;
      if (!BigNumber.isBN(y)) {
        y = new BigNumber(y, 16);
      }
      this.y = y;
      if (!BigNumber.isBN(z)) {
        z = new BigNumber(z, 16);
      }
      this.z = z;
    }
    if (this.x.red == null) {
      this.x = this.x.toRed(this.curve.red);
    }
    if (this.y.red == null) {
      this.y = this.y.toRed(this.curve.red);
    }
    if (this.z.red == null) {
      this.z = this.z.toRed(this.curve.red);
    }
    this.zOne = this.z === this.curve.one;
  }
  /**
   * Converts the `JacobianPoint` object instance to standard affine `Point` format and returns `Point` type.
   *
   * @returns The `Point`(affine) object representing the same point as the original `JacobianPoint`.
   *
   * If the initial `JacobianPoint` represents point at infinity, an instance of `Point` at infinity is returned.
   *
   * @example
   * const pointJ = new JacobianPoint('3', '4', '1');
   * const pointP = pointJ.toP();  // The point in affine coordinates.
   */
  toP() {
    if (this.isInfinity()) {
      return new Point(null, null);
    }
    const zinv = this.z.redInvm();
    const zinv2 = zinv.redSqr();
    const ax = this.x.redMul(zinv2);
    const ay = this.y.redMul(zinv2).redMul(zinv);
    return new Point(ax, ay);
  }
  /**
   * Negation operation. It returns the additive inverse of the Jacobian point.
   *
   * @method neg
   * @returns Returns a new Jacobian point as the result of the negation.
   *
   * @example
   * const jp = new JacobianPoint(x, y, z)
   * const result = jp.neg()
   */
  neg() {
    return new _JacobianPoint(this.x, this.y.redNeg(), this.z);
  }
  /**
   * Addition operation in the Jacobian coordinates. It takes a Jacobian point as an argument
   * and returns a new Jacobian point as a result of the addition. In the special cases,
   * when either one of the points is the point at infinity, it will return the other point.
   *
   * @method add
   * @param p - The Jacobian point to be added.
   * @returns Returns a new Jacobian point as the result of the addition.
   *
   * @example
   * const p1 = new JacobianPoint(x1, y1, z1)
   * const p2 = new JacobianPoint(x2, y2, z2)
   * const result = p1.add(p2)
   */
  add(p) {
    if (this.isInfinity()) {
      return p;
    }
    if (p.isInfinity()) {
      return this;
    }
    const pz2 = p.z.redSqr();
    const z2 = this.z.redSqr();
    const u1 = this.x.redMul(pz2);
    const u2 = p.x.redMul(z2);
    const s1 = this.y.redMul(pz2.redMul(p.z));
    const s2 = p.y.redMul(z2.redMul(this.z));
    const h = u1.redSub(u2);
    const r2 = s1.redSub(s2);
    if (h.cmpn(0) === 0) {
      if (r2.cmpn(0) !== 0) {
        return new _JacobianPoint(null, null, null);
      } else {
        return this.dbl();
      }
    }
    const h2 = h.redSqr();
    const h3 = h2.redMul(h);
    const v = u1.redMul(h2);
    const nx = r2.redSqr().redIAdd(h3).redISub(v).redISub(v);
    const ny = r2.redMul(v.redISub(nx)).redISub(s1.redMul(h3));
    const nz = this.z.redMul(p.z).redMul(h);
    return new _JacobianPoint(nx, ny, nz);
  }
  /**
   * Mixed addition operation. This function combines the standard point addition with
   * the transformation from the affine to Jacobian coordinates. It first converts
   * the affine point to Jacobian, and then preforms the addition.
   *
   * @method mixedAdd
   * @param p - The affine point to be added.
   * @returns Returns the result of the mixed addition as a new Jacobian point.
   *
   * @example
   * const jp = new JacobianPoint(x1, y1, z1)
   * const ap = new Point(x2, y2)
   * const result = jp.mixedAdd(ap)
   */
  mixedAdd(p) {
    if (this.isInfinity()) {
      return p.toJ();
    }
    if (p.isInfinity()) {
      return this;
    }
    const z2 = this.z.redSqr();
    const u1 = this.x;
    const u2 = p.x.redMul(z2);
    const s1 = this.y;
    const s2 = p.y.redMul(z2).redMul(this.z);
    const h = u1.redSub(u2);
    const r2 = s1.redSub(s2);
    if (h.cmpn(0) === 0) {
      if (r2.cmpn(0) !== 0) {
        return new _JacobianPoint(null, null, null);
      } else {
        return this.dbl();
      }
    }
    const h2 = h.redSqr();
    const h3 = h2.redMul(h);
    const v = u1.redMul(h2);
    const nx = r2.redSqr().redIAdd(h3).redISub(v).redISub(v);
    const ny = r2.redMul(v.redISub(nx)).redISub(s1.redMul(h3));
    const nz = this.z.redMul(h);
    return new _JacobianPoint(nx, ny, nz);
  }
  /**
   * Multiple doubling operation. It doubles the Jacobian point as many times as the pow parameter specifies. If pow is 0 or the point is the point at infinity, it will return the point itself.
   *
   * @method dblp
   * @param pow - The number of times the point should be doubled.
   * @returns Returns a new Jacobian point as the result of multiple doublings.
   *
   * @example
   * const jp = new JacobianPoint(x, y, z)
   * const result = jp.dblp(3)
   */
  dblp(pow) {
    if (pow === 0) {
      return this;
    }
    if (this.isInfinity()) {
      return this;
    }
    if (typeof pow === "undefined") {
      return this.dbl();
    }
    let r2 = this;
    for (let i = 0; i < pow; i++) {
      r2 = r2.dbl();
    }
    return r2;
  }
  /**
   * Point doubling operation in the Jacobian coordinates. A special case is when the point is the point at infinity, in this case, this function will return the point itself.
   *
   * @method dbl
   * @returns Returns a new Jacobian point as the result of the doubling.
   *
   * @example
   * const jp = new JacobianPoint(x, y, z)
   * const result = jp.dbl()
   */
  dbl() {
    if (this.isInfinity()) {
      return this;
    }
    let nx;
    let ny;
    let nz;
    if (this.zOne) {
      const xx = this.x.redSqr();
      const yy = this.y.redSqr();
      const yyyy = yy.redSqr();
      let s2 = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
      s2 = s2.redIAdd(s2);
      const m = xx.redAdd(xx).redIAdd(xx);
      const t = m.redSqr().redISub(s2).redISub(s2);
      let yyyy8 = yyyy.redIAdd(yyyy);
      yyyy8 = yyyy8.redIAdd(yyyy8);
      yyyy8 = yyyy8.redIAdd(yyyy8);
      nx = t;
      ny = m.redMul(s2.redISub(t)).redISub(yyyy8);
      nz = this.y.redAdd(this.y);
    } else {
      const a = this.x.redSqr();
      const b = this.y.redSqr();
      const c = b.redSqr();
      let d = this.x.redAdd(b).redSqr().redISub(a).redISub(c);
      d = d.redIAdd(d);
      const e = a.redAdd(a).redIAdd(a);
      const f2 = e.redSqr();
      let c8 = c.redIAdd(c);
      c8 = c8.redIAdd(c8);
      c8 = c8.redIAdd(c8);
      nx = f2.redISub(d).redISub(d);
      ny = e.redMul(d.redISub(nx)).redISub(c8);
      nz = this.y.redMul(this.z);
      nz = nz.redIAdd(nz);
    }
    return new _JacobianPoint(nx, ny, nz);
  }
  /**
   * Equality check operation. It checks whether the affine or Jacobian point is equal to this Jacobian point.
   *
   * @method eq
   * @param p - The affine or Jacobian point to compare with.
   * @returns Returns true if the points are equal, otherwise returns false.
   *
   * @example
   * const jp1 = new JacobianPoint(x1, y1, z1)
   * const jp2 = new JacobianPoint(x2, y2, z2)
   * const areEqual = jp1.eq(jp2)
   */
  eq(p) {
    if (p.type === "affine") {
      return this.eq(p.toJ());
    }
    if (this === p) {
      return true;
    }
    const z2 = this.z.redSqr();
    p = p;
    const pz2 = p.z.redSqr();
    if (this.x.redMul(pz2).redISub(p.x.redMul(z2)).cmpn(0) !== 0) {
      return false;
    }
    const z3 = z2.redMul(this.z);
    const pz3 = pz2.redMul(p.z);
    return this.y.redMul(pz3).redISub(p.y.redMul(z3)).cmpn(0) === 0;
  }
  /**
   * Equality check operation in relation to an x coordinate of a point in projective coordinates.
   * It checks whether the x coordinate of the Jacobian point is equal to the provided x coordinate
   * of a point in projective coordinates.
   *
   * @method eqXToP
   * @param x - The x coordinate of a point in projective coordinates.
   * @returns Returns true if the x coordinates are equal, otherwise returns false.
   *
   * @example
   * const jp = new JacobianPoint(x1, y1, z1)
   * const isXEqual = jp.eqXToP(x2)
   */
  eqXToP(x) {
    const zs = this.z.redSqr();
    const rx = x.toRed(this.curve.red).redMul(zs);
    if (this.x.cmp(rx) === 0) {
      return true;
    }
    const xc = x.clone();
    const t = this.curve.redN.redMul(zs);
    for (; ; ) {
      xc.iadd(this.curve.n);
      if (xc.cmp(this.curve.p) >= 0) {
        return false;
      }
      rx.redIAdd(t);
      if (this.x.cmp(rx) === 0) {
        return true;
      }
    }
  }
  /**
   * Returns the string representation of the JacobianPoint instance.
   * @method inspect
   * @returns Returns the string description of the JacobianPoint. If the JacobianPoint represents a point at infinity, the return value of this function is '<EC JPoint Infinity>'. For a normal point, it returns the string description format as '<EC JPoint x: x-coordinate y: y-coordinate z: z-coordinate>'.
   *
   * @example
   * const point = new JacobianPoint('5', '6', '1');
   * console.log(point.inspect()); // Output: '<EC JPoint x: 5 y: 6 z: 1>'
   */
  inspect() {
    if (this.isInfinity()) {
      return "<EC JPoint Infinity>";
    }
    return "<EC JPoint x: " + this.x.toString(16, 2) + " y: " + this.y.toString(16, 2) + " z: " + this.z.toString(16, 2) + ">";
  }
  /**
   * Checks whether the JacobianPoint instance represents a point at infinity.
   * @method isInfinity
   * @returns Returns true if the JacobianPoint's z-coordinate equals to zero (which represents the point at infinity in Jacobian coordinates). Returns false otherwise.
   *
   * @example
   * const point = new JacobianPoint('5', '6', '0');
   * console.log(point.isInfinity()); // Output: true
   */
  isInfinity() {
    return this.z.cmpn(0) === 0;
  }
};

// node_modules/@bsv/sdk/dist/esm/src/primitives/utils.js
var utils_exports = {};
__export(utils_exports, {
  Reader: () => Reader,
  Writer: () => Writer,
  encode: () => encode,
  fromBase58: () => fromBase58,
  fromBase58Check: () => fromBase58Check,
  toArray: () => toArray2,
  toBase58: () => toBase58,
  toBase58Check: () => toBase58Check,
  toBase64: () => toBase64,
  toHex: () => toHex,
  toUTF8: () => toUTF8,
  zero2: () => zero2
});

// node_modules/@bsv/sdk/dist/esm/src/primitives/Hash.js
var Hash_exports = {};
__export(Hash_exports, {
  RIPEMD160: () => RIPEMD160,
  SHA1: () => SHA1,
  SHA1HMAC: () => SHA1HMAC,
  SHA256: () => SHA256,
  SHA256HMAC: () => SHA256HMAC,
  SHA512: () => SHA512,
  SHA512HMAC: () => SHA512HMAC,
  hash160: () => hash160,
  hash256: () => hash256,
  pbkdf2: () => pbkdf2,
  ripemd160: () => ripemd160,
  sha1: () => sha1,
  sha256: () => sha256,
  sha256hmac: () => sha256hmac,
  sha512: () => sha512,
  sha512hmac: () => sha512hmac,
  toArray: () => toArray
});
var assert = (expression, message = "Hash assertion failed") => {
  if (!expression) {
    throw new Error(message);
  }
};
var BaseHash = class {
  constructor(blockSize, outSize, hmacStrength, padLength) {
    __publicField(this, "pending");
    __publicField(this, "pendingTotal");
    __publicField(this, "blockSize");
    __publicField(this, "outSize");
    __publicField(this, "endian");
    __publicField(this, "_delta8");
    __publicField(this, "_delta32");
    __publicField(this, "padLength");
    __publicField(this, "hmacStrength");
    this.pending = null;
    this.pendingTotal = 0;
    this.blockSize = blockSize;
    this.outSize = outSize;
    this.hmacStrength = hmacStrength;
    this.padLength = padLength / 8;
    this.endian = "big";
    this._delta8 = this.blockSize / 8;
    this._delta32 = this.blockSize / 32;
  }
  _update(msg, start) {
    throw new Error("Not implemented");
  }
  _digest() {
    throw new Error("Not implemented");
  }
  _digestHex() {
    throw new Error("Not implemented");
  }
  /**
   * Converts the input message into an array, pads it, and joins into 32bit blocks.
   * If there is enough data, it tries updating the hash computation.
   *
   * @method update
   * @param msg - The message segment to include in the hashing computation.
   * @param enc - The encoding of the message. If 'hex', the string will be treated as such, 'utf8' otherwise.
   *
   * @returns Returns the instance of the object for chaining.
   *
   * @example
   * sha256.update('Hello World', 'utf8');
   */
  update(msg, enc) {
    msg = toArray(msg, enc);
    if (this.pending == null) {
      this.pending = msg;
    } else {
      this.pending = this.pending.concat(msg);
    }
    this.pendingTotal += msg.length;
    if (this.pending.length >= this._delta8) {
      msg = this.pending;
      const r2 = msg.length % this._delta8;
      this.pending = msg.slice(msg.length - r2, msg.length);
      if (this.pending.length === 0) {
        this.pending = null;
      }
      msg = join32(msg, 0, msg.length - r2, this.endian);
      for (let i = 0; i < msg.length; i += this._delta32) {
        this._update(msg, i);
      }
    }
    return this;
  }
  /**
   * Finalizes the hash computation and returns the hash value/result.
   *
   * @method digest
   *
   * @returns Returns the final hash value.
   *
   * @example
   * const hash = sha256.digest();
   */
  digest() {
    this.update(this._pad());
    assert(this.pending === null);
    return this._digest();
  }
  /**
   * Finalizes the hash computation and returns the hash value/result as a hex string.
   *
   * @method digest
   *
   * @returns Returns the final hash value as a hex string.
   *
   * @example
   * const hash = sha256.digestHex();
   */
  digestHex() {
    this.update(this._pad());
    assert(this.pending === null);
    return this._digestHex();
  }
  /**
   * [Private Method] Used internally to prepare the padding for the final stage of the hash computation.
   *
   * @method _pad
   * @private
   *
   * @returns Returns an array denoting the padding.
   */
  _pad() {
    let len = this.pendingTotal;
    const bytes = this._delta8;
    const k = bytes - (len + this.padLength) % bytes;
    const res = new Array(k + this.padLength);
    res[0] = 128;
    let i;
    for (i = 1; i < k; i++) {
      res[i] = 0;
    }
    len <<= 3;
    let t;
    if (this.endian === "big") {
      for (t = 8; t < this.padLength; t++) {
        res[i++] = 0;
      }
      res[i++] = 0;
      res[i++] = 0;
      res[i++] = 0;
      res[i++] = 0;
      res[i++] = len >>> 24 & 255;
      res[i++] = len >>> 16 & 255;
      res[i++] = len >>> 8 & 255;
      res[i++] = len & 255;
    } else {
      res[i++] = len & 255;
      res[i++] = len >>> 8 & 255;
      res[i++] = len >>> 16 & 255;
      res[i++] = len >>> 24 & 255;
      res[i++] = 0;
      res[i++] = 0;
      res[i++] = 0;
      res[i++] = 0;
      for (t = 8; t < this.padLength; t++) {
        res[i++] = 0;
      }
    }
    return res;
  }
};
function isSurrogatePair(msg, i) {
  if ((msg.charCodeAt(i) & 64512) !== 55296) {
    return false;
  }
  if (i < 0 || i + 1 >= msg.length) {
    return false;
  }
  return (msg.charCodeAt(i + 1) & 64512) === 56320;
}
function toArray(msg, enc) {
  if (Array.isArray(msg)) {
    return msg.slice();
  }
  if (!msg) {
    return [];
  }
  const res = [];
  if (typeof msg === "string") {
    if (enc !== "hex") {
      let p = 0;
      for (let i = 0; i < msg.length; i++) {
        let c = msg.charCodeAt(i);
        if (c < 128) {
          res[p++] = c;
        } else if (c < 2048) {
          res[p++] = c >> 6 | 192;
          res[p++] = c & 63 | 128;
        } else if (isSurrogatePair(msg, i)) {
          c = 65536 + ((c & 1023) << 10) + (msg.charCodeAt(++i) & 1023);
          res[p++] = c >> 18 | 240;
          res[p++] = c >> 12 & 63 | 128;
          res[p++] = c >> 6 & 63 | 128;
          res[p++] = c & 63 | 128;
        } else {
          res[p++] = c >> 12 | 224;
          res[p++] = c >> 6 & 63 | 128;
          res[p++] = c & 63 | 128;
        }
      }
    } else {
      msg = msg.replace(/[^a-z0-9]+/ig, "");
      if (msg.length % 2 !== 0) {
        msg = "0" + msg;
      }
      for (let i = 0; i < msg.length; i += 2) {
        res.push(parseInt(msg[i] + msg[i + 1], 16));
      }
    }
  } else {
    msg = msg;
    for (let i = 0; i < msg.length; i++) {
      res[i] = msg[i] | 0;
    }
  }
  return res;
}
function htonl(w) {
  const res = w >>> 24 | w >>> 8 & 65280 | w << 8 & 16711680 | (w & 255) << 24;
  return res >>> 0;
}
function toHex32(msg, endian) {
  let res = "";
  for (let i = 0; i < msg.length; i++) {
    let w = msg[i];
    if (endian === "little") {
      w = htonl(w);
    }
    res += zero8(w.toString(16));
  }
  return res;
}
function zero8(word) {
  if (word.length === 7) {
    return "0" + word;
  } else if (word.length === 6) {
    return "00" + word;
  } else if (word.length === 5) {
    return "000" + word;
  } else if (word.length === 4) {
    return "0000" + word;
  } else if (word.length === 3) {
    return "00000" + word;
  } else if (word.length === 2) {
    return "000000" + word;
  } else if (word.length === 1) {
    return "0000000" + word;
  } else {
    return word;
  }
}
function join32(msg, start, end, endian) {
  const len = end - start;
  assert(len % 4 === 0);
  const res = new Array(len / 4);
  for (let i = 0, k = start; i < res.length; i++, k += 4) {
    let w;
    if (endian === "big") {
      w = msg[k] << 24 | msg[k + 1] << 16 | msg[k + 2] << 8 | msg[k + 3];
    } else {
      w = msg[k + 3] << 24 | msg[k + 2] << 16 | msg[k + 1] << 8 | msg[k];
    }
    res[i] = w >>> 0;
  }
  return res;
}
function split32(msg, endian) {
  const res = new Array(msg.length * 4);
  for (let i = 0, k = 0; i < msg.length; i++, k += 4) {
    const m = msg[i];
    if (endian === "big") {
      res[k] = m >>> 24;
      res[k + 1] = m >>> 16 & 255;
      res[k + 2] = m >>> 8 & 255;
      res[k + 3] = m & 255;
    } else {
      res[k + 3] = m >>> 24;
      res[k + 2] = m >>> 16 & 255;
      res[k + 1] = m >>> 8 & 255;
      res[k] = m & 255;
    }
  }
  return res;
}
function rotr32(w, b) {
  return w >>> b | w << 32 - b;
}
function rotl32(w, b) {
  return w << b | w >>> 32 - b;
}
function sum32(a, b) {
  return a + b >>> 0;
}
function SUM32_3(a, b, c) {
  return a + b + c >>> 0;
}
function SUM32_4(a, b, c, d) {
  return a + b + c + d >>> 0;
}
function SUM32_5(a, b, c, d, e) {
  return a + b + c + d + e >>> 0;
}
function FT_1(s2, x, y, z) {
  if (s2 === 0) {
    return ch32(x, y, z);
  }
  if (s2 === 1 || s2 === 3) {
    return p32(x, y, z);
  }
  if (s2 === 2) {
    return maj32(x, y, z);
  }
}
function ch32(x, y, z) {
  return x & y ^ ~x & z;
}
function maj32(x, y, z) {
  return x & y ^ x & z ^ y & z;
}
function p32(x, y, z) {
  return x ^ y ^ z;
}
function S0_256(x) {
  return rotr32(x, 2) ^ rotr32(x, 13) ^ rotr32(x, 22);
}
function S1_256(x) {
  return rotr32(x, 6) ^ rotr32(x, 11) ^ rotr32(x, 25);
}
function G0_256(x) {
  return rotr32(x, 7) ^ rotr32(x, 18) ^ x >>> 3;
}
function G1_256(x) {
  return rotr32(x, 17) ^ rotr32(x, 19) ^ x >>> 10;
}
var r = [
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  12,
  13,
  14,
  15,
  7,
  4,
  13,
  1,
  10,
  6,
  15,
  3,
  12,
  0,
  9,
  5,
  2,
  14,
  11,
  8,
  3,
  10,
  14,
  4,
  9,
  15,
  8,
  1,
  2,
  7,
  0,
  6,
  13,
  11,
  5,
  12,
  1,
  9,
  11,
  10,
  0,
  8,
  12,
  4,
  13,
  3,
  7,
  15,
  14,
  5,
  6,
  2,
  4,
  0,
  5,
  9,
  7,
  12,
  2,
  10,
  14,
  1,
  3,
  8,
  11,
  6,
  15,
  13
];
var rh = [
  5,
  14,
  7,
  0,
  9,
  2,
  11,
  4,
  13,
  6,
  15,
  8,
  1,
  10,
  3,
  12,
  6,
  11,
  3,
  7,
  0,
  13,
  5,
  10,
  14,
  15,
  8,
  12,
  4,
  9,
  1,
  2,
  15,
  5,
  1,
  3,
  7,
  14,
  6,
  9,
  11,
  8,
  12,
  2,
  10,
  0,
  4,
  13,
  8,
  6,
  4,
  1,
  3,
  11,
  15,
  0,
  5,
  12,
  2,
  13,
  9,
  7,
  10,
  14,
  12,
  15,
  10,
  4,
  1,
  5,
  8,
  7,
  6,
  2,
  13,
  14,
  0,
  3,
  9,
  11
];
var s = [
  11,
  14,
  15,
  12,
  5,
  8,
  7,
  9,
  11,
  13,
  14,
  15,
  6,
  7,
  9,
  8,
  7,
  6,
  8,
  13,
  11,
  9,
  7,
  15,
  7,
  12,
  15,
  9,
  11,
  7,
  13,
  12,
  11,
  13,
  6,
  7,
  14,
  9,
  13,
  15,
  14,
  8,
  13,
  6,
  5,
  12,
  7,
  5,
  11,
  12,
  14,
  15,
  14,
  15,
  9,
  8,
  9,
  14,
  5,
  6,
  8,
  6,
  5,
  12,
  9,
  15,
  5,
  11,
  6,
  8,
  13,
  12,
  5,
  12,
  13,
  14,
  11,
  8,
  5,
  6
];
var sh = [
  8,
  9,
  9,
  11,
  13,
  15,
  15,
  5,
  7,
  7,
  8,
  11,
  14,
  14,
  12,
  6,
  9,
  13,
  15,
  7,
  12,
  8,
  9,
  11,
  7,
  7,
  12,
  7,
  6,
  15,
  13,
  11,
  9,
  7,
  15,
  11,
  8,
  6,
  6,
  14,
  12,
  13,
  5,
  14,
  13,
  13,
  7,
  5,
  15,
  5,
  8,
  11,
  14,
  14,
  6,
  14,
  6,
  9,
  12,
  9,
  12,
  5,
  15,
  8,
  8,
  5,
  12,
  9,
  12,
  5,
  14,
  6,
  8,
  13,
  6,
  5,
  15,
  13,
  11,
  11
];
function f(j, x, y, z) {
  if (j <= 15) {
    return x ^ y ^ z;
  } else if (j <= 31) {
    return x & y | ~x & z;
  } else if (j <= 47) {
    return (x | ~y) ^ z;
  } else if (j <= 63) {
    return x & z | y & ~z;
  } else {
    return x ^ (y | ~z);
  }
}
function K(j) {
  if (j <= 15) {
    return 0;
  } else if (j <= 31) {
    return 1518500249;
  } else if (j <= 47) {
    return 1859775393;
  } else if (j <= 63) {
    return 2400959708;
  } else {
    return 2840853838;
  }
}
function Kh(j) {
  if (j <= 15) {
    return 1352829926;
  } else if (j <= 31) {
    return 1548603684;
  } else if (j <= 47) {
    return 1836072691;
  } else if (j <= 63) {
    return 2053994217;
  } else {
    return 0;
  }
}
function sum64(buf, pos, ah, al) {
  const bh = buf[pos];
  const bl = buf[pos + 1];
  const lo = al + bl >>> 0;
  const hi = (lo < al ? 1 : 0) + ah + bh;
  buf[pos] = hi >>> 0;
  buf[pos + 1] = lo;
}
function sum64_hi(ah, al, bh, bl) {
  const lo = al + bl >>> 0;
  const hi = (lo < al ? 1 : 0) + ah + bh;
  return hi >>> 0;
}
function sum64_lo(ah, al, bh, bl) {
  const lo = al + bl;
  return lo >>> 0;
}
function sum64_4_hi(ah, al, bh, bl, ch, cl, dh, dl) {
  let carry = 0;
  let lo = al;
  lo = lo + bl >>> 0;
  carry += lo < al ? 1 : 0;
  lo = lo + cl >>> 0;
  carry += lo < cl ? 1 : 0;
  lo = lo + dl >>> 0;
  carry += lo < dl ? 1 : 0;
  const hi = ah + bh + ch + dh + carry;
  return hi >>> 0;
}
function sum64_4_lo(ah, al, bh, bl, ch, cl, dh, dl) {
  const lo = al + bl + cl + dl;
  return lo >>> 0;
}
function sum64_5_hi(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
  let carry = 0;
  let lo = al;
  lo = lo + bl >>> 0;
  carry += lo < al ? 1 : 0;
  lo = lo + cl >>> 0;
  carry += lo < cl ? 1 : 0;
  lo = lo + dl >>> 0;
  carry += lo < dl ? 1 : 0;
  lo = lo + el >>> 0;
  carry += lo < el ? 1 : 0;
  const hi = ah + bh + ch + dh + eh + carry;
  return hi >>> 0;
}
function sum64_5_lo(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
  const lo = al + bl + cl + dl + el;
  return lo >>> 0;
}
function rotr64_hi(ah, al, num) {
  const r2 = al << 32 - num | ah >>> num;
  return r2 >>> 0;
}
function rotr64_lo(ah, al, num) {
  const r2 = ah << 32 - num | al >>> num;
  return r2 >>> 0;
}
function shr64_hi(ah, al, num) {
  return ah >>> num;
}
function shr64_lo(ah, al, num) {
  const r2 = ah << 32 - num | al >>> num;
  return r2 >>> 0;
}
var RIPEMD160 = class extends BaseHash {
  constructor() {
    super(512, 160, 192, 64);
    __publicField(this, "h");
    this.endian = "little";
    this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
    this.endian = "little";
  }
  _update(msg, start) {
    let A = this.h[0];
    let B = this.h[1];
    let C = this.h[2];
    let D = this.h[3];
    let E = this.h[4];
    let Ah = A;
    let Bh = B;
    let Ch = C;
    let Dh = D;
    let Eh = E;
    let T;
    for (let j = 0; j < 80; j++) {
      T = sum32(rotl32(SUM32_4(A, f(j, B, C, D), msg[r[j] + start], K(j)), s[j]), E);
      A = E;
      E = D;
      D = rotl32(C, 10);
      C = B;
      B = T;
      T = sum32(rotl32(SUM32_4(Ah, f(79 - j, Bh, Ch, Dh), msg[rh[j] + start], Kh(j)), sh[j]), Eh);
      Ah = Eh;
      Eh = Dh;
      Dh = rotl32(Ch, 10);
      Ch = Bh;
      Bh = T;
    }
    T = SUM32_3(this.h[1], C, Dh);
    this.h[1] = SUM32_3(this.h[2], D, Eh);
    this.h[2] = SUM32_3(this.h[3], E, Ah);
    this.h[3] = SUM32_3(this.h[4], A, Bh);
    this.h[4] = SUM32_3(this.h[0], B, Ch);
    this.h[0] = T;
  }
  _digest() {
    return split32(this.h, "little");
  }
  _digestHex() {
    return toHex32(this.h, "little");
  }
};
var SHA256 = class extends BaseHash {
  constructor() {
    super(512, 256, 192, 64);
    __publicField(this, "h");
    __publicField(this, "W");
    __publicField(this, "k");
    this.h = [
      1779033703,
      3144134277,
      1013904242,
      2773480762,
      1359893119,
      2600822924,
      528734635,
      1541459225
    ];
    this.k = [
      1116352408,
      1899447441,
      3049323471,
      3921009573,
      961987163,
      1508970993,
      2453635748,
      2870763221,
      3624381080,
      310598401,
      607225278,
      1426881987,
      1925078388,
      2162078206,
      2614888103,
      3248222580,
      3835390401,
      4022224774,
      264347078,
      604807628,
      770255983,
      1249150122,
      1555081692,
      1996064986,
      2554220882,
      2821834349,
      2952996808,
      3210313671,
      3336571891,
      3584528711,
      113926993,
      338241895,
      666307205,
      773529912,
      1294757372,
      1396182291,
      1695183700,
      1986661051,
      2177026350,
      2456956037,
      2730485921,
      2820302411,
      3259730800,
      3345764771,
      3516065817,
      3600352804,
      4094571909,
      275423344,
      430227734,
      506948616,
      659060556,
      883997877,
      958139571,
      1322822218,
      1537002063,
      1747873779,
      1955562222,
      2024104815,
      2227730452,
      2361852424,
      2428436474,
      2756734187,
      3204031479,
      3329325298
    ];
    this.W = new Array(64);
  }
  _update(msg, start) {
    const W = this.W;
    let i;
    for (i = 0; i < 16; i++) {
      W[i] = msg[start + i];
    }
    for (; i < W.length; i++) {
      W[i] = SUM32_4(G1_256(W[i - 2]), W[i - 7], G0_256(W[i - 15]), W[i - 16]);
    }
    let a = this.h[0];
    let b = this.h[1];
    let c = this.h[2];
    let d = this.h[3];
    let e = this.h[4];
    let f2 = this.h[5];
    let g = this.h[6];
    let h = this.h[7];
    assert(this.k.length === W.length);
    for (i = 0; i < W.length; i++) {
      const T1 = SUM32_5(h, S1_256(e), ch32(e, f2, g), this.k[i], W[i]);
      const T2 = sum32(S0_256(a), maj32(a, b, c));
      h = g;
      g = f2;
      f2 = e;
      e = sum32(d, T1);
      d = c;
      c = b;
      b = a;
      a = sum32(T1, T2);
    }
    this.h[0] = sum32(this.h[0], a);
    this.h[1] = sum32(this.h[1], b);
    this.h[2] = sum32(this.h[2], c);
    this.h[3] = sum32(this.h[3], d);
    this.h[4] = sum32(this.h[4], e);
    this.h[5] = sum32(this.h[5], f2);
    this.h[6] = sum32(this.h[6], g);
    this.h[7] = sum32(this.h[7], h);
  }
  _digest() {
    return split32(this.h, "big");
  }
  _digestHex() {
    return toHex32(this.h, "big");
  }
};
var SHA1 = class extends BaseHash {
  constructor() {
    super(512, 160, 80, 64);
    __publicField(this, "h");
    __publicField(this, "W");
    __publicField(this, "k");
    this.k = [
      1518500249,
      1859775393,
      2400959708,
      3395469782
    ];
    this.h = [
      1732584193,
      4023233417,
      2562383102,
      271733878,
      3285377520
    ];
    this.W = new Array(80);
  }
  _update(msg, start) {
    const W = this.W;
    let i;
    for (i = 0; i < 16; i++) {
      W[i] = msg[start + i];
    }
    for (; i < W.length; i++) {
      W[i] = rotl32(W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16], 1);
    }
    let a = this.h[0];
    let b = this.h[1];
    let c = this.h[2];
    let d = this.h[3];
    let e = this.h[4];
    for (i = 0; i < W.length; i++) {
      const s2 = ~~(i / 20);
      const t = SUM32_5(rotl32(a, 5), FT_1(s2, b, c, d), e, W[i], this.k[s2]);
      e = d;
      d = c;
      c = rotl32(b, 30);
      b = a;
      a = t;
    }
    this.h[0] = sum32(this.h[0], a);
    this.h[1] = sum32(this.h[1], b);
    this.h[2] = sum32(this.h[2], c);
    this.h[3] = sum32(this.h[3], d);
    this.h[4] = sum32(this.h[4], e);
  }
  _digest() {
    return split32(this.h, "big");
  }
  _digestHex() {
    return toHex32(this.h, "big");
  }
};
var SHA512 = class extends BaseHash {
  constructor() {
    super(1024, 512, 192, 128);
    __publicField(this, "h");
    __publicField(this, "W");
    __publicField(this, "k");
    this.h = [
      1779033703,
      4089235720,
      3144134277,
      2227873595,
      1013904242,
      4271175723,
      2773480762,
      1595750129,
      1359893119,
      2917565137,
      2600822924,
      725511199,
      528734635,
      4215389547,
      1541459225,
      327033209
    ];
    this.k = [
      1116352408,
      3609767458,
      1899447441,
      602891725,
      3049323471,
      3964484399,
      3921009573,
      2173295548,
      961987163,
      4081628472,
      1508970993,
      3053834265,
      2453635748,
      2937671579,
      2870763221,
      3664609560,
      3624381080,
      2734883394,
      310598401,
      1164996542,
      607225278,
      1323610764,
      1426881987,
      3590304994,
      1925078388,
      4068182383,
      2162078206,
      991336113,
      2614888103,
      633803317,
      3248222580,
      3479774868,
      3835390401,
      2666613458,
      4022224774,
      944711139,
      264347078,
      2341262773,
      604807628,
      2007800933,
      770255983,
      1495990901,
      1249150122,
      1856431235,
      1555081692,
      3175218132,
      1996064986,
      2198950837,
      2554220882,
      3999719339,
      2821834349,
      766784016,
      2952996808,
      2566594879,
      3210313671,
      3203337956,
      3336571891,
      1034457026,
      3584528711,
      2466948901,
      113926993,
      3758326383,
      338241895,
      168717936,
      666307205,
      1188179964,
      773529912,
      1546045734,
      1294757372,
      1522805485,
      1396182291,
      2643833823,
      1695183700,
      2343527390,
      1986661051,
      1014477480,
      2177026350,
      1206759142,
      2456956037,
      344077627,
      2730485921,
      1290863460,
      2820302411,
      3158454273,
      3259730800,
      3505952657,
      3345764771,
      106217008,
      3516065817,
      3606008344,
      3600352804,
      1432725776,
      4094571909,
      1467031594,
      275423344,
      851169720,
      430227734,
      3100823752,
      506948616,
      1363258195,
      659060556,
      3750685593,
      883997877,
      3785050280,
      958139571,
      3318307427,
      1322822218,
      3812723403,
      1537002063,
      2003034995,
      1747873779,
      3602036899,
      1955562222,
      1575990012,
      2024104815,
      1125592928,
      2227730452,
      2716904306,
      2361852424,
      442776044,
      2428436474,
      593698344,
      2756734187,
      3733110249,
      3204031479,
      2999351573,
      3329325298,
      3815920427,
      3391569614,
      3928383900,
      3515267271,
      566280711,
      3940187606,
      3454069534,
      4118630271,
      4000239992,
      116418474,
      1914138554,
      174292421,
      2731055270,
      289380356,
      3203993006,
      460393269,
      320620315,
      685471733,
      587496836,
      852142971,
      1086792851,
      1017036298,
      365543100,
      1126000580,
      2618297676,
      1288033470,
      3409855158,
      1501505948,
      4234509866,
      1607167915,
      987167468,
      1816402316,
      1246189591
    ];
    this.W = new Array(160);
  }
  _prepareBlock(msg, start) {
    const W = this.W;
    let i;
    for (i = 0; i < 32; i++) {
      W[i] = msg[start + i];
    }
    for (; i < W.length; i += 2) {
      const c0_hi = g1_512_hi(W[i - 4], W[i - 3]);
      const c0_lo = g1_512_lo(W[i - 4], W[i - 3]);
      const c1_hi = W[i - 14];
      const c1_lo = W[i - 13];
      const c2_hi = g0_512_hi(W[i - 30], W[i - 29]);
      const c2_lo = g0_512_lo(W[i - 30], W[i - 29]);
      const c3_hi = W[i - 32];
      const c3_lo = W[i - 31];
      W[i] = sum64_4_hi(c0_hi, c0_lo, c1_hi, c1_lo, c2_hi, c2_lo, c3_hi, c3_lo);
      W[i + 1] = sum64_4_lo(c0_hi, c0_lo, c1_hi, c1_lo, c2_hi, c2_lo, c3_hi, c3_lo);
    }
  }
  _update(msg, start) {
    this._prepareBlock(msg, start);
    const W = this.W;
    let ah = this.h[0];
    let al = this.h[1];
    let bh = this.h[2];
    let bl = this.h[3];
    let ch = this.h[4];
    let cl = this.h[5];
    let dh = this.h[6];
    let dl = this.h[7];
    let eh = this.h[8];
    let el = this.h[9];
    let fh = this.h[10];
    let fl = this.h[11];
    let gh = this.h[12];
    let gl = this.h[13];
    let hh = this.h[14];
    let hl = this.h[15];
    assert(this.k.length === W.length);
    for (let i = 0; i < W.length; i += 2) {
      let c0_hi = hh;
      let c0_lo = hl;
      let c1_hi = s1_512_hi(eh, el);
      let c1_lo = s1_512_lo(eh, el);
      const c2_hi = ch64_hi(eh, el, fh, fl, gh, gl);
      const c2_lo = ch64_lo(eh, el, fh, fl, gh, gl);
      const c3_hi = this.k[i];
      const c3_lo = this.k[i + 1];
      const c4_hi = W[i];
      const c4_lo = W[i + 1];
      const T1_hi = sum64_5_hi(c0_hi, c0_lo, c1_hi, c1_lo, c2_hi, c2_lo, c3_hi, c3_lo, c4_hi, c4_lo);
      const T1_lo = sum64_5_lo(c0_hi, c0_lo, c1_hi, c1_lo, c2_hi, c2_lo, c3_hi, c3_lo, c4_hi, c4_lo);
      c0_hi = s0_512_hi(ah, al);
      c0_lo = s0_512_lo(ah, al);
      c1_hi = maj64_hi(ah, al, bh, bl, ch, cl);
      c1_lo = maj64_lo(ah, al, bh, bl, ch, cl);
      const T2_hi = sum64_hi(c0_hi, c0_lo, c1_hi, c1_lo);
      const T2_lo = sum64_lo(c0_hi, c0_lo, c1_hi, c1_lo);
      hh = gh;
      hl = gl;
      gh = fh;
      gl = fl;
      fh = eh;
      fl = el;
      eh = sum64_hi(dh, dl, T1_hi, T1_lo);
      el = sum64_lo(dl, dl, T1_hi, T1_lo);
      dh = ch;
      dl = cl;
      ch = bh;
      cl = bl;
      bh = ah;
      bl = al;
      ah = sum64_hi(T1_hi, T1_lo, T2_hi, T2_lo);
      al = sum64_lo(T1_hi, T1_lo, T2_hi, T2_lo);
    }
    sum64(this.h, 0, ah, al);
    sum64(this.h, 2, bh, bl);
    sum64(this.h, 4, ch, cl);
    sum64(this.h, 6, dh, dl);
    sum64(this.h, 8, eh, el);
    sum64(this.h, 10, fh, fl);
    sum64(this.h, 12, gh, gl);
    sum64(this.h, 14, hh, hl);
  }
  _digest() {
    return split32(this.h, "big");
  }
  _digestHex() {
    return toHex32(this.h, "big");
  }
};
function ch64_hi(xh, xl, yh, yl, zh, zl) {
  let r2 = xh & yh ^ ~xh & zh;
  if (r2 < 0) {
    r2 += 4294967296;
  }
  return r2;
}
function ch64_lo(xh, xl, yh, yl, zh, zl) {
  let r2 = xl & yl ^ ~xl & zl;
  if (r2 < 0) {
    r2 += 4294967296;
  }
  return r2;
}
function maj64_hi(xh, xl, yh, yl, zh, zl) {
  let r2 = xh & yh ^ xh & zh ^ yh & zh;
  if (r2 < 0) {
    r2 += 4294967296;
  }
  return r2;
}
function maj64_lo(xh, xl, yh, yl, zh, zl) {
  let r2 = xl & yl ^ xl & zl ^ yl & zl;
  if (r2 < 0) {
    r2 += 4294967296;
  }
  return r2;
}
function s0_512_hi(xh, xl) {
  const c0_hi = rotr64_hi(xh, xl, 28);
  const c1_hi = rotr64_hi(xl, xh, 2);
  const c2_hi = rotr64_hi(xl, xh, 7);
  let r2 = c0_hi ^ c1_hi ^ c2_hi;
  if (r2 < 0) {
    r2 += 4294967296;
  }
  return r2;
}
function s0_512_lo(xh, xl) {
  const c0_lo = rotr64_lo(xh, xl, 28);
  const c1_lo = rotr64_lo(xl, xh, 2);
  const c2_lo = rotr64_lo(xl, xh, 7);
  let r2 = c0_lo ^ c1_lo ^ c2_lo;
  if (r2 < 0) {
    r2 += 4294967296;
  }
  return r2;
}
function s1_512_hi(xh, xl) {
  const c0_hi = rotr64_hi(xh, xl, 14);
  const c1_hi = rotr64_hi(xh, xl, 18);
  const c2_hi = rotr64_hi(xl, xh, 9);
  let r2 = c0_hi ^ c1_hi ^ c2_hi;
  if (r2 < 0) {
    r2 += 4294967296;
  }
  return r2;
}
function s1_512_lo(xh, xl) {
  const c0_lo = rotr64_lo(xh, xl, 14);
  const c1_lo = rotr64_lo(xh, xl, 18);
  const c2_lo = rotr64_lo(xl, xh, 9);
  let r2 = c0_lo ^ c1_lo ^ c2_lo;
  if (r2 < 0) {
    r2 += 4294967296;
  }
  return r2;
}
function g0_512_hi(xh, xl) {
  const c0_hi = rotr64_hi(xh, xl, 1);
  const c1_hi = rotr64_hi(xh, xl, 8);
  const c2_hi = shr64_hi(xh, xl, 7);
  let r2 = c0_hi ^ c1_hi ^ c2_hi;
  if (r2 < 0) {
    r2 += 4294967296;
  }
  return r2;
}
function g0_512_lo(xh, xl) {
  const c0_lo = rotr64_lo(xh, xl, 1);
  const c1_lo = rotr64_lo(xh, xl, 8);
  const c2_lo = shr64_lo(xh, xl, 7);
  let r2 = c0_lo ^ c1_lo ^ c2_lo;
  if (r2 < 0) {
    r2 += 4294967296;
  }
  return r2;
}
function g1_512_hi(xh, xl) {
  const c0_hi = rotr64_hi(xh, xl, 19);
  const c1_hi = rotr64_hi(xl, xh, 29);
  const c2_hi = shr64_hi(xh, xl, 6);
  let r2 = c0_hi ^ c1_hi ^ c2_hi;
  if (r2 < 0) {
    r2 += 4294967296;
  }
  return r2;
}
function g1_512_lo(xh, xl) {
  const c0_lo = rotr64_lo(xh, xl, 19);
  const c1_lo = rotr64_lo(xl, xh, 29);
  const c2_lo = shr64_lo(xh, xl, 6);
  let r2 = c0_lo ^ c1_lo ^ c2_lo;
  if (r2 < 0) {
    r2 += 4294967296;
  }
  return r2;
}
var SHA256HMAC = class {
  /**
   * The constructor for the `SHA256HMAC` class.
   *
   * It initializes the `SHA256HMAC` object and sets up the inner and outer padded keys.
   * If the key size is larger than the blockSize, it is digested using SHA-256.
   * If the key size is less than the blockSize, it is padded with zeroes.
   *
   * @constructor
   * @param key - The key to use to create the HMAC. Can be a number array or a string in hexadecimal format.
   *
   * @example
   * const myHMAC = new SHA256HMAC('deadbeef');
   */
  constructor(key) {
    __publicField(this, "inner");
    __publicField(this, "outer");
    __publicField(this, "blockSize", 64);
    __publicField(this, "outSize", 32);
    key = toArray(key, "hex");
    if (key.length > this.blockSize) {
      key = new SHA256().update(key).digest();
    }
    assert(key.length <= this.blockSize);
    let i;
    for (i = key.length; i < this.blockSize; i++) {
      key.push(0);
    }
    for (i = 0; i < key.length; i++) {
      key[i] ^= 54;
    }
    this.inner = new SHA256().update(key);
    for (i = 0; i < key.length; i++) {
      key[i] ^= 106;
    }
    this.outer = new SHA256().update(key);
  }
  /**
   * Updates the `SHA256HMAC` object with part of the message to be hashed.
   *
   * @method update
   * @param msg - Part of the message to hash. Can be a number array or a string.
   * @param enc - If 'hex', then the input is encoded as hexadecimal. If undefined or not 'hex', then no encoding is performed.
   * @returns Returns the instance of `SHA256HMAC` for chaining calls.
   *
   * @example
   * myHMAC.update('deadbeef', 'hex');
   */
  update(msg, enc) {
    this.inner.update(msg, enc);
    return this;
  }
  /**
   * Finalizes the HMAC computation and returns the resultant hash.
   *
   * @method digest
   * @returns Returns the digest of the hashed data. Can be a number array or a string.
   *
   * @example
   * let hashedMessage = myHMAC.digest();
   */
  digest() {
    this.outer.update(this.inner.digest());
    return this.outer.digest();
  }
  /**
   * Finalizes the HMAC computation and returns the resultant hash as a hex string.
   *
   * @method digest
   * @returns Returns the digest of the hashed data as a hex string
   *
   * @example
   * let hashedMessage = myHMAC.digestHex();
   */
  digestHex() {
    this.outer.update(this.inner.digest());
    return this.outer.digestHex();
  }
};
var SHA1HMAC = class {
  constructor(key) {
    __publicField(this, "inner");
    __publicField(this, "outer");
    __publicField(this, "blockSize", 64);
    key = toArray(key, "hex");
    if (key.length > this.blockSize) {
      key = new SHA1().update(key).digest();
    }
    let i;
    for (i = key.length; i < this.blockSize; i++) {
      key.push(0);
    }
    for (i = 0; i < key.length; i++) {
      key[i] ^= 54;
    }
    this.inner = new SHA1().update(key);
    for (i = 0; i < key.length; i++) {
      key[i] ^= 106;
    }
    this.outer = new SHA1().update(key);
  }
  update(msg, enc) {
    this.inner.update(msg, enc);
    return this;
  }
  digest() {
    this.outer.update(this.inner.digest());
    return this.outer.digest();
  }
  digestHex() {
    this.outer.update(this.inner.digest());
    return this.outer.digestHex();
  }
};
var SHA512HMAC = class {
  /**
   * The constructor for the `SHA512HMAC` class.
   *
   * It initializes the `SHA512HMAC` object and sets up the inner and outer padded keys.
   * If the key size is larger than the blockSize, it is digested using SHA-512.
   * If the key size is less than the blockSize, it is padded with zeroes.
   *
   * @constructor
   * @param key - The key to use to create the HMAC. Can be a number array or a string in hexadecimal format.
   *
   * @example
   * const myHMAC = new SHA512HMAC('deadbeef');
   */
  constructor(key) {
    __publicField(this, "inner");
    __publicField(this, "outer");
    __publicField(this, "blockSize", 128);
    __publicField(this, "outSize", 32);
    key = toArray(key, "hex");
    if (key.length > this.blockSize) {
      key = new SHA512().update(key).digest();
    }
    assert(key.length <= this.blockSize);
    let i;
    for (i = key.length; i < this.blockSize; i++) {
      key.push(0);
    }
    for (i = 0; i < key.length; i++) {
      key[i] ^= 54;
    }
    this.inner = new SHA512().update(key);
    for (i = 0; i < key.length; i++) {
      key[i] ^= 106;
    }
    this.outer = new SHA512().update(key);
  }
  /**
   * Updates the `SHA512HMAC` object with part of the message to be hashed.
   *
   * @method update
   * @param msg - Part of the message to hash. Can be a number array or a string.
   * @param enc - If 'hex', then the input is encoded as hexadecimal. If undefined or not 'hex', then no encoding is performed.
   * @returns Returns the instance of `SHA512HMAC` for chaining calls.
   *
   * @example
   * myHMAC.update('deadbeef', 'hex');
   */
  update(msg, enc) {
    this.inner.update(msg, enc);
    return this;
  }
  /**
   * Finalizes the HMAC computation and returns the resultant hash.
   *
   * @method digest
   * @returns Returns the digest of the hashed data as a number array.
   *
   * @example
   * let hashedMessage = myHMAC.digest();
   */
  digest() {
    this.outer.update(this.inner.digest());
    return this.outer.digest();
  }
  /**
   * Finalizes the HMAC computation and returns the resultant hash as a hex string.
   *
   * @method digest
   * @returns Returns the digest of the hashed data as a hex string
   *
   * @example
   * let hashedMessage = myHMAC.digestHex();
   */
  digestHex() {
    this.outer.update(this.inner.digest());
    return this.outer.digestHex();
  }
};
var ripemd160 = (msg, enc) => {
  return new RIPEMD160().update(msg, enc).digest();
};
var sha1 = (msg, enc) => {
  return new SHA1().update(msg, enc).digest();
};
var sha256 = (msg, enc) => {
  return new SHA256().update(msg, enc).digest();
};
var sha512 = (msg, enc) => {
  return new SHA512().update(msg, enc).digest();
};
var hash256 = (msg, enc) => {
  const first = new SHA256().update(msg, enc).digest();
  return new SHA256().update(first).digest();
};
var hash160 = (msg, enc) => {
  const first = new SHA256().update(msg, enc).digest();
  return new RIPEMD160().update(first).digest();
};
var sha256hmac = (key, msg, enc) => {
  return new SHA256HMAC(key).update(msg, enc).digest();
};
var sha512hmac = (key, msg, enc) => {
  return new SHA512HMAC(key).update(msg, enc).digest();
};
function pbkdf2(password, salt, iterations, keylen, digest = "sha512") {
  if (digest !== "sha512") {
    throw new Error("Only sha512 is supported in this PBKDF2 implementation");
  }
  const DK = new Array(keylen);
  const block1 = [...salt, 0, 0, 0, 0];
  let destPos = 0;
  const hLen = 64;
  const l = Math.ceil(keylen / hLen);
  for (let i = 1; i <= l; i++) {
    block1[salt.length] = i >> 24 & 255;
    block1[salt.length + 1] = i >> 16 & 255;
    block1[salt.length + 2] = i >> 8 & 255;
    block1[salt.length + 3] = i & 255;
    const T = sha512hmac(password, block1);
    let U = T;
    for (let j = 1; j < iterations; j++) {
      U = sha512hmac(password, U);
      for (let k = 0; k < hLen; k++)
        T[k] ^= U[k];
    }
    for (let i2 = 0; i2 < T.length; i2++) {
      DK[destPos + i2] = T[i2];
    }
    destPos += hLen;
  }
  return DK.slice(0, keylen);
}

// node_modules/@bsv/sdk/dist/esm/src/primitives/utils.js
var zero2 = (word) => {
  if (word.length % 2 === 1) {
    return "0" + word;
  } else {
    return word;
  }
};
var toHex = (msg) => {
  let res = "";
  for (let i = 0; i < msg.length; i++) {
    res += zero2(msg[i].toString(16));
  }
  return res;
};
var toArray2 = (msg, enc) => {
  if (Array.isArray(msg)) {
    return msg.slice();
  }
  if (!msg) {
    return [];
  }
  const res = [];
  if (typeof msg !== "string") {
    for (let i = 0; i < msg.length; i++) {
      res[i] = msg[i] | 0;
    }
    return res;
  }
  if (enc === "hex") {
    msg = msg.replace(/[^a-z0-9]+/ig, "");
    if (msg.length % 2 !== 0) {
      msg = "0" + msg;
    }
    for (let i = 0; i < msg.length; i += 2) {
      res.push(parseInt(msg[i] + msg[i + 1], 16));
    }
  } else if (enc === "base64") {
    const base64Chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    const result = [];
    let currentBit = 0;
    let currentByte = 0;
    for (const char of msg.replace(/=+$/, "")) {
      currentBit = currentBit << 6 | base64Chars.indexOf(char);
      currentByte += 6;
      if (currentByte >= 8) {
        currentByte -= 8;
        result.push(currentBit >> currentByte & 255);
        currentBit &= (1 << currentByte) - 1;
      }
    }
    return result;
  } else {
    for (let i = 0; i < msg.length; i++) {
      const c = msg.charCodeAt(i);
      const hi = c >> 8;
      const lo = c & 255;
      if (hi) {
        res.push(hi, lo);
      } else {
        res.push(lo);
      }
    }
  }
  return res;
};
var toUTF8 = (arr) => {
  let result = "";
  for (let i = 0; i < arr.length; i++) {
    const byte = arr[i];
    if (byte <= 127) {
      result += String.fromCharCode(byte);
    } else if (byte >= 192 && byte <= 223) {
      const byte2 = arr[++i];
      const codePoint = (byte & 31) << 6 | byte2 & 63;
      result += String.fromCharCode(codePoint);
    } else if (byte >= 224 && byte <= 239) {
      const byte2 = arr[++i];
      const byte3 = arr[++i];
      const codePoint = (byte & 15) << 12 | (byte2 & 63) << 6 | byte3 & 63;
      result += String.fromCharCode(codePoint);
    } else if (byte >= 240 && byte <= 247) {
      const byte2 = arr[++i];
      const byte3 = arr[++i];
      const byte4 = arr[++i];
      const codePoint = (byte & 7) << 18 | (byte2 & 63) << 12 | (byte3 & 63) << 6 | byte4 & 63;
      const surrogate1 = 55296 + (codePoint - 65536 >> 10);
      const surrogate2 = 56320 + (codePoint - 65536 & 1023);
      result += String.fromCharCode(surrogate1, surrogate2);
    }
  }
  return result;
};
var encode = (arr, enc) => {
  switch (enc) {
    case "hex":
      return toHex(arr);
    case "utf8":
      return toUTF8(arr);
    default:
      return arr;
  }
};
function toBase64(byteArray) {
  const base64Chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  let result = "";
  let i;
  for (i = 0; i < byteArray.length; i += 3) {
    const byte1 = byteArray[i];
    const byte2 = i + 1 < byteArray.length ? byteArray[i + 1] : 0;
    const byte3 = i + 2 < byteArray.length ? byteArray[i + 2] : 0;
    const encoded1 = byte1 >> 2;
    const encoded2 = (byte1 & 3) << 4 | byte2 >> 4;
    const encoded3 = (byte2 & 15) << 2 | byte3 >> 6;
    const encoded4 = byte3 & 63;
    result += base64Chars.charAt(encoded1) + base64Chars.charAt(encoded2);
    result += i + 1 < byteArray.length ? base64Chars.charAt(encoded3) : "=";
    result += i + 2 < byteArray.length ? base64Chars.charAt(encoded4) : "=";
  }
  return result;
}
var base58chars = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
var fromBase58 = (str) => {
  if (!str || typeof str !== "string") {
    throw new Error(`Expected base58 string but got ${str}`);
  }
  if (str.match(/[IOl0]/gmu)) {
    throw new Error(`Invalid base58 character ${str.match(/[IOl0]/gmu)}`);
  }
  const lz = str.match(/^1+/gmu);
  const psz = lz ? lz[0].length : 0;
  const size = (str.length - psz) * (Math.log(58) / Math.log(256)) + 1 >>> 0;
  const uint8 = new Uint8Array([
    ...new Uint8Array(psz),
    ...str.match(/.{1}/gmu).map((i) => base58chars.indexOf(i)).reduce((acc, i) => {
      acc = acc.map((j) => {
        const x = j * 58 + i;
        i = x >> 8;
        return x;
      });
      return acc;
    }, new Uint8Array(size)).reverse().filter(/* @__PURE__ */ ((lastValue) => (value) => (
      // @ts-expect-error
      lastValue = lastValue || value
    ))(false))
  ]);
  return [...uint8];
};
var toBase58 = (bin) => {
  const base58Map = Array(256).fill(-1);
  for (let i = 0; i < base58chars.length; ++i) {
    base58Map[base58chars.charCodeAt(i)] = i;
  }
  const result = [];
  for (const byte of bin) {
    let carry = byte;
    for (let j = 0; j < result.length; ++j) {
      const x = (base58Map[result[j]] << 8) + carry;
      result[j] = base58chars.charCodeAt(x % 58);
      carry = x / 58 | 0;
    }
    while (carry) {
      result.push(base58chars.charCodeAt(carry % 58));
      carry = carry / 58 | 0;
    }
  }
  for (const byte of bin) {
    if (byte)
      break;
    else
      result.push("1".charCodeAt(0));
  }
  result.reverse();
  return String.fromCharCode(...result);
};
var toBase58Check = (bin, prefix2 = [0]) => {
  let hash = hash256([...prefix2, ...bin]);
  hash = [...prefix2, ...bin, ...hash.slice(0, 4)];
  return toBase58(hash);
};
var fromBase58Check = (str, enc, prefixLength = 1) => {
  const bin = fromBase58(str);
  let prefix2 = bin.slice(0, prefixLength);
  let data = bin.slice(prefixLength, -4);
  let hash = [...prefix2, ...data];
  hash = hash256(hash);
  bin.slice(-4).forEach((check, index) => {
    if (check !== hash[index]) {
      throw new Error("Invalid checksum");
    }
  });
  if (enc === "hex") {
    prefix2 = toHex(prefix2);
    data = toHex(data);
  }
  return { prefix: prefix2, data };
};
var Writer = class _Writer {
  constructor(bufs) {
    __publicField(this, "bufs");
    this.bufs = bufs || [];
  }
  getLength() {
    let len = 0;
    for (const buf of this.bufs) {
      len = len + buf.length;
    }
    return len;
  }
  toArray() {
    let ret = [];
    for (const x of this.bufs) {
      if (x.length < 65536) {
        ret.push(...x);
      } else {
        ret = ret.concat(x);
      }
    }
    return ret;
  }
  write(buf) {
    this.bufs.push(buf);
    return this;
  }
  writeReverse(buf) {
    const buf2 = new Array(buf.length);
    for (let i = 0; i < buf2.length; i++) {
      buf2[i] = buf[buf.length - 1 - i];
    }
    this.bufs.push(buf2);
    return this;
  }
  writeUInt8(n) {
    const buf = new Array(1);
    buf[0] = n;
    this.write(buf);
    return this;
  }
  writeInt8(n) {
    const buf = new Array(1);
    buf[0] = n & 255;
    this.write(buf);
    return this;
  }
  writeUInt16BE(n) {
    this.bufs.push([
      n >> 8 & 255,
      n & 255
      // low byte is just the last 8 bits
    ]);
    return this;
  }
  writeInt16BE(n) {
    return this.writeUInt16BE(n & 65535);
  }
  writeUInt16LE(n) {
    this.bufs.push([
      n & 255,
      n >> 8 & 255
      // shift right 8 bits to get the high byte
    ]);
    return this;
  }
  writeInt16LE(n) {
    return this.writeUInt16LE(n & 65535);
  }
  writeUInt32BE(n) {
    this.bufs.push([
      n >> 24 & 255,
      n >> 16 & 255,
      n >> 8 & 255,
      n & 255
      // lowest byte
    ]);
    return this;
  }
  writeInt32BE(n) {
    return this.writeUInt32BE(n >>> 0);
  }
  writeUInt32LE(n) {
    this.bufs.push([
      n & 255,
      n >> 8 & 255,
      n >> 16 & 255,
      n >> 24 & 255
      // highest byte
    ]);
    return this;
  }
  writeInt32LE(n) {
    return this.writeUInt32LE(n >>> 0);
  }
  writeUInt64BEBn(bn) {
    const buf = bn.toArray("be", 8);
    this.write(buf);
    return this;
  }
  writeUInt64LEBn(bn) {
    const buf = bn.toArray("be", 8);
    this.writeReverse(buf);
    return this;
  }
  writeUInt64LE(n) {
    const buf = new BigNumber(n).toArray("be", 8);
    this.writeReverse(buf);
    return this;
  }
  writeVarIntNum(n) {
    const buf = _Writer.varIntNum(n);
    this.write(buf);
    return this;
  }
  writeVarIntBn(bn) {
    const buf = _Writer.varIntBn(bn);
    this.write(buf);
    return this;
  }
  static varIntNum(n) {
    let buf;
    if (n < 253) {
      buf = [n];
    } else if (n < 65536) {
      buf = [
        253,
        n & 255,
        n >> 8 & 255
        // high byte
      ];
    } else if (n < 4294967296) {
      buf = [
        254,
        n & 255,
        n >> 8 & 255,
        n >> 16 & 255,
        n >> 24 & 255
      ];
    } else {
      const low = n & 4294967295;
      const high = Math.floor(n / 4294967296) & 4294967295;
      buf = [
        255,
        low & 255,
        low >> 8 & 255,
        low >> 16 & 255,
        low >> 24 & 255,
        high & 255,
        high >> 8 & 255,
        high >> 16 & 255,
        high >> 24 & 255
      ];
    }
    return buf;
  }
  static varIntBn(bn) {
    let buf;
    if (bn.ltn(253)) {
      const n = bn.toNumber();
      buf = [n];
    } else if (bn.ltn(65536)) {
      const n = bn.toNumber();
      buf = [253, n & 255, n >> 8 & 255];
    } else if (bn.lt(new BigNumber(4294967296))) {
      const n = bn.toNumber();
      buf = [254, n & 255, n >> 8 & 255, n >> 16 & 255, n >> 24 & 255];
    } else {
      const bw = new _Writer();
      bw.writeUInt8(255);
      bw.writeUInt64LEBn(bn);
      buf = bw.toArray();
    }
    return buf;
  }
};
var Reader = class {
  constructor(bin = [], pos = 0) {
    __publicField(this, "bin");
    __publicField(this, "pos");
    this.bin = bin;
    this.pos = pos;
  }
  eof() {
    return this.pos >= this.bin.length;
  }
  read(len = this.bin.length) {
    const bin = this.bin.slice(this.pos, this.pos + len);
    this.pos = this.pos + len;
    return bin;
  }
  readReverse(len = this.bin.length) {
    const bin = this.bin.slice(this.pos, this.pos + len);
    this.pos = this.pos + len;
    const buf2 = new Array(bin.length);
    for (let i = 0; i < buf2.length; i++) {
      buf2[i] = bin[bin.length - 1 - i];
    }
    return buf2;
  }
  readUInt8() {
    const val = this.bin[this.pos];
    this.pos += 1;
    return val;
  }
  readInt8() {
    const val = this.bin[this.pos];
    this.pos += 1;
    return (val & 128) !== 0 ? val - 256 : val;
  }
  readUInt16BE() {
    const val = this.bin[this.pos] << 8 | this.bin[this.pos + 1];
    this.pos += 2;
    return val;
  }
  readInt16BE() {
    const val = this.readUInt16BE();
    return (val & 32768) !== 0 ? val - 65536 : val;
  }
  readUInt16LE() {
    const val = this.bin[this.pos] | this.bin[this.pos + 1] << 8;
    this.pos += 2;
    return val;
  }
  readInt16LE() {
    const val = this.readUInt16LE();
    const x = (val & 32768) !== 0 ? val - 65536 : val;
    return x;
  }
  readUInt32BE() {
    const val = this.bin[this.pos] * 16777216 + // Shift the first byte by 24 bits
    (this.bin[this.pos + 1] << 16 | // Shift the second byte by 16 bits
    this.bin[this.pos + 2] << 8 | // Shift the third byte by 8 bits
    this.bin[this.pos + 3]);
    this.pos += 4;
    return val;
  }
  readInt32BE() {
    const val = this.readUInt32BE();
    return (val & 2147483648) !== 0 ? val - 4294967296 : val;
  }
  readUInt32LE() {
    const val = (this.bin[this.pos] | this.bin[this.pos + 1] << 8 | this.bin[this.pos + 2] << 16 | this.bin[this.pos + 3] << 24) >>> 0;
    this.pos += 4;
    return val;
  }
  readInt32LE() {
    const val = this.readUInt32LE();
    return (val & 2147483648) !== 0 ? val - 4294967296 : val;
  }
  readUInt64BEBn() {
    const bin = this.bin.slice(this.pos, this.pos + 8);
    const bn = new BigNumber(bin);
    this.pos = this.pos + 8;
    return bn;
  }
  readUInt64LEBn() {
    const bin = this.readReverse(8);
    const bn = new BigNumber(bin);
    return bn;
  }
  readVarIntNum() {
    const first = this.readUInt8();
    let bn;
    let n;
    switch (first) {
      case 253:
        return this.readUInt16LE();
      case 254:
        return this.readUInt32LE();
      case 255:
        bn = this.readUInt64LEBn();
        if (bn.lte(new BigNumber(2).pow(new BigNumber(53)))) {
          return bn.toNumber();
        } else {
          throw new Error("number too large to retain precision - use readVarIntBn");
        }
      default:
        return first;
    }
  }
  readVarInt() {
    const first = this.bin[this.pos];
    switch (first) {
      case 253:
        return this.read(1 + 2);
      case 254:
        return this.read(1 + 4);
      case 255:
        return this.read(1 + 8);
      default:
        return this.read(1);
    }
  }
  readVarIntBn() {
    const first = this.readUInt8();
    switch (first) {
      case 253:
        return new BigNumber(this.readUInt16LE());
      case 254:
        return new BigNumber(this.readUInt32LE());
      case 255:
        return this.readUInt64LEBn();
      default:
        return new BigNumber(first);
    }
  }
};

// node_modules/@bsv/sdk/dist/esm/src/primitives/Point.js
var Point = class _Point extends BasePoint {
  /**
   * @constructor
   * @param x - The x-coordinate of the point. May be a number, a BigNumber, a string (which will be interpreted as hex), a number array, or null. If null, an "Infinity" point is constructed.
   * @param y - The y-coordinate of the point, similar to x.
   * @param isRed - A boolean indicating if the point is a member of the field of integers modulo the k256 prime. Default is true.
   *
   * @example
   * new Point('abc123', 'def456');
   * new Point(null, null); // Generates Infinity point.
   */
  constructor(x, y, isRed = true) {
    super("affine");
    __publicField(this, "x");
    __publicField(this, "y");
    __publicField(this, "inf");
    this.precomputed = null;
    if (x === null && y === null) {
      this.x = null;
      this.y = null;
      this.inf = true;
    } else {
      if (!BigNumber.isBN(x)) {
        x = new BigNumber(x, 16);
      }
      this.x = x;
      if (!BigNumber.isBN(y)) {
        y = new BigNumber(y, 16);
      }
      this.y = y;
      if (isRed) {
        this.x.forceRed(this.curve.red);
        this.y.forceRed(this.curve.red);
      }
      if (this.x.red === null) {
        this.x = this.x.toRed(this.curve.red);
      }
      if (this.y.red === null) {
        this.y = this.y.toRed(this.curve.red);
      }
      this.inf = false;
    }
  }
  /**
   * Creates a point object from a given string. This string can represent coordinates in hex format, or points
   * in multiple established formats.
   * The function verifies the integrity of the provided data and throws errors if inconsistencies are found.
   *
   * @method fromString
   * @static
   * @param str - The point representation string.
   * @returns Returns a new point representing the given string.
   * @throws `Error` If the point string value has a wrong length.
   * @throws `Error` If the point format is unknown.
   *
   * @example
   * const pointStr = 'abcdef';
   * const point = Point.fromString(pointStr);
   */
  static fromString(str) {
    const bytes = toArray2(str, "hex");
    const len = 32;
    if ((bytes[0] === 4 || bytes[0] === 6 || bytes[0] === 7) && bytes.length - 1 === 2 * len) {
      if (bytes[0] === 6) {
        if (bytes[bytes.length - 1] % 2 !== 0) {
          throw new Error("Point string value is wrong length");
        }
      } else if (bytes[0] === 7) {
        if (bytes[bytes.length - 1] % 2 !== 1) {
          throw new Error("Point string value is wrong length");
        }
      }
      const res = new _Point(bytes.slice(1, 1 + len), bytes.slice(1 + len, 1 + 2 * len));
      return res;
    } else if ((bytes[0] === 2 || bytes[0] === 3) && bytes.length - 1 === len) {
      return _Point.fromX(bytes.slice(1, 1 + len), bytes[0] === 3);
    }
    throw new Error("Unknown point format");
  }
  /**
   * Generates a point from an x coordinate and a boolean indicating whether the corresponding
   * y coordinate is odd.
   *
   * @method fromX
   * @static
   * @param x - The x coordinate of the point.
   * @param odd - Boolean indicating whether the corresponding y coordinate is odd or not.
   * @returns Returns the new point.
   * @throws `Error` If the point is invalid.
   *
   * @example
   * const xCoordinate = new BigNumber('10');
   * const point = Point.fromX(xCoordinate, true);
   */
  static fromX(x, odd) {
    const red = new ReductionContext("k256");
    const a = new BigNumber(0).toRed(red);
    const b = new BigNumber(7).toRed(red);
    const zero = new BigNumber(0).toRed(red);
    if (!BigNumber.isBN(x)) {
      x = new BigNumber(x, 16);
    }
    x = x;
    if (x.red == null) {
      x = x.toRed(red);
    }
    const y2 = x.redSqr().redMul(x).redIAdd(x.redMul(a)).redIAdd(b);
    let y = y2.redSqrt();
    if (y.redSqr().redSub(y2).cmp(zero) !== 0) {
      throw new Error("invalid point");
    }
    const isOdd = y.fromRed().isOdd();
    if (odd && !isOdd || !odd && isOdd) {
      y = y.redNeg();
    }
    return new _Point(x, y);
  }
  /**
   * Generates a point from a serialized JSON object. The function accounts for different options in the JSON object,
   * including precomputed values for optimization of EC operations, and calls another helper function to turn nested
   * JSON points into proper Point objects.
   *
   * @method fromJSON
   * @static
   * @param obj - An object or array that holds the data for the point.
   * @param isRed - A boolean to direct how the Point is constructed from the JSON object.
   * @returns Returns a new point based on the deserialized JSON object.
   *
   * @example
   * const serializedPoint = '{"x":52,"y":15}';
   * const point = Point.fromJSON(serializedPoint, true);
   */
  static fromJSON(obj, isRed) {
    if (typeof obj === "string") {
      obj = JSON.parse(obj);
    }
    const res = new _Point(obj[0], obj[1], isRed);
    if (typeof obj[2] !== "object") {
      return res;
    }
    const obj2point = (obj2) => {
      return new _Point(obj2[0], obj2[1], isRed);
    };
    const pre = obj[2];
    res.precomputed = {
      beta: null,
      doubles: typeof pre.doubles === "object" && pre.doubles !== null ? {
        step: pre.doubles.step,
        points: [res].concat(pre.doubles.points.map(obj2point))
      } : void 0,
      naf: typeof pre.naf === "object" && pre.naf !== null ? {
        wnd: pre.naf.wnd,
        points: [res].concat(pre.naf.points.map(obj2point))
      } : void 0
    };
    return res;
  }
  /**
   * Validates if a point belongs to the curve. Follows the short Weierstrass
   * equation for elliptic curves: y^2 = x^3 + ax + b.
   *
   * @method validate
   * @returns {boolean} true if the point is on the curve, false otherwise.
   *
   * @example
   * const aPoint = new Point(x, y);
   * const isValid = aPoint.validate();
   */
  validate() {
    return this.curve.validate(this);
  }
  /**
   * Encodes the coordinates of a point into an array or a hexadecimal string.
   * The details of encoding are determined by the optional compact and enc parameters.
   *
   * @method encode
   * @param compact - If true, an additional prefix byte 0x02 or 0x03 based on the 'y' coordinate being even or odd respectively is used. If false, byte 0x04 is used.
   * @param enc - Expects the string 'hex' if hexadecimal string encoding is required instead of an array of numbers.
   * @throws Will throw an error if the specified encoding method is not recognized. Expects 'hex'.
   * @returns If enc is undefined, a byte array representation of the point will be returned. if enc is 'hex', a hexadecimal string representation of the point will be returned.
   *
   * @example
   * const aPoint = new Point(x, y);
   * const encodedPointArray = aPoint.encode();
   * const encodedPointHex = aPoint.encode(true, 'hex');
   */
  encode(compact = true, enc) {
    const len = this.curve.p.byteLength();
    const x = this.getX().toArray("be", len);
    let res;
    if (compact) {
      res = [this.getY().isEven() ? 2 : 3].concat(x);
    } else {
      res = [4].concat(x, this.getY().toArray("be", len));
    }
    if (enc !== "hex") {
      return res;
    } else {
      return toHex(res);
    }
  }
  /**
   * Converts the point coordinates to a hexadecimal string. A wrapper method
   * for encode. Byte 0x02 or 0x03 is used as prefix based on the 'y' coordinate being even or odd respectively.
   *
   * @method toString
   * @returns {string} A hexadecimal string representation of the point coordinates.
   *
   * @example
   * const aPoint = new Point(x, y);
   * const stringPoint = aPoint.toString();
   */
  toString() {
    return this.encode(true, "hex");
  }
  /**
   * Exports the x and y coordinates of the point, and the precomputed doubles and non-adjacent form (NAF) for optimization. The output is an array.
   *
   * @method toJSON
   * @returns An Array where first two elements are the coordinates of the point and optional third element is an object with doubles and NAF points.
   *
   * @example
   * const aPoint = new Point(x, y);
   * const jsonPoint = aPoint.toJSON();
   */
  toJSON() {
    if (this.precomputed == null) {
      return [this.x, this.y];
    }
    return [this.x, this.y, typeof this.precomputed === "object" && this.precomputed !== null ? {
      doubles: this.precomputed.doubles != null ? {
        step: this.precomputed.doubles.step,
        points: this.precomputed.doubles.points.slice(1)
      } : void 0,
      naf: this.precomputed.naf != null ? {
        wnd: this.precomputed.naf.wnd,
        points: this.precomputed.naf.points.slice(1)
      } : void 0
    } : void 0];
  }
  /**
   * Provides the point coordinates in a human-readable string format for debugging purposes.
   *
   * @method inspect
   * @returns String of the format '<EC Point x: x-coordinate y: y-coordinate>', or '<EC Point Infinity>' if the point is at infinity.
   *
   * @example
   * const aPoint = new Point(x, y);
   * console.log(aPoint.inspect());
   */
  inspect() {
    if (this.isInfinity()) {
      return "<EC Point Infinity>";
    }
    return "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + ">";
  }
  /**
   * Checks if the point is at infinity.
   * @method isInfinity
   * @returns Returns whether or not the point is at infinity.
   *
   * @example
   * const p = new Point(null, null);
   * console.log(p.isInfinity()); // outputs: true
   */
  isInfinity() {
    return this.inf;
  }
  /**
   * Adds another Point to this Point, returning a new Point.
   *
   * @method add
   * @param p - The Point to add to this one.
   * @returns A new Point that results from the addition.
   *
   * @example
   * const p1 = new Point(1, 2);
   * const p2 = new Point(2, 3);
   * const result = p1.add(p2);
   */
  add(p) {
    if (this.inf) {
      return p;
    }
    if (p.inf) {
      return this;
    }
    if (this.eq(p)) {
      return this.dbl();
    }
    if (this.neg().eq(p)) {
      return new _Point(null, null);
    }
    if (this.x.cmp(p.x) === 0) {
      return new _Point(null, null);
    }
    let c = this.y.redSub(p.y);
    if (c.cmpn(0) !== 0) {
      c = c.redMul(this.x.redSub(p.x).redInvm());
    }
    const nx = c.redSqr().redISub(this.x).redISub(p.x);
    const ny = c.redMul(this.x.redSub(nx)).redISub(this.y);
    return new _Point(nx, ny);
  }
  /**
   * Doubles the current point.
   *
   * @method dbl
   *
   * @example
   * const P = new Point('123', '456');
   * const result = P.dbl();
   * */
  dbl() {
    if (this.inf) {
      return this;
    }
    const ys1 = this.y.redAdd(this.y);
    if (ys1.cmpn(0) === 0) {
      return new _Point(null, null);
    }
    const a = this.curve.a;
    const x2 = this.x.redSqr();
    const dyinv = ys1.redInvm();
    const c = x2.redAdd(x2).redIAdd(x2).redIAdd(a).redMul(dyinv);
    const nx = c.redSqr().redISub(this.x.redAdd(this.x));
    const ny = c.redMul(this.x.redSub(nx)).redISub(this.y);
    return new _Point(nx, ny);
  }
  /**
   * Returns X coordinate of point
   *
   * @example
   * const P = new Point('123', '456');
   * const x = P.getX();
   */
  getX() {
    return this.x.fromRed();
  }
  /**
   * Returns X coordinate of point
   *
   * @example
   * const P = new Point('123', '456');
   * const x = P.getX();
   */
  getY() {
    return this.y.fromRed();
  }
  /**
   * Multiplies this Point by a scalar value, returning a new Point.
   *
   * @method mul
   * @param k - The scalar value to multiply this Point by.
   * @returns  A new Point that results from the multiplication.
   *
   * @example
   * const p = new Point(1, 2);
   * const result = p.mul(2); // this doubles the Point
   */
  mul(k) {
    if (!BigNumber.isBN(k)) {
      k = new BigNumber(k, 16);
    }
    k = k;
    if (this.isInfinity()) {
      return this;
    } else if (this._hasDoubles(k)) {
      return this._fixedNafMul(k);
    } else {
      return this._endoWnafMulAdd([this], [k]);
    }
  }
  /**
   * Performs a multiplication and addition operation in a single step.
   * Multiplies this Point by k1, adds the resulting Point to the result of p2 multiplied by k2.
   *
   * @method mulAdd
   * @param k1 - The scalar value to multiply this Point by.
   * @param p2 - The other Point to be involved in the operation.
   * @param k2 - The scalar value to multiply the Point p2 by.
   * @returns A Point that results from the combined multiplication and addition operations.
   *
   * @example
   * const p1 = new Point(1, 2);
   * const p2 = new Point(2, 3);
   * const result = p1.mulAdd(2, p2, 3);
   */
  mulAdd(k1, p2, k2) {
    const points = [this, p2];
    const coeffs = [k1, k2];
    return this._endoWnafMulAdd(points, coeffs);
  }
  /**
   * Performs the Jacobian multiplication and addition operation in a single
   * step. Instead of returning a regular Point, the result is a JacobianPoint.
   *
   * @method jmulAdd
   * @param k1 - The scalar value to multiply this Point by.
   * @param p2 - The other Point to be involved in the operation
   * @param k2 - The scalar value to multiply the Point p2 by.
   * @returns A JacobianPoint that results from the combined multiplication and addition operation.
   *
   * @example
   * const p1 = new Point(1, 2);
   * const p2 = new Point(2, 3);
   * const result = p1.jmulAdd(2, p2, 3);
   */
  jmulAdd(k1, p2, k2) {
    const points = [this, p2];
    const coeffs = [k1, k2];
    return this._endoWnafMulAdd(points, coeffs, true);
  }
  /**
   * Checks if the Point instance is equal to another given Point.
   *
   * @method eq
   * @param p - The Point to be checked if equal to the current instance.
   *
   * @returns Whether the two Point instances are equal. Both the 'x' and 'y' coordinates have to match, and both points have to either be valid or at infinity for equality. If both conditions are true, it returns true, else it returns false.
   *
   * @example
   * const p1 = new Point(5, 20);
   * const p2 = new Point(5, 20);
   * const areEqual = p1.eq(p2); // returns true
   */
  eq(p) {
    return this === p || this.inf === p.inf && (this.inf || this.x.cmp(p.x) === 0 && this.y.cmp(p.y) === 0);
  }
  /**
   * Negate a point. The negation of a point P is the mirror of P about x-axis.
   *
   * @method neg
   *
   * @example
   * const P = new Point('123', '456');
   * const result = P.neg();
   */
  neg(_precompute) {
    if (this.inf) {
      return this;
    }
    const res = new _Point(this.x, this.y.redNeg());
    if (_precompute && this.precomputed != null) {
      const pre = this.precomputed;
      const negate = (p) => p.neg();
      res.precomputed = {
        naf: pre.naf != null && {
          wnd: pre.naf.wnd,
          points: pre.naf.points.map(negate)
        },
        doubles: pre.doubles != null && {
          step: pre.doubles.step,
          points: pre.doubles.points.map((p) => p.neg())
        },
        beta: void 0
      };
    }
    return res;
  }
  /**
   * Performs the "doubling" operation on the Point a given number of times.
   * This is used in elliptic curve operations to perform multiplication by 2, multiple times.
   * If the point is at infinity, it simply returns the point because doubling
   * a point at infinity is still infinity.
   *
   * @method dblp
   * @param k - The number of times the "doubling" operation is to be performed on the Point.
   * @returns The Point after 'k' "doubling" operations have been performed.
   *
   * @example
   * const p = new Point(5, 20);
   * const doubledPoint = p.dblp(10); // returns the point after "doubled" 10 times
   */
  dblp(k) {
    let r2 = this;
    for (let i = 0; i < k; i++) {
      r2 = r2.dbl();
    }
    return r2;
  }
  /**
   * Converts the point to a Jacobian point. If the point is at infinity, the corresponding Jacobian point
   * will also be at infinity.
   *
   * @method toJ
   * @returns Returns a new Jacobian point based on the current point.
   *
   * @example
   * const point = new Point(xCoordinate, yCoordinate);
   * const jacobianPoint = point.toJ();
   */
  toJ() {
    if (this.inf) {
      return new JacobianPoint(null, null, null);
    }
    const res = new JacobianPoint(this.x, this.y, this.curve.one);
    return res;
  }
  _getBeta() {
    if (typeof this.curve.endo !== "object") {
      return;
    }
    const pre = this.precomputed;
    if (typeof pre === "object" && pre !== null && typeof pre.beta === "object" && pre.beta !== null) {
      return pre.beta;
    }
    const beta = new _Point(this.x.redMul(this.curve.endo.beta), this.y);
    if (pre != null) {
      const curve = this.curve;
      const endoMul = (p) => {
        return new _Point(p.x.redMul(curve.endo.beta), p.y);
      };
      pre.beta = beta;
      beta.precomputed = {
        beta: null,
        naf: pre.naf != null ? {
          wnd: pre.naf.wnd,
          points: pre.naf.points.map(endoMul)
        } : void 0,
        doubles: pre.doubles != null ? {
          step: pre.doubles.step,
          points: pre.doubles.points.map(endoMul)
        } : void 0
      };
    }
    return beta;
  }
  _fixedNafMul(k) {
    if (typeof this.precomputed !== "object" || this.precomputed === null) {
      throw new Error("_fixedNafMul requires precomputed values for the point");
    }
    const doubles = this._getDoubles();
    const naf = this.curve.getNAF(k, 1, this.curve._bitLength);
    let I = (1 << doubles.step + 1) - (doubles.step % 2 === 0 ? 2 : 1);
    I /= 3;
    const repr = [];
    for (let j = 0; j < naf.length; j += doubles.step) {
      let nafW = 0;
      for (let k2 = j + doubles.step - 1; k2 >= j; k2--) {
        nafW = (nafW << 1) + naf[k2];
      }
      repr.push(nafW);
    }
    let a = new JacobianPoint(null, null, null);
    let b = new JacobianPoint(null, null, null);
    for (let i = I; i > 0; i--) {
      for (let j = 0; j < repr.length; j++) {
        const nafW = repr[j];
        if (nafW === i) {
          b = b.mixedAdd(doubles.points[j]);
        } else if (nafW === -i) {
          b = b.mixedAdd(doubles.points[j].neg());
        }
      }
      a = a.add(b);
    }
    return a.toP();
  }
  _wnafMulAdd(defW, points, coeffs, len, jacobianResult) {
    const wndWidth = this.curve._wnafT1;
    const wnd = this.curve._wnafT2;
    const naf = this.curve._wnafT3;
    let max = 0;
    for (let i = 0; i < len; i++) {
      const p = points[i];
      const nafPoints = p._getNAFPoints(defW);
      wndWidth[i] = nafPoints.wnd;
      wnd[i] = nafPoints.points;
    }
    for (let i = len - 1; i >= 1; i -= 2) {
      const a = i - 1;
      const b = i;
      if (wndWidth[a] !== 1 || wndWidth[b] !== 1) {
        naf[a] = this.curve.getNAF(coeffs[a], wndWidth[a], this.curve._bitLength);
        naf[b] = this.curve.getNAF(coeffs[b], wndWidth[b], this.curve._bitLength);
        max = Math.max(naf[a].length, max);
        max = Math.max(naf[b].length, max);
        continue;
      }
      const comb = [
        points[a],
        null,
        null,
        points[b]
        /* 7 */
      ];
      if (points[a].y.cmp(points[b].y) === 0) {
        comb[1] = points[a].add(points[b]);
        comb[2] = points[a].toJ().mixedAdd(points[b].neg());
      } else if (points[a].y.cmp(points[b].y.redNeg()) === 0) {
        comb[1] = points[a].toJ().mixedAdd(points[b]);
        comb[2] = points[a].add(points[b].neg());
      } else {
        comb[1] = points[a].toJ().mixedAdd(points[b]);
        comb[2] = points[a].toJ().mixedAdd(points[b].neg());
      }
      const index = [
        -3,
        -1,
        -5,
        -7,
        0,
        7,
        5,
        1,
        3
        /* 1 1 */
      ];
      const jsf = this.curve.getJSF(coeffs[a], coeffs[b]);
      max = Math.max(jsf[0].length, max);
      naf[a] = new Array(max);
      naf[b] = new Array(max);
      for (let j = 0; j < max; j++) {
        const ja = jsf[0][j] | 0;
        const jb = jsf[1][j] | 0;
        naf[a][j] = index[(ja + 1) * 3 + (jb + 1)];
        naf[b][j] = 0;
        wnd[a] = comb;
      }
    }
    let acc = new JacobianPoint(null, null, null);
    const tmp = this.curve._wnafT4;
    for (let i = max; i >= 0; i--) {
      let k = 0;
      while (i >= 0) {
        let zero = true;
        for (let j = 0; j < len; j++) {
          tmp[j] = naf[j][i] | 0;
          if (tmp[j] !== 0) {
            zero = false;
          }
        }
        if (!zero) {
          break;
        }
        k++;
        i--;
      }
      if (i >= 0) {
        k++;
      }
      acc = acc.dblp(k);
      if (i < 0) {
        break;
      }
      for (let j = 0; j < len; j++) {
        const z = tmp[j];
        let p;
        if (z === 0) {
          continue;
        } else if (z > 0) {
          p = wnd[j][z - 1 >> 1];
        } else if (z < 0) {
          p = wnd[j][-z - 1 >> 1].neg();
        }
        if (p.type === "affine") {
          acc = acc.mixedAdd(p);
        } else {
          acc = acc.add(p);
        }
      }
    }
    for (let i = 0; i < len; i++) {
      wnd[i] = null;
    }
    if (jacobianResult) {
      return acc;
    } else {
      return acc.toP();
    }
  }
  _endoWnafMulAdd(points, coeffs, jacobianResult) {
    const npoints = this.curve._endoWnafT1;
    const ncoeffs = this.curve._endoWnafT2;
    let i;
    for (i = 0; i < points.length; i++) {
      const split = this.curve._endoSplit(coeffs[i]);
      let p = points[i];
      let beta = p._getBeta();
      if (split.k1.negative !== 0) {
        split.k1.ineg();
        p = p.neg(true);
      }
      if (split.k2.negative !== 0) {
        split.k2.ineg();
        beta = beta.neg(true);
      }
      npoints[i * 2] = p;
      npoints[i * 2 + 1] = beta;
      ncoeffs[i * 2] = split.k1;
      ncoeffs[i * 2 + 1] = split.k2;
    }
    const res = this._wnafMulAdd(1, npoints, ncoeffs, i * 2, jacobianResult);
    for (let j = 0; j < i * 2; j++) {
      npoints[j] = null;
      ncoeffs[j] = null;
    }
    return res;
  }
  _hasDoubles(k) {
    if (this.precomputed == null) {
      return false;
    }
    const doubles = this.precomputed.doubles;
    if (typeof doubles !== "object") {
      return false;
    }
    return doubles.points.length >= Math.ceil((k.bitLength() + 1) / doubles.step);
  }
  _getDoubles(step, power) {
    if (typeof this.precomputed === "object" && this.precomputed !== null && typeof this.precomputed.doubles === "object" && this.precomputed.doubles !== null) {
      return this.precomputed.doubles;
    }
    const doubles = [this];
    let acc = this;
    for (let i = 0; i < power; i += step) {
      for (let j = 0; j < step; j++) {
        acc = acc.dbl();
      }
      doubles.push(acc);
    }
    return {
      step,
      points: doubles
    };
  }
  _getNAFPoints(wnd) {
    if (typeof this.precomputed === "object" && this.precomputed !== null && typeof this.precomputed.naf === "object" && this.precomputed.naf !== null) {
      return this.precomputed.naf;
    }
    const res = [this];
    const max = (1 << wnd) - 1;
    const dbl = max === 1 ? null : this.dbl();
    for (let i = 1; i < max; i++) {
      res[i] = res[i - 1].add(dbl);
    }
    return {
      wnd,
      points: res
    };
  }
};

// node_modules/@bsv/sdk/dist/esm/src/primitives/Curve.js
var globalCurve;
var Curve = class _Curve {
  constructor() {
    __publicField(this, "p");
    __publicField(this, "red");
    __publicField(this, "redN");
    __publicField(this, "zero");
    __publicField(this, "one");
    __publicField(this, "two");
    __publicField(this, "g");
    __publicField(this, "n");
    __publicField(this, "a");
    __publicField(this, "b");
    __publicField(this, "tinv");
    __publicField(this, "zeroA");
    __publicField(this, "threeA");
    __publicField(this, "endo");
    // beta, lambda, basis
    __publicField(this, "_endoWnafT1");
    __publicField(this, "_endoWnafT2");
    __publicField(this, "_wnafT1");
    __publicField(this, "_wnafT2");
    __publicField(this, "_wnafT3");
    __publicField(this, "_wnafT4");
    __publicField(this, "_bitLength");
    const precomputed = {
      doubles: {
        step: 4,
        points: [
          [
            "e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a",
            "f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821"
          ],
          [
            "8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508",
            "11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf"
          ],
          [
            "175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739",
            "d3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695"
          ],
          [
            "363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640",
            "4e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9"
          ],
          [
            "8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c",
            "4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36"
          ],
          [
            "723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda",
            "96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f"
          ],
          [
            "eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa",
            "5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999"
          ],
          [
            "100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0",
            "cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09"
          ],
          [
            "e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d",
            "9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d"
          ],
          [
            "feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d",
            "e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088"
          ],
          [
            "da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1",
            "9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d"
          ],
          [
            "53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0",
            "5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8"
          ],
          [
            "8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047",
            "10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a"
          ],
          [
            "385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862",
            "283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453"
          ],
          [
            "6f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7",
            "7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160"
          ],
          [
            "3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd",
            "56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0"
          ],
          [
            "85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83",
            "7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6"
          ],
          [
            "948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a",
            "53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589"
          ],
          [
            "6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8",
            "bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17"
          ],
          [
            "e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d",
            "4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda"
          ],
          [
            "e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725",
            "7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd"
          ],
          [
            "213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754",
            "4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2"
          ],
          [
            "4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c",
            "17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6"
          ],
          [
            "fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6",
            "6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f"
          ],
          [
            "76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39",
            "c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01"
          ],
          [
            "c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891",
            "893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3"
          ],
          [
            "d895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b",
            "febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f"
          ],
          [
            "b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03",
            "2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7"
          ],
          [
            "e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d",
            "eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78"
          ],
          [
            "a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070",
            "7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1"
          ],
          [
            "90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4",
            "e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150"
          ],
          [
            "8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da",
            "662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82"
          ],
          [
            "e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11",
            "1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc"
          ],
          [
            "8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e",
            "efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b"
          ],
          [
            "e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41",
            "2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51"
          ],
          [
            "b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef",
            "67c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45"
          ],
          [
            "d68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8",
            "db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120"
          ],
          [
            "324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d",
            "648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84"
          ],
          [
            "4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96",
            "35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d"
          ],
          [
            "9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd",
            "ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d"
          ],
          [
            "6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5",
            "9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8"
          ],
          [
            "a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266",
            "40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8"
          ],
          [
            "7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71",
            "34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac"
          ],
          [
            "928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac",
            "c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f"
          ],
          [
            "85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751",
            "1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962"
          ],
          [
            "ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e",
            "493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907"
          ],
          [
            "827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241",
            "c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec"
          ],
          [
            "eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3",
            "be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d"
          ],
          [
            "e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f",
            "4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414"
          ],
          [
            "1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19",
            "aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd"
          ],
          [
            "146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be",
            "b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0"
          ],
          [
            "fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9",
            "6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811"
          ],
          [
            "da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2",
            "8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1"
          ],
          [
            "a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13",
            "7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c"
          ],
          [
            "174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c",
            "ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73"
          ],
          [
            "959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba",
            "2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd"
          ],
          [
            "d2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151",
            "e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405"
          ],
          [
            "64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073",
            "d99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589"
          ],
          [
            "8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458",
            "38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e"
          ],
          [
            "13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b",
            "69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27"
          ],
          [
            "bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366",
            "d3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1"
          ],
          [
            "8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa",
            "40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482"
          ],
          [
            "8ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0",
            "620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945"
          ],
          [
            "dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787",
            "7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573"
          ],
          [
            "f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e",
            "ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82"
          ]
        ]
      },
      naf: {
        wnd: 7,
        points: [
          [
            "f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9",
            "388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672"
          ],
          [
            "2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4",
            "d8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6"
          ],
          [
            "5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc",
            "6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da"
          ],
          [
            "acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe",
            "cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37"
          ],
          [
            "774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb",
            "d984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b"
          ],
          [
            "f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8",
            "ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81"
          ],
          [
            "d7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e",
            "581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58"
          ],
          [
            "defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34",
            "4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77"
          ],
          [
            "2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c",
            "85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a"
          ],
          [
            "352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5",
            "321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c"
          ],
          [
            "2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f",
            "2de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67"
          ],
          [
            "9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714",
            "73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402"
          ],
          [
            "daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729",
            "a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55"
          ],
          [
            "c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db",
            "2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482"
          ],
          [
            "6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4",
            "e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82"
          ],
          [
            "1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5",
            "b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396"
          ],
          [
            "605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479",
            "2972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49"
          ],
          [
            "62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d",
            "80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf"
          ],
          [
            "80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f",
            "1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a"
          ],
          [
            "7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb",
            "d0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7"
          ],
          [
            "d528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9",
            "eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933"
          ],
          [
            "49370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963",
            "758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a"
          ],
          [
            "77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74",
            "958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6"
          ],
          [
            "f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530",
            "e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37"
          ],
          [
            "463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b",
            "5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e"
          ],
          [
            "f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247",
            "cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6"
          ],
          [
            "caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1",
            "cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476"
          ],
          [
            "2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120",
            "4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40"
          ],
          [
            "7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435",
            "91b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61"
          ],
          [
            "754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18",
            "673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683"
          ],
          [
            "e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8",
            "59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5"
          ],
          [
            "186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb",
            "3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b"
          ],
          [
            "df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f",
            "55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417"
          ],
          [
            "5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143",
            "efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868"
          ],
          [
            "290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba",
            "e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a"
          ],
          [
            "af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45",
            "f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6"
          ],
          [
            "766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a",
            "744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996"
          ],
          [
            "59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e",
            "c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e"
          ],
          [
            "f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8",
            "e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d"
          ],
          [
            "7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c",
            "30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2"
          ],
          [
            "948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519",
            "e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e"
          ],
          [
            "7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab",
            "100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437"
          ],
          [
            "3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca",
            "ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311"
          ],
          [
            "d3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf",
            "8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4"
          ],
          [
            "1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610",
            "68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575"
          ],
          [
            "733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4",
            "f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d"
          ],
          [
            "15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c",
            "d56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d"
          ],
          [
            "a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940",
            "edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629"
          ],
          [
            "e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980",
            "a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06"
          ],
          [
            "311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3",
            "66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374"
          ],
          [
            "34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf",
            "9414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee"
          ],
          [
            "f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63",
            "4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1"
          ],
          [
            "d7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448",
            "fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b"
          ],
          [
            "32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf",
            "5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661"
          ],
          [
            "7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5",
            "8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6"
          ],
          [
            "ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6",
            "8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e"
          ],
          [
            "16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5",
            "5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d"
          ],
          [
            "eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99",
            "f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc"
          ],
          [
            "78c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51",
            "f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4"
          ],
          [
            "494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5",
            "42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c"
          ],
          [
            "a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5",
            "204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b"
          ],
          [
            "c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997",
            "4f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913"
          ],
          [
            "841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881",
            "73867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154"
          ],
          [
            "5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5",
            "39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865"
          ],
          [
            "36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66",
            "d2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc"
          ],
          [
            "336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726",
            "ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224"
          ],
          [
            "8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede",
            "6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e"
          ],
          [
            "1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94",
            "60660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6"
          ],
          [
            "85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31",
            "3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511"
          ],
          [
            "29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51",
            "b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b"
          ],
          [
            "a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252",
            "ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2"
          ],
          [
            "4e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5",
            "cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c"
          ],
          [
            "d24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b",
            "6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3"
          ],
          [
            "ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4",
            "322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d"
          ],
          [
            "af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f",
            "6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700"
          ],
          [
            "e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889",
            "2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4"
          ],
          [
            "591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246",
            "b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196"
          ],
          [
            "11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984",
            "998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4"
          ],
          [
            "3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a",
            "b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257"
          ],
          [
            "cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030",
            "bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13"
          ],
          [
            "c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197",
            "6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096"
          ],
          [
            "c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593",
            "c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38"
          ],
          [
            "a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef",
            "21ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f"
          ],
          [
            "347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38",
            "60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448"
          ],
          [
            "da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a",
            "49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a"
          ],
          [
            "c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111",
            "5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4"
          ],
          [
            "4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502",
            "7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437"
          ],
          [
            "3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea",
            "be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7"
          ],
          [
            "cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26",
            "8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d"
          ],
          [
            "b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986",
            "39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a"
          ],
          [
            "d4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e",
            "62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54"
          ],
          [
            "48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4",
            "25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77"
          ],
          [
            "dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda",
            "ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517"
          ],
          [
            "6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859",
            "cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10"
          ],
          [
            "e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f",
            "f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125"
          ],
          [
            "eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c",
            "6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e"
          ],
          [
            "13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942",
            "fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1"
          ],
          [
            "ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a",
            "1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2"
          ],
          [
            "b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80",
            "5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423"
          ],
          [
            "ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d",
            "438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8"
          ],
          [
            "8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1",
            "cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758"
          ],
          [
            "52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63",
            "c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375"
          ],
          [
            "e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352",
            "6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d"
          ],
          [
            "7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193",
            "ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec"
          ],
          [
            "5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00",
            "9731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0"
          ],
          [
            "32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58",
            "ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c"
          ],
          [
            "e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7",
            "d3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4"
          ],
          [
            "8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8",
            "c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f"
          ],
          [
            "4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e",
            "67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649"
          ],
          [
            "3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d",
            "cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826"
          ],
          [
            "674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b",
            "299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5"
          ],
          [
            "d32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f",
            "f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87"
          ],
          [
            "30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6",
            "462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b"
          ],
          [
            "be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297",
            "62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc"
          ],
          [
            "93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a",
            "7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c"
          ],
          [
            "b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c",
            "ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f"
          ],
          [
            "d5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52",
            "4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a"
          ],
          [
            "d3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb",
            "bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46"
          ],
          [
            "463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065",
            "bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f"
          ],
          [
            "7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917",
            "603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03"
          ],
          [
            "74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9",
            "cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08"
          ],
          [
            "30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3",
            "553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8"
          ],
          [
            "9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57",
            "712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373"
          ],
          [
            "176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66",
            "ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3"
          ],
          [
            "75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8",
            "9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8"
          ],
          [
            "809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721",
            "9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1"
          ],
          [
            "1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180",
            "4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9"
          ]
        ]
      }
    };
    if (typeof globalCurve !== "undefined") {
      return globalCurve;
    } else {
      globalCurve = this;
    }
    const conf = {
      prime: "k256",
      p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f",
      a: "0",
      b: "7",
      n: "ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141",
      h: "1",
      // Precomputed endomorphism
      beta: "7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee",
      lambda: "5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72",
      basis: [
        {
          a: "3086d221a7d46bcde86c90e49284eb15",
          b: "-e4437ed6010e88286f547fa90abfe4c3"
        },
        {
          a: "114ca50f7a8e2f3f657c1108d9d44cfd8",
          b: "3086d221a7d46bcde86c90e49284eb15"
        }
      ],
      gRed: false,
      g: [
        "79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798",
        "483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8",
        precomputed
      ]
    };
    this.p = new BigNumber(conf.p, 16);
    this.red = new ReductionContext(conf.prime);
    this.zero = new BigNumber(0).toRed(this.red);
    this.one = new BigNumber(1).toRed(this.red);
    this.two = new BigNumber(2).toRed(this.red);
    this.n = new BigNumber(conf.n, 16);
    this.g = Point.fromJSON(conf.g, conf.gRed);
    this._wnafT1 = new Array(4);
    this._wnafT2 = new Array(4);
    this._wnafT3 = new Array(4);
    this._wnafT4 = new Array(4);
    this._bitLength = this.n.bitLength();
    this.redN = this.n.toRed(this.red);
    this.a = new BigNumber(conf.a, 16).toRed(this.red);
    this.b = new BigNumber(conf.b, 16).toRed(this.red);
    this.tinv = this.two.redInvm();
    this.zeroA = this.a.fromRed().cmpn(0) === 0;
    this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0;
    this.endo = this._getEndomorphism(conf);
    this._endoWnafT1 = new Array(4);
    this._endoWnafT2 = new Array(4);
  }
  // Represent num in a w-NAF form
  static assert(expression, message = "Elliptic curve assertion failed") {
    if (!expression) {
      throw new Error(message);
    }
  }
  getNAF(num, w, bits) {
    const naf = new Array(Math.max(num.bitLength(), bits) + 1);
    naf.fill(0);
    const ws = 1 << w + 1;
    const k = num.clone();
    for (let i = 0; i < naf.length; i++) {
      let z;
      const mod = k.andln(ws - 1);
      if (k.isOdd()) {
        if (mod > (ws >> 1) - 1) {
          z = (ws >> 1) - mod;
        } else {
          z = mod;
        }
        k.isubn(z);
      } else {
        z = 0;
      }
      naf[i] = z;
      k.iushrn(1);
    }
    return naf;
  }
  // Represent k1, k2 in a Joint Sparse Form
  getJSF(k1, k2) {
    const jsf = [
      [],
      []
    ];
    k1 = k1.clone();
    k2 = k2.clone();
    let d1 = 0;
    let d2 = 0;
    while (k1.cmpn(-d1) > 0 || k2.cmpn(-d2) > 0) {
      let m14 = k1.andln(3) + d1 & 3;
      let m24 = k2.andln(3) + d2 & 3;
      if (m14 === 3) {
        m14 = -1;
      }
      if (m24 === 3) {
        m24 = -1;
      }
      let u1;
      if ((m14 & 1) === 0) {
        u1 = 0;
      } else {
        const m8 = k1.andln(7) + d1 & 7;
        if ((m8 === 3 || m8 === 5) && m24 === 2) {
          u1 = -m14;
        } else {
          u1 = m14;
        }
      }
      jsf[0].push(u1);
      let u2;
      if ((m24 & 1) === 0) {
        u2 = 0;
      } else {
        const m8 = k2.andln(7) + d2 & 7;
        if ((m8 === 3 || m8 === 5) && m14 === 2) {
          u2 = -m24;
        } else {
          u2 = m24;
        }
      }
      jsf[1].push(u2);
      if (2 * d1 === u1 + 1) {
        d1 = 1 - d1;
      }
      if (2 * d2 === u2 + 1) {
        d2 = 1 - d2;
      }
      k1.iushrn(1);
      k2.iushrn(1);
    }
    return jsf;
  }
  static cachedProperty(obj, name, computer) {
    const key = "_" + name;
    obj.prototype[name] = function cachedProperty() {
      const r2 = this[key] !== void 0 ? this[key] : this[key] = computer.call(this);
      return r2;
    };
  }
  static parseBytes(bytes) {
    return typeof bytes === "string" ? toArray2(bytes, "hex") : bytes;
  }
  static intFromLE(bytes) {
    return new BigNumber(bytes, "hex", "le");
  }
  _getEndomorphism(conf) {
    if (!this.zeroA || this.p.modrn(3) !== 1) {
      return;
    }
    let beta;
    let lambda;
    if (conf.beta !== void 0) {
      beta = new BigNumber(conf.beta, 16).toRed(this.red);
    } else {
      const betas = this._getEndoRoots(this.p);
      beta = betas[0].cmp(betas[1]) < 0 ? betas[0] : betas[1];
      beta = beta.toRed(this.red);
    }
    if (conf.lambda !== void 0) {
      lambda = new BigNumber(conf.lambda, 16);
    } else {
      const lambdas = this._getEndoRoots(this.n);
      if (this.g.mul(lambdas[0]).x.cmp(this.g.x.redMul(beta)) === 0) {
        lambda = lambdas[0];
      } else {
        lambda = lambdas[1];
        _Curve.assert(this.g.mul(lambda).x.cmp(this.g.x.redMul(beta)) === 0);
      }
    }
    let basis;
    if (typeof conf.basis === "object" && conf.basis !== null) {
      basis = conf.basis.map(function(vec) {
        return {
          a: new BigNumber(vec.a, 16),
          b: new BigNumber(vec.b, 16)
        };
      });
    } else {
      basis = this._getEndoBasis(lambda);
    }
    return {
      beta,
      lambda,
      basis
    };
  }
  _getEndoRoots(num) {
    const red = num === this.p ? this.red : new MontgomoryMethod(num);
    const tinv = new BigNumber(2).toRed(red).redInvm();
    const ntinv = tinv.redNeg();
    const s2 = new BigNumber(3).toRed(red).redNeg().redSqrt().redMul(tinv);
    const l1 = ntinv.redAdd(s2).fromRed();
    const l2 = ntinv.redSub(s2).fromRed();
    return [l1, l2];
  }
  _getEndoBasis(lambda) {
    const aprxSqrt = this.n.ushrn(Math.floor(this.n.bitLength() / 2));
    let u = lambda;
    let v = this.n.clone();
    let x1 = new BigNumber(1);
    let y1 = new BigNumber(0);
    let x2 = new BigNumber(0);
    let y2 = new BigNumber(1);
    let a0;
    let b0;
    let a1;
    let b1;
    let a2;
    let b2;
    let prevR;
    let i = 0;
    let r2;
    let x;
    while (u.cmpn(0) !== 0) {
      const q = v.div(u);
      r2 = v.sub(q.mul(u));
      x = x2.sub(q.mul(x1));
      const y = y2.sub(q.mul(y1));
      if (typeof a1 !== "object" && r2.cmp(aprxSqrt) < 0) {
        a0 = prevR.neg();
        b0 = x1;
        a1 = r2.neg();
        b1 = x;
      } else if (typeof a1 === "object" && ++i === 2) {
        break;
      }
      prevR = r2;
      v = u;
      u = r2;
      x2 = x1;
      x1 = x;
      y2 = y1;
      y1 = y;
    }
    a2 = r2.neg();
    b2 = x;
    const len1 = a1.sqr().add(b1.sqr());
    const len2 = a2.sqr().add(b2.sqr());
    if (len2.cmp(len1) >= 0) {
      a2 = a0;
      b2 = b0;
    }
    if (a1.negative !== 0) {
      a1 = a1.neg();
      b1 = b1.neg();
    }
    if (a2.negative !== 0) {
      a2 = a2.neg();
      b2 = b2.neg();
    }
    return [
      { a: a1, b: b1 },
      { a: a2, b: b2 }
    ];
  }
  _endoSplit(k) {
    const basis = this.endo.basis;
    const v1 = basis[0];
    const v2 = basis[1];
    const c1 = v2.b.mul(k).divRound(this.n);
    const c2 = v1.b.neg().mul(k).divRound(this.n);
    const p1 = c1.mul(v1.a);
    const p2 = c2.mul(v2.a);
    const q1 = c1.mul(v1.b);
    const q2 = c2.mul(v2.b);
    const k1 = k.sub(p1).sub(p2);
    const k2 = q1.add(q2).neg();
    return { k1, k2 };
  }
  validate(point) {
    if (point.inf) {
      return true;
    }
    const x = point.x;
    const y = point.y;
    const ax = this.a.redMul(x);
    const rhs = x.redSqr().redMul(x).redIAdd(ax).redIAdd(this.b);
    return y.redSqr().redISub(rhs).cmpn(0) === 0;
  }
};

// node_modules/@bsv/sdk/dist/esm/src/primitives/ECDSA.js
var ECDSA_exports = {};
__export(ECDSA_exports, {
  sign: () => sign,
  verify: () => verify
});

// node_modules/@bsv/sdk/dist/esm/src/primitives/Signature.js
var Signature = class _Signature {
  /**
   * Creates an instance of the Signature class.
   *
   * @constructor
   * @param r - The R component of the signature.
   * @param s - The S component of the signature.
   *
   * @example
   * const r = new BigNumber('208755674028...');
   * const s = new BigNumber('564745627577...');
   * const signature = new Signature(r, s);
   */
  constructor(r2, s2) {
    /**
     * @property Represents the "r" component of the digital signature
     */
    __publicField(this, "r");
    /**
     * @property Represents the "s" component of the digital signature
     */
    __publicField(this, "s");
    this.r = r2;
    this.s = s2;
  }
  /**
   * Takes an array of numbers or a string and returns a new Signature instance.
   * This method will throw an error if the DER encoding is invalid.
   * If a string is provided, it is assumed to represent a hexadecimal sequence.
   *
   * @static
   * @method fromDER
   * @param data - The sequence to decode from DER encoding.
   * @param enc - The encoding of the data string.
   * @returns The decoded data in the form of Signature instance.
   *
   * @example
   * const signature = Signature.fromDER('30440220018c1f5502f8...', 'hex');
   */
  static fromDER(data, enc) {
    const getLength = (buf, p2) => {
      const initial = buf[p2.place++];
      if ((initial & 128) === 0) {
        return initial;
      } else {
        throw new Error("Invalid DER entity length");
      }
    };
    class Position {
      constructor() {
        __publicField(this, "place");
        this.place = 0;
      }
    }
    data = toArray2(data, enc);
    const p = new Position();
    if (data[p.place++] !== 48) {
      throw new Error("Signature DER must start with 0x30");
    }
    const len = getLength(data, p);
    if (len + p.place !== data.length) {
      throw new Error("Signature DER invalid");
    }
    if (data[p.place++] !== 2) {
      throw new Error("Signature DER invalid");
    }
    const rlen = getLength(data, p);
    let r2 = data.slice(p.place, rlen + p.place);
    p.place += rlen;
    if (data[p.place++] !== 2) {
      throw new Error("Signature DER invalid");
    }
    const slen = getLength(data, p);
    if (data.length !== slen + p.place) {
      throw new Error("Invalid R-length in signature DER");
    }
    let s2 = data.slice(p.place, slen + p.place);
    if (r2[0] === 0) {
      if ((r2[1] & 128) !== 0) {
        r2 = r2.slice(1);
      } else {
        throw new Error("Invalid R-value in signature DER");
      }
    }
    if (s2[0] === 0) {
      if ((s2[1] & 128) !== 0) {
        s2 = s2.slice(1);
      } else {
        throw new Error("Invalid S-value in signature DER");
      }
    }
    return new _Signature(new BigNumber(r2), new BigNumber(s2));
  }
  /**
   * Takes an array of numbers or a string and returns a new Signature instance.
   * This method will throw an error if the Compact encoding is invalid.
   * If a string is provided, it is assumed to represent a hexadecimal sequence.
   * compactByte value 27-30 means uncompressed public key.
   * 31-34 means compressed public key.
   * The range represents the recovery param which can be 0,1,2,3.
   * We could support recovery functions in future if there's demand.
   *
   * @static
   * @method fromCompact
   * @param data - The sequence to decode from Compact encoding.
   * @param enc - The encoding of the data string.
   * @returns The decoded data in the form of Signature instance.
   *
   * @example
   * const signature = Signature.fromCompact('1b18c1f5502f8...', 'hex');
   */
  static fromCompact(data, enc) {
    data = toArray2(data, enc);
    if (data.length !== 65) {
      throw new Error("Invalid Compact Signature");
    }
    const compactByte = data[0];
    if (compactByte < 27 || compactByte >= 35) {
      throw new Error("Invalid Compact Byte");
    }
    return new _Signature(new BigNumber(data.slice(1, 33)), new BigNumber(data.slice(33, 65)));
  }
  /**
   * Verifies a digital signature.
   *
   * This method will return true if the signature, key, and message hash match.
   * If the data or key do not match the signature, the function returns false.
   *
   * @method verify
   * @param msg - The message to verify.
   * @param key - The public key used to sign the original message.
   * @param enc - The encoding of the msg string.
   * @returns A boolean representing whether the signature is valid.
   *
   * @example
   * const msg = 'The quick brown fox jumps over the lazy dog';
   * const publicKey = PublicKey.fromString('04188ca1050...');
   * const isVerified = signature.verify(msg, publicKey);
   */
  verify(msg, key, enc) {
    const msgHash = new BigNumber(sha256(msg, enc), 16);
    return verify(msgHash, this, key);
  }
  /**
   * Converts an instance of Signature into DER encoding.
   * An alias for the toDER method.
   *
   * If the encoding parameter is set to 'hex', the function will return a hex string.
   * If 'base64', it will return a base64 string.
   * Otherwise, it will return an array of numbers.
   *
   * @method toDER
   * @param enc - The encoding to use for the output.
   * @returns The current instance in DER encoding.
   *
   * @example
   * const der = signature.toString('base64');
   */
  toString(enc) {
    return this.toDER(enc);
  }
  /**
   * Converts an instance of Signature into DER encoding.
   *
   * If the encoding parameter is set to 'hex', the function will return a hex string.
   * If 'base64', it will return a base64 string.
   * Otherwise, it will return an array of numbers.
   *
   * @method toDER
   * @param enc - The encoding to use for the output.
   * @returns The current instance in DER encoding.
   *
   * @example
   * const der = signature.toDER('hex');
   */
  toDER(enc) {
    const constructLength = (arr2, len) => {
      if (len < 128) {
        arr2.push(len);
      } else {
        throw new Error("len must be < 0x80");
      }
    };
    const rmPadding = (buf) => {
      let i = 0;
      const len = buf.length - 1;
      while (buf[i] === 0 && (buf[i + 1] & 128) === 0 && i < len) {
        i++;
      }
      if (i === 0) {
        return buf;
      }
      return buf.slice(i);
    };
    let r2 = this.r.toArray();
    let s2 = this.s.toArray();
    if ((r2[0] & 128) !== 0) {
      r2 = [0].concat(r2);
    }
    if ((s2[0] & 128) !== 0) {
      s2 = [0].concat(s2);
    }
    r2 = rmPadding(r2);
    s2 = rmPadding(s2);
    while (s2[0] === 0 && (s2[1] & 128) === 0) {
      s2 = s2.slice(1);
    }
    let arr = [2];
    constructLength(arr, r2.length);
    arr = arr.concat(r2);
    arr.push(2);
    constructLength(arr, s2.length);
    const backHalf = arr.concat(s2);
    let res = [48];
    constructLength(res, backHalf.length);
    res = res.concat(backHalf);
    if (enc === "hex") {
      return toHex(res);
    } else if (enc === "base64") {
      return toBase64(res);
    } else {
      return res;
    }
  }
  /**
   * Converts an instance of Signature into Compact encoding.
   *
   * If the encoding parameter is set to 'hex', the function will return a hex string.
   * If 'base64', it will return a base64 string.
   * Otherwise, it will return an array of numbers.
   *
   * @method toCompact
   * @param enc - The encoding to use for the output.
   * @returns The current instance in DER encoding.
   *
   * @example
   * const compact = signature.toCompact(3, true, 'base64');
   */
  toCompact(recovery, compressed, enc) {
    if (recovery < 0 || recovery > 3)
      throw new Error("Invalid recovery param");
    if (typeof compressed !== "boolean")
      throw new Error("Invalid compressed param");
    let compactByte = 27 + recovery;
    if (compressed) {
      compactByte += 4;
    }
    let arr = [compactByte];
    arr = arr.concat(this.r.toArray("be", 32));
    arr = arr.concat(this.s.toArray("be", 32));
    if (enc === "hex") {
      return toHex(arr);
    } else if (enc === "base64") {
      return toBase64(arr);
    } else {
      return arr;
    }
  }
  /**
   * Recovers the public key from a signature.
   * This method will return the public key if it finds a valid public key.
   * If it does not find a valid public key, it will throw an error.
   * The recovery factor is a number between 0 and 3.
   * @method RecoverPublicKey
   * @param recovery - The recovery factor.
   * @param e - The message hash.
   * @returns The public key associated with the signature.
   *
   * @example
   * const publicKey = signature.RecoverPublicKey(0, msgHash);
   */
  RecoverPublicKey(recovery, e) {
    const r2 = this.r;
    const s2 = this.s;
    const isYOdd = !!(recovery & 1);
    const isSecondKey = recovery >> 1;
    const curve = new Curve();
    const n = curve.n;
    const G = curve.g;
    const x = isSecondKey ? r2.add(n) : r2;
    const R2 = Point.fromX(x, isYOdd);
    const nR = R2.mul(n);
    if (!nR.isInfinity()) {
      throw new Error("nR is not at infinity");
    }
    const eNeg = e.neg().umod(n);
    const rInv = r2.invm(n);
    const srInv = rInv.mul(s2).umod(n);
    const eInvrInv = rInv.mul(eNeg).umod(n);
    const Q = G.mul(eInvrInv).add(R2.mul(srInv));
    const pubKey = new PublicKey(Q);
    pubKey.validate();
    return pubKey;
  }
  /**
   * Calculates the recovery factor which will work for a particular public key and message hash.
   * This method will return the recovery factor if it finds a valid recovery factor.
   * If it does not find a valid recovery factor, it will throw an error.
   * The recovery factor is a number between 0 and 3.
   *
   * @method CalculateRecoveryFactor
   * @param msgHash - The message hash.
   * @returns the recovery factor: number
   * /
   * @example
   * const recovery = signature.CalculateRecoveryFactor(publicKey, msgHash);
   */
  CalculateRecoveryFactor(pubkey, msgHash) {
    for (let recovery = 0; recovery < 4; recovery++) {
      let Qprime;
      try {
        Qprime = this.RecoverPublicKey(recovery, msgHash);
      } catch (e) {
        continue;
      }
      if (pubkey.eq(Qprime)) {
        return recovery;
      }
    }
    throw new Error("Unable to find valid recovery factor");
  }
};

// node_modules/@bsv/sdk/dist/esm/src/primitives/DRBG.js
var DRBG = class {
  constructor(entropy, nonce) {
    __publicField(this, "K");
    __publicField(this, "V");
    entropy = toArray2(entropy, "hex");
    nonce = toArray2(nonce, "hex");
    if (entropy.length < 32) {
      throw new Error("Not enough entropy. Minimum is 256 bits");
    }
    const seed = entropy.concat(nonce);
    this.K = new Array(32);
    this.V = new Array(32);
    for (let i = 0; i < 32; i++) {
      this.K[i] = 0;
      this.V[i] = 1;
    }
    this.update(seed);
  }
  /**
   * Generates HMAC using the K value of the instance. This method is used internally for operations.
   *
   * @method hmac
   * @returns The SHA256HMAC object created with K value.
   *
   * @example
   * const hmac = drbg.hmac();
   */
  hmac() {
    return new SHA256HMAC(this.K);
  }
  /**
   * Updates the `K` and `V` values of the instance based on the seed.
   * The seed if not provided uses `V` as seed.
   *
   * @method update
   * @param seed - an optional value that used to update `K` and `V`. Default is `undefined`.
   * @returns Nothing, but updates the internal state `K` and `V` value.
   *
   * @example
   * drbg.update('e13af...');
   */
  update(seed) {
    let kmac = this.hmac().update(this.V).update([0]);
    if (seed !== void 0) {
      kmac = kmac.update(seed);
    }
    this.K = kmac.digest();
    this.V = this.hmac().update(this.V).digest();
    if (seed === void 0) {
      return;
    }
    this.K = this.hmac().update(this.V).update([1]).update(seed).digest();
    this.V = this.hmac().update(this.V).digest();
  }
  /**
   * Generates deterministic random hexadecimal string of given length.
   * In every generation process, it also updates the internal state `K` and `V`.
   *
   * @method generate
   * @param len - The length of required random number.
   * @returns The required deterministic random hexadecimal string.
   *
   * @example
   * const randomHex = drbg.generate(256);
   */
  generate(len) {
    let temp = [];
    while (temp.length < len) {
      this.V = this.hmac().update(this.V).digest();
      temp = temp.concat(this.V);
    }
    const res = temp.slice(0, len);
    this.update();
    return toHex(res);
  }
};

// node_modules/@bsv/sdk/dist/esm/src/primitives/ECDSA.js
function truncateToN(msg, truncOnly) {
  const curve = new Curve();
  const delta = msg.byteLength() * 8 - curve.n.bitLength();
  if (delta > 0) {
    msg = msg.ushrn(delta);
  }
  if (!truncOnly && msg.cmp(curve.n) >= 0) {
    return msg.sub(curve.n);
  } else {
    return msg;
  }
}
var sign = (msg, key, forceLowS = false, customK) => {
  const curve = new Curve();
  msg = truncateToN(msg);
  const bytes = curve.n.byteLength();
  const bkey = key.toArray("be", bytes);
  const nonce = msg.toArray("be", bytes);
  const drbg = new DRBG(bkey, nonce);
  const ns1 = curve.n.subn(1);
  for (let iter = 0; ; iter++) {
    let k = typeof customK === "function" ? customK(iter) : BigNumber.isBN(customK) ? customK : new BigNumber(drbg.generate(bytes), 16);
    k = truncateToN(k, true);
    if (k.cmpn(1) <= 0 || k.cmp(ns1) >= 0) {
      if (BigNumber.isBN(customK)) {
        throw new Error("Invalid fixed custom K value (must be more than 1 and less than N-1)");
      } else {
        continue;
      }
    }
    const kp = curve.g.mul(k);
    if (kp.isInfinity()) {
      if (BigNumber.isBN(customK)) {
        throw new Error("Invalid fixed custom K value (must not create a point at infinity when multiplied by the generator point)");
      } else {
        continue;
      }
    }
    const kpX = kp.getX();
    const r2 = kpX.umod(curve.n);
    if (r2.cmpn(0) === 0) {
      if (BigNumber.isBN(customK)) {
        throw new Error("Invalid fixed custom K value (when multiplied by G, the resulting x coordinate mod N must not be zero)");
      } else {
        continue;
      }
    }
    let s2 = k.invm(curve.n).mul(r2.mul(key).iadd(msg));
    s2 = s2.umod(curve.n);
    if (s2.cmpn(0) === 0) {
      if (BigNumber.isBN(customK)) {
        throw new Error("Invalid fixed custom K value (when used with the key, it cannot create a zero value for S)");
      } else {
        continue;
      }
    }
    if (forceLowS && s2.cmp(curve.n.ushrn(1)) > 0) {
      s2 = curve.n.sub(s2);
    }
    return new Signature(r2, s2);
  }
};
var verify = (msg, sig, key) => {
  const curve = new Curve();
  msg = truncateToN(msg);
  const r2 = sig.r;
  const s2 = sig.s;
  if (r2.cmpn(1) < 0 || r2.cmp(curve.n) >= 0) {
    return false;
  }
  if (s2.cmpn(1) < 0 || s2.cmp(curve.n) >= 0) {
    return false;
  }
  const sinv = s2.invm(curve.n);
  const u1 = sinv.mul(msg).umod(curve.n);
  const u2 = sinv.mul(r2).umod(curve.n);
  const p = curve.g.jmulAdd(u1, key, u2);
  if (p.isInfinity()) {
    return false;
  }
  return p.eqXToP(r2);
};

// node_modules/@bsv/sdk/dist/esm/src/primitives/PublicKey.js
var PublicKey = class _PublicKey extends Point {
  /**
   * Static factory method to derive a public key from a private key.
   * It multiplies the generator point 'g' on the elliptic curve by the private key.
   *
   * @static
   * @method fromPrivateKey
   *
   * @param key - The private key from which to derive the public key.
   *
   * @returns Returns the PublicKey derived from the given PrivateKey.
   *
   * @example
   * const myPrivKey = new PrivateKey(...)
   * const myPubKey = PublicKey.fromPrivateKey(myPrivKey)
   */
  static fromPrivateKey(key) {
    const c = new Curve();
    const p = c.g.mul(key);
    return new _PublicKey(p.x, p.y);
  }
  /**
   * Static factory method to create a PublicKey instance from a string.
   *
   * @param str - A string representing a public key.
   *
   * @returns Returns the PublicKey created from the string.
   *
   * @example
   * const myPubKey = PublicKey.fromString("03....")
   */
  static fromString(str) {
    const p = Point.fromString(str);
    return new _PublicKey(p.x, p.y);
  }
  /**
   * @constructor
   * @param x - A point or the x-coordinate of the point. May be a number, a BigNumber, a string (which will be interpreted as hex), a number array, or null. If null, an "Infinity" point is constructed.
   * @param y - If x is not a point, the y-coordinate of the point, similar to x.
   * @param isRed - A boolean indicating if the point is a member of the field of integers modulo the k256 prime. Default is true.
   *
   * @example
   * new PublicKey(point1);
   * new PublicKey('abc123', 'def456');
   */
  constructor(x, y = null, isRed = true) {
    if (x instanceof Point) {
      super(x.getX(), x.getY());
    } else {
      super(x, y, isRed);
    }
  }
  /**
   * Derive a shared secret from a public key and a private key for use in symmetric encryption.
   * This method multiplies the public key (an instance of Point) with a private key.
   *
   * @param priv - The private key to use in deriving the shared secret.
   *
   * @returns Returns the Point representing the shared secret.
   *
   * @throws Will throw an error if the public key is not valid for ECDH secret derivation.
   *
   * @example
   * const myPrivKey = new PrivateKey(...)
   * const sharedSecret = myPubKey.deriveSharedSecret(myPrivKey)
   */
  deriveSharedSecret(priv) {
    if (!this.validate()) {
      throw new Error("Public key not valid for ECDH secret derivation");
    }
    return this.mul(priv);
  }
  /**
   * Verify a signature of a message using this public key.
   *
   * @param msg - The message to verify. It can be a string or an array of numbers.
   * @param sig - The Signature of the message that needs verification.
   * @param enc - The encoding of the message. It defaults to 'utf8'.
   *
   * @returns Returns true if the signature is verified successfully, otherwise false.
   *
   * @example
   * const myMessage = "Hello, world!"
   * const mySignature = new Signature(...)
   * const isVerified = myPubKey.verify(myMessage, mySignature)
   */
  verify(msg, sig, enc) {
    const msgHash = new BigNumber(sha256(msg, enc), 16);
    return verify(msgHash, sig, this);
  }
  /**
   * Encode the public key to DER (Distinguished Encoding Rules) format.
   *
   * @returns Returns the DER-encoded string of this public key.
   *
   * @example
   * const derPublicKey = myPubKey.toDER()
   */
  toDER() {
    return this.encode(true, "hex");
  }
  /**
   * Hash sha256 and ripemd160 of the public key.
   *
   * @returns Returns the hash of the public key.
   *
   * @example
   * const publicKeyHash = pubkey.toHash()
   */
  toHash(enc) {
    const pkh = hash160(this.encode(true));
    if (enc === "hex") {
      return toHex(pkh);
    }
    return pkh;
  }
  /**
   * Base58Check encodes the hash of the public key with a prefix to indicate locking script type.
   * Defaults to P2PKH for mainnet, otherwise known as a "Bitcoin Address".
   *
   * @param prefix defaults to [0x00] for mainnet, set to [0x6f] for testnet or use the strings 'mainnet' or 'testnet'
   *
   * @returns Returns the address encoding associated with the hash of the public key.
   *
   * @example
   * const address = pubkey.toAddress()
   * const address = pubkey.toAddress('mainnet')
   * const testnetAddress = pubkey.toAddress([0x6f])
   * const testnetAddress = pubkey.toAddress('testnet')
   */
  toAddress(prefix2 = [0]) {
    if (typeof prefix2 === "string") {
      if (prefix2 === "testnet" || prefix2 === "test") {
        prefix2 = [111];
      } else if (prefix2 === "mainnet" || prefix2 === "main") {
        prefix2 = [0];
      } else {
        throw new Error(`Invalid prefix ${prefix2}`);
      }
    }
    return toBase58Check(this.toHash(), prefix2);
  }
  /**
   * Derives a child key with BRC-42.
   * @param privateKey The private key of the other party
   * @param invoiceNumber The invoice number used to derive the child key
   * @returns The derived child key.
   */
  deriveChild(privateKey, invoiceNumber) {
    const sharedSecret = this.deriveSharedSecret(privateKey);
    const invoiceNumberBin = toArray2(invoiceNumber, "utf8");
    const hmac = sha256hmac(sharedSecret.encode(true), invoiceNumberBin);
    const curve = new Curve();
    const point = curve.g.mul(new BigNumber(hmac));
    const finalPoint = this.add(point);
    return new _PublicKey(finalPoint.x, finalPoint.y);
  }
  /**
   * Takes an array of numbers or a string and returns a new PublicKey instance.
   * This method will throw an error if the Compact encoding is invalid.
   * If a string is provided, it is assumed to represent a hexadecimal sequence.
   * compactByte value 27-30 means uncompressed public key.
   * 31-34 means compressed public key.
   * The range represents the recovery param which can be 0,1,2,3.
   *
   * @static
   * @method fromMsgHashAndCompactSignature
   * @param msgHash - The message hash which was signed.
   * @param signature - The signature in compact format.
   * @param enc - The encoding of the signature string.
   * @returns A PublicKey instance derived from the message hash and compact signature.
   * @example
   * const publicKey = Signature.fromMsgHashAndCompactSignature(msgHash, 'IMOl2mVKfDgsSsHT4uIYBNN4e...', 'base64');
   */
  static fromMsgHashAndCompactSignature(msgHash, signature, enc) {
    const data = toArray2(signature, enc);
    if (data.length !== 65) {
      throw new Error("Invalid Compact Signature");
    }
    const compactByte = data[0];
    if (compactByte < 27 || compactByte >= 35) {
      throw new Error("Invalid Compact Byte");
    }
    let r2 = data[0] - 27;
    let compressed = false;
    if (r2 > 3) {
      compressed = true;
      r2 -= 4;
    }
    const s2 = new Signature(new BigNumber(data.slice(1, 33)), new BigNumber(data.slice(33, 65)));
    return s2.RecoverPublicKey(r2, msgHash);
  }
};

// node_modules/@bsv/sdk/dist/esm/src/primitives/Random.js
var Rand = class {
  constructor() {
    __publicField(this, "_rand");
    const noRand = () => {
      throw new Error("No secure random number generator is available in this environment.");
    };
    if (typeof self === "object") {
      if (self.crypto && self.crypto.getRandomValues) {
        this._rand = (n) => {
          const arr = new Uint8Array(n);
          self.crypto.getRandomValues(arr);
          return [...arr];
        };
      } else {
        this._rand = noRand;
      }
    } else {
      try {
        const crypto = require_crypto();
        if (typeof crypto.randomBytes === "function") {
          this._rand = (n) => [...crypto.randomBytes(n)];
        }
      } catch (e) {
        this._rand = noRand;
      }
    }
  }
  generate(len) {
    return this._rand(len);
  }
};
var ayn = null;
var Random_default = (len) => {
  if (ayn == null) {
    ayn = new Rand();
  }
  return ayn.generate(len);
};

// node_modules/@bsv/sdk/dist/esm/src/primitives/PrivateKey.js
var PrivateKey = class _PrivateKey extends BigNumber {
  /**
   * Generates a private key randomly.
   *
   * @method fromRandom
   * @static
   * @returns The newly generated Private Key.
   *
   * @example
   * const privateKey = PrivateKey.fromRandom();
   */
  static fromRandom() {
    return new _PrivateKey(Random_default(32));
  }
  /**
   * Generates a private key from a string.
   *
   * @method fromString
   * @static
   * @param str - The string to generate the private key from.
   * @param base - The base of the string.
   * @returns The generated Private Key.
   * @throws Will throw an error if the string is not valid.
   **/
  static fromString(str, base) {
    return new _PrivateKey(BigNumber.fromString(str, base).toArray());
  }
  /**
   * Generates a private key from a WIF (Wallet Import Format) string.
   *
   * @method fromWif
   * @static
   * @param wif - The WIF string to generate the private key from.
   * @param base - The base of the string.
   * @returns The generated Private Key.
   * @throws Will throw an error if the string is not a valid WIF.
   **/
  static fromWif(wif, prefixLength = 1) {
    const decoded = fromBase58Check(wif, null, prefixLength);
    if (decoded.data.length !== 33) {
      throw new Error("Invalid WIF length");
    }
    if (decoded.data[32] !== 1) {
      throw new Error("Invalid WIF padding");
    }
    return new _PrivateKey(decoded.data.slice(0, 32));
  }
  /**
   * @constructor
   *
   * @param number - The number (various types accepted) to construct a BigNumber from. Default is 0.
   *
   * @param base - The base of number provided. By default is 10. Ignored if number is BigNumber.
   *
   * @param endian - The endianness provided. By default is 'big endian'. Ignored if number is BigNumber.
   *
   * @param modN - Optional. Default 'apply. If 'apply', apply modN to input to guarantee a valid PrivateKey. If 'error', if input is out of field throw Error('Input is out of field'). If 'nocheck', assumes input is in field.
   *
   * @example
   * import PrivateKey from './PrivateKey';
   * import BigNumber from './BigNumber';
   * const privKey = new PrivateKey(new BigNumber('123456', 10, 'be'));
   */
  constructor(number = 0, base = 10, endian = "be", modN = "apply") {
    if (number instanceof BigNumber) {
      super();
      number.copy(this);
    } else {
      super(number, base, endian);
    }
    if (modN !== "nocheck") {
      const check = this.checkInField();
      if (!check.inField) {
        if (modN === "error") {
          throw new Error("Input is out of field");
        }
        BigNumber.move(this, check.modN);
      }
    }
  }
  /**
   * A utility function to check that the value of this PrivateKey lies in the field limited by curve.n
   * @returns { inField, modN } where modN is this PrivateKey's current BigNumber value mod curve.n, and inField is true only if modN equals current BigNumber value.
   */
  checkInField() {
    const curve = new Curve();
    const modN = this.mod(curve.n);
    const inField = this.cmp(modN) === 0;
    return { inField, modN };
  }
  /**
   * @returns true if the PrivateKey's current BigNumber value lies in the field limited by curve.n
   */
  isValid() {
    return this.checkInField().inField;
  }
  /**
   * Signs a message using the private key.
   *
   * @method sign
   * @param msg - The message (array of numbers or string) to be signed.
   * @param enc - If 'hex' the string will be treated as hex, utf8 otherwise.
   * @param forceLowS - If true (the default), the signature will be forced to have a low S value.
   * @param customK  If provided, uses a custom K-value for the signature. Provie a function that returns a BigNumber, or the BigNumber itself.
   * @returns A digital signature generated from the hash of the message and the private key.
   *
   * @example
   * const privateKey = PrivateKey.fromRandom();
   * const signature = privateKey.sign('Hello, World!');
   */
  sign(msg, enc, forceLowS = true, customK) {
    const msgHash = new BigNumber(sha256(msg, enc), 16);
    return sign(msgHash, this, forceLowS, customK);
  }
  /**
   * Verifies a message's signature using the public key associated with this private key.
   *
   * @method verify
   * @param msg - The original message which has been signed.
   * @param sig - The signature to be verified.
   * @param enc - The data encoding method.
   * @returns Whether or not the signature is valid.
   *
   * @example
   * const privateKey = PrivateKey.fromRandom();
   * const signature = privateKey.sign('Hello, World!');
   * const isSignatureValid = privateKey.verify('Hello, World!', signature);
   */
  verify(msg, sig, enc) {
    const msgHash = new BigNumber(sha256(msg, enc), 16);
    return verify(msgHash, sig, this.toPublicKey());
  }
  /**
   * Converts the private key to its corresponding public key.
   *
   * The public key is generated by multiplying the base point G of the curve and the private key.
   *
   * @method toPublicKey
   * @returns The generated PublicKey.
   *
   * @example
   * const privateKey = PrivateKey.fromRandom();
   * const publicKey = privateKey.toPublicKey();
   */
  toPublicKey() {
    const c = new Curve();
    const p = c.g.mul(this);
    return new PublicKey(p.x, p.y);
  }
  /**
   * Converts the private key to a Wallet Import Format (WIF) string.
   *
   * Base58Check encoding is used for encoding the private key.
   * The prefix
   *
   * @method toWif
   * @returns The WIF string.
   *
   * @param prefix defaults to [0x80] for mainnet, set it to [0xef] for testnet.
   *
   * @throws Error('Value is out of field') if current BigNumber value is out of field limited by curve.n
   *
   * @example
   * const privateKey = PrivateKey.fromRandom();
   * const wif = privateKey.toWif();
   * const testnetWif = privateKey.toWif([0xef]);
   */
  toWif(prefix2 = [128]) {
    if (!this.isValid()) {
      throw new Error("Value is out of field");
    }
    return toBase58Check([...this.toArray("be", 32), 1], prefix2);
  }
  /**
   * Base58Check encodes the hash of the public key associated with this private key with a prefix to indicate locking script type.
   * Defaults to P2PKH for mainnet, otherwise known as a "Bitcoin Address".
   *
   * @param prefix defaults to [0x00] for mainnet, set to [0x6f] for testnet or use the strings 'testnet' or 'mainnet'
   *
   * @returns Returns the address encoding associated with the hash of the public key associated with this private key.
   *
   * @example
   * const address = privkey.toAddress()
   * const address = privkey.toAddress('mainnet')
   * const testnetAddress = privkey.toAddress([0x6f])
   * const testnetAddress = privkey.toAddress('testnet')
   */
  toAddress(prefix2 = [0]) {
    return this.toPublicKey().toAddress(prefix2);
  }
  /**
   * Derives a shared secret from the public key.
   *
   * @method deriveSharedSecret
   * @param key - The public key to derive the shared secret from.
   * @returns The derived shared secret (a point on the curve).
   * @throws Will throw an error if the public key is not valid.
   *
   * @example
   * const privateKey = PrivateKey.fromRandom();
   * const publicKey = privateKey.toPublicKey();
   * const sharedSecret = privateKey.deriveSharedSecret(publicKey);
   */
  deriveSharedSecret(key) {
    if (!key.validate()) {
      throw new Error("Public key not valid for ECDH secret derivation");
    }
    return key.mul(this);
  }
  /**
   * Derives a child key with BRC-42.
   * @param publicKey The public key of the other party
   * @param invoiceNumber The invoice number used to derive the child key
   * @returns The derived child key.
   */
  deriveChild(publicKey, invoiceNumber) {
    const sharedSecret = this.deriveSharedSecret(publicKey);
    const invoiceNumberBin = toArray2(invoiceNumber, "utf8");
    const hmac = sha256hmac(sharedSecret.encode(true), invoiceNumberBin);
    const curve = new Curve();
    return new _PrivateKey(this.add(new BigNumber(hmac)).mod(curve.n).toArray());
  }
};

// node_modules/@bsv/sdk/dist/esm/src/primitives/AESGCM.js
var SBox = [
  [99, 124, 119, 123, 242, 107, 111, 197, 48, 1, 103, 43, 254, 215, 171, 118],
  [202, 130, 201, 125, 250, 89, 71, 240, 173, 212, 162, 175, 156, 164, 114, 192],
  [183, 253, 147, 38, 54, 63, 247, 204, 52, 165, 229, 241, 113, 216, 49, 21],
  [4, 199, 35, 195, 24, 150, 5, 154, 7, 18, 128, 226, 235, 39, 178, 117],
  [9, 131, 44, 26, 27, 110, 90, 160, 82, 59, 214, 179, 41, 227, 47, 132],
  [83, 209, 0, 237, 32, 252, 177, 91, 106, 203, 190, 57, 74, 76, 88, 207],
  [208, 239, 170, 251, 67, 77, 51, 133, 69, 249, 2, 127, 80, 60, 159, 168],
  [81, 163, 64, 143, 146, 157, 56, 245, 188, 182, 218, 33, 16, 255, 243, 210],
  [205, 12, 19, 236, 95, 151, 68, 23, 196, 167, 126, 61, 100, 93, 25, 115],
  [96, 129, 79, 220, 34, 42, 144, 136, 70, 238, 184, 20, 222, 94, 11, 219],
  [224, 50, 58, 10, 73, 6, 36, 92, 194, 211, 172, 98, 145, 149, 228, 121],
  [231, 200, 55, 109, 141, 213, 78, 169, 108, 86, 244, 234, 101, 122, 174, 8],
  [186, 120, 37, 46, 28, 166, 180, 198, 232, 221, 116, 31, 75, 189, 139, 138],
  [112, 62, 181, 102, 72, 3, 246, 14, 97, 53, 87, 185, 134, 193, 29, 158],
  [225, 248, 152, 17, 105, 217, 142, 148, 155, 30, 135, 233, 206, 85, 40, 223],
  [140, 161, 137, 13, 191, 230, 66, 104, 65, 153, 45, 15, 176, 84, 187, 22]
];
var Rcon = [
  [0, 0, 0, 0],
  [1, 0, 0, 0],
  [2, 0, 0, 0],
  [4, 0, 0, 0],
  [8, 0, 0, 0],
  [16, 0, 0, 0],
  [32, 0, 0, 0],
  [64, 0, 0, 0],
  [128, 0, 0, 0],
  [27, 0, 0, 0],
  [54, 0, 0, 0]
];
function addRoundKey(state, roundKeyArray, offset) {
  let i;
  let j;
  for (i = 0; i < 4; i++) {
    for (j = 0; j < 4; j++) {
      state[i][j] = state[i][j] ^ roundKeyArray[offset + j][i];
    }
  }
}
function subBytes(state) {
  let i;
  let j;
  for (i = 0; i < 4; i++) {
    for (j = 0; j < 4; j++) {
      state[i][j] = SBox[(state[i][j] & 240) >> 4][state[i][j] & 15];
    }
  }
}
function subWord(value) {
  let i;
  for (i = 0; i < 4; i++) {
    value[i] = SBox[(value[i] & 240) >> 4][value[i] & 15];
  }
}
function rotWord(value) {
  const temp = value[0];
  value[0] = value[1];
  value[1] = value[2];
  value[2] = value[3];
  value[3] = temp;
}
function shiftRows(state) {
  let i;
  let j;
  let k;
  let l;
  let temp;
  for (i = 1; i < 4; i++) {
    for (j = 0; j < (i - 1) % 2 + 1; j++) {
      temp = state[i][j];
      k = j;
      while (true) {
        l = k + i;
        if (l >= 4) {
          l = l - 4;
        }
        if (l === j) {
          break;
        }
        state[i][k] = state[i][l];
        k = l;
      }
      state[i][k] = temp;
    }
  }
}
function finiteFieldMultiplication(value0, value1) {
  let i;
  let result = 0;
  for (i = 0; i < 8; i++) {
    if ((value1 & 1) !== 0) {
      result = result ^ value0;
    }
    if ((value0 & 128) !== 0) {
      value0 = value0 << 1;
      value0 = value0 ^ 283;
    } else {
      value0 = value0 << 1;
    }
    value1 = value1 >> 1;
  }
  return result;
}
function mixColumns(state) {
  let i;
  let j;
  const temp = [[], [], [], []];
  for (i = 0; i < 4; i++) {
    temp[0][i] = finiteFieldMultiplication(2, state[0][i]) ^ finiteFieldMultiplication(3, state[1][i]) ^ state[2][i] ^ state[3][i];
    temp[1][i] = state[0][i] ^ finiteFieldMultiplication(2, state[1][i]) ^ finiteFieldMultiplication(3, state[2][i]) ^ state[3][i];
    temp[2][i] = state[0][i] ^ state[1][i] ^ finiteFieldMultiplication(2, state[2][i]) ^ finiteFieldMultiplication(3, state[3][i]);
    temp[3][i] = finiteFieldMultiplication(3, state[0][i]) ^ state[1][i] ^ state[2][i] ^ finiteFieldMultiplication(2, state[3][i]);
  }
  for (i = 0; i < 4; i++) {
    for (j = 0; j < 4; j++) {
      state[i][j] = temp[i][j];
    }
  }
}
function keyExpansion(roundLimit, key) {
  let i;
  let j;
  const nK = parseInt(String(key.length / 4));
  const result = [];
  for (i = 0; i < key.length; i++) {
    if (i % 4 === 0) {
      result.push([]);
    }
    result[parseInt(String(i / 4))].push(key[i]);
  }
  for (i = nK; i < 4 * roundLimit; i++) {
    result[i] = [];
    const temp = result[i - 1].slice();
    if (i % nK === 0) {
      rotWord(temp);
      subWord(temp);
      for (j = 0; j < 4; j++) {
        temp[j] = temp[j] ^ Rcon[parseInt(String(i / nK))][j];
      }
    } else if (nK > 6 && i % nK === 4) {
      subWord(temp);
    }
    for (j = 0; j < 4; j++) {
      result[i][j] = result[i - nK][j] ^ temp[j];
    }
  }
  return result;
}
function AES(input, key) {
  let i;
  let j;
  let round;
  let roundLimit;
  const state = [[], [], [], []];
  const output = [];
  const ekey = Array.from(key);
  if (ekey.length <= 16) {
    while (ekey.length < 16)
      ekey.unshift(0);
    roundLimit = 11;
  } else if (ekey.length <= 24) {
    while (ekey.length < 24)
      ekey.unshift(0);
    roundLimit = 13;
  } else if (key.length <= 32) {
    while (ekey.length < 32)
      ekey.unshift(0);
    roundLimit = 15;
  } else {
    throw new Error("Illegal key length: " + String(key.length));
  }
  const w = keyExpansion(roundLimit, ekey);
  for (i = 0; i < 15; i++) {
    state[parseInt(String(i / 4))].push(input[i * 4 % 15]);
  }
  state[3].push(input[15]);
  addRoundKey(state, w, 0);
  for (round = 1; round < roundLimit; round++) {
    subBytes(state);
    shiftRows(state);
    if (round + 1 < roundLimit) {
      mixColumns(state);
    }
    addRoundKey(state, w, round * 4);
  }
  for (i = 0; i < 4; i++) {
    for (j = 0; j < 4; j++) {
      output.push(state[j][i]);
    }
  }
  return output;
}
var checkBit = function(byteArray, byteIndex, bitIndex) {
  return (byteArray[byteIndex] & 1 << bitIndex) !== 0 ? 1 : 0;
};
var getBytes = function(numericValue) {
  return [
    (numericValue & 4278190080) >>> 24,
    (numericValue & 16711680) >> 16,
    (numericValue & 65280) >> 8,
    numericValue & 255
  ];
};
var createZeroBlock = function(length) {
  let i;
  const result = [];
  for (i = 0; i < length; i++) {
    result.push(0);
  }
  return result;
};
var R = [225].concat(createZeroBlock(15));
var exclusiveOR = function(block0, block1) {
  let i;
  const result = [];
  for (i = 0; i < block0.length; i++) {
    result[i] = block0[i] ^ block1[i];
  }
  return result;
};
var rightShift = function(block) {
  let i;
  let carry = 0;
  let oldCarry = 0;
  for (i = 0; i < block.length; i++) {
    oldCarry = carry;
    carry = block[i] & 1;
    block[i] = block[i] >> 1;
    if (oldCarry !== 0) {
      block[i] = block[i] | 128;
    }
  }
  return block;
};
var multiply = function(block0, block1) {
  let i;
  let j;
  let v = block1.slice();
  let z = createZeroBlock(16);
  for (i = 0; i < 16; i++) {
    for (j = 7; j !== -1; j--) {
      if (checkBit(block0, i, j) !== 0) {
        z = exclusiveOR(z, v);
      }
      if (checkBit(v, 15, 0) !== 0) {
        v = exclusiveOR(rightShift(v), R);
      } else {
        v = rightShift(v);
      }
    }
  }
  return z;
};
var incrementLeastSignificantThirtyTwoBits = function(block) {
  let i;
  const result = block.slice();
  for (i = 15; i !== 11; i--) {
    result[i] = result[i] + 1;
    if (result[i] === 256) {
      result[i] = 0;
    } else {
      break;
    }
  }
  return result;
};
function ghash(input, hashSubKey) {
  let i;
  let result = createZeroBlock(16);
  for (i = 0; i < input.length; i += 16) {
    result = multiply(exclusiveOR(result, input.slice(i, Math.min(i + 16, input.length))), hashSubKey);
  }
  return result;
}
function gctr(input, initialCounterBlock, key) {
  let i;
  let j;
  let y;
  let counterBlock = initialCounterBlock;
  const output = [];
  if (input.length === 0) {
    return input;
  }
  const n = Math.ceil(input.length / 16);
  for (i = 0; i < n; i++) {
    y = exclusiveOR(input.slice(i * 16, Math.min((i + 1) * 16, input.length)), AES(counterBlock, key));
    for (j = 0; j < y.length; j++) {
      output.push(y[j]);
    }
    if (i + 1 < n) {
      counterBlock = incrementLeastSignificantThirtyTwoBits(counterBlock);
    }
  }
  return output;
}
function AESGCM(plainText, additionalAuthenticatedData, initializationVector, key) {
  let preCounterBlock;
  let plainTag;
  const hashSubKey = AES(createZeroBlock(16), key);
  preCounterBlock = [...initializationVector];
  if (initializationVector.length === 12) {
    preCounterBlock = preCounterBlock.concat(createZeroBlock(3)).concat([1]);
  } else {
    if (initializationVector.length % 16 !== 0) {
      preCounterBlock = preCounterBlock.concat(createZeroBlock(16 - initializationVector.length % 16));
    }
    preCounterBlock = preCounterBlock.concat(createZeroBlock(8));
    preCounterBlock = ghash(preCounterBlock.concat(createZeroBlock(4)).concat(getBytes(initializationVector.length * 8)), hashSubKey);
  }
  const cipherText = gctr(plainText, incrementLeastSignificantThirtyTwoBits(preCounterBlock), key);
  plainTag = additionalAuthenticatedData.slice();
  if (additionalAuthenticatedData.length === 0) {
    plainTag = plainTag.concat(createZeroBlock(16));
  } else if (additionalAuthenticatedData.length % 16 !== 0) {
    plainTag = plainTag.concat(createZeroBlock(16 - additionalAuthenticatedData.length % 16));
  }
  plainTag = plainTag.concat(cipherText);
  if (cipherText.length === 0) {
    plainTag = plainTag.concat(createZeroBlock(16));
  } else if (cipherText.length % 16 !== 0) {
    plainTag = plainTag.concat(createZeroBlock(16 - cipherText.length % 16));
  }
  plainTag = plainTag.concat(createZeroBlock(4)).concat(getBytes(additionalAuthenticatedData.length * 8)).concat(createZeroBlock(4)).concat(getBytes(cipherText.length * 8));
  return {
    result: cipherText,
    authenticationTag: gctr(ghash(plainTag, hashSubKey), preCounterBlock, key)
  };
}
function AESGCMDecrypt(cipherText, additionalAuthenticatedData, initializationVector, authenticationTag, key) {
  let preCounterBlock;
  let compareTag;
  const hashSubKey = AES(createZeroBlock(16), key);
  preCounterBlock = [...initializationVector];
  if (initializationVector.length === 12) {
    preCounterBlock = preCounterBlock.concat(createZeroBlock(3)).concat([1]);
  } else {
    if (initializationVector.length % 16 !== 0) {
      preCounterBlock = preCounterBlock.concat(createZeroBlock(16 - initializationVector.length % 16));
    }
    preCounterBlock = preCounterBlock.concat(createZeroBlock(8));
    preCounterBlock = ghash(preCounterBlock.concat(createZeroBlock(4)).concat(getBytes(initializationVector.length * 8)), hashSubKey);
  }
  const plainText = gctr(cipherText, incrementLeastSignificantThirtyTwoBits(preCounterBlock), key);
  compareTag = additionalAuthenticatedData.slice();
  if (additionalAuthenticatedData.length === 0) {
    compareTag = compareTag.concat(createZeroBlock(16));
  } else if (additionalAuthenticatedData.length % 16 !== 0) {
    compareTag = compareTag.concat(createZeroBlock(16 - additionalAuthenticatedData.length % 16));
  }
  compareTag = compareTag.concat(cipherText);
  if (cipherText.length === 0) {
    compareTag = compareTag.concat(createZeroBlock(16));
  } else if (cipherText.length % 16 !== 0) {
    compareTag = compareTag.concat(createZeroBlock(16 - cipherText.length % 16));
  }
  compareTag = compareTag.concat(createZeroBlock(4)).concat(getBytes(additionalAuthenticatedData.length * 8)).concat(createZeroBlock(4)).concat(getBytes(cipherText.length * 8));
  const calculatedTag = gctr(ghash(compareTag, hashSubKey), preCounterBlock, key);
  if (calculatedTag.join() !== authenticationTag.join()) {
    return null;
  }
  return plainText;
}

// node_modules/@bsv/sdk/dist/esm/src/primitives/SymmetricKey.js
var SymmetricKey = class _SymmetricKey extends BigNumber {
  /**
   * Generates a symmetric key randomly.
   *
   * @method fromRandom
   * @static
   * @returns The newly generated Symmetric Key.
   *
   * @example
   * const symmetricKey = SymmetricKey.fromRandom();
   */
  static fromRandom() {
    return new _SymmetricKey(Random_default(32));
  }
  /**
  * Encrypts a given message using AES-GCM encryption.
  * The generated Initialization Vector (IV) is attached to the encrypted message for decryption purposes.
  * The OpenSSL format of |IV|encryptedContent|authTag| is used.
  *
  * @method encrypt
  * @param msg - The message to be encrypted. It can be a string or an array of numbers.
  * @param enc - optional. The encoding of the message. If hex, the string is assumed to be hex, UTF-8 otherwise.
  * @returns Returns the encrypted message as a string or an array of numbers, depending on `enc` argument.
  *
  * @example
  * const key = new SymmetricKey(1234);
  * const encryptedMessage = key.encrypt('plainText', 'utf8');
  */
  encrypt(msg, enc) {
    const iv = Random_default(32);
    msg = toArray2(msg, enc);
    const { result, authenticationTag } = AESGCM(msg, [], iv, this.toArray("be", 32));
    return encode([...iv, ...result, ...authenticationTag], enc);
  }
  /**
   * Decrypts a given AES-GCM encrypted message using the same key that was used for encryption.
   * The method extracts the IV and the authentication tag from the encrypted message, then attempts to decrypt it.
   * If the decryption fails (e.g., due to message tampering), an error is thrown.
   *
   * @method decrypt
   * @param msg - The encrypted message to be decrypted. It can be a string or an array of numbers.
   * @param enc - optional. The encoding of the message (if no encoding is provided, uses utf8 for strings, unless specified as hex).
   * @returns Returns the decrypted message as a string or an array of numbers, depending on `enc` argument. If absent, an array of numbers is returned.
   *
   * @example
   * const key = new SymmetricKey(1234);
   * const decryptedMessage = key.decrypt(encryptedMessage, 'utf8');
   *
   * @throws {Error} Will throw an error if the decryption fails, likely due to message tampering or incorrect decryption key.
   */
  decrypt(msg, enc) {
    msg = toArray2(msg, enc);
    const iv = msg.slice(0, 32);
    const ciphertextWithTag = msg.slice(32);
    const messageTag = ciphertextWithTag.slice(-16);
    const ciphertext = ciphertextWithTag.slice(0, -16);
    const result = AESGCMDecrypt(ciphertext, [], iv, messageTag, this.toArray());
    if (result === null) {
      throw new Error("Decryption failed!");
    }
    return encode(result, enc);
  }
};

// node_modules/@bsv/sdk/dist/esm/src/primitives/TransactionSignature.js
var _TransactionSignature = class _TransactionSignature extends Signature {
  constructor(r2, s2, scope) {
    super(r2, s2);
    __publicField(this, "scope");
    this.scope = scope;
  }
  static format(params) {
    const currentInput = {
      sourceTXID: params.sourceTXID,
      sourceOutputIndex: params.sourceOutputIndex,
      sequence: params.inputSequence
    };
    const inputs = [...params.otherInputs];
    inputs.splice(params.inputIndex, 0, currentInput);
    const getPrevoutHash = () => {
      const writer2 = new Writer();
      for (const input of inputs) {
        if (typeof input.sourceTXID === "undefined") {
          writer2.writeReverse(input.sourceTransaction.id());
        } else {
          writer2.writeReverse(toArray2(input.sourceTXID, "hex"));
        }
        writer2.writeUInt32LE(input.sourceOutputIndex);
      }
      const buf2 = writer2.toArray();
      const ret = hash256(buf2);
      return ret;
    };
    const getSequenceHash = () => {
      const writer2 = new Writer();
      for (const input of inputs) {
        writer2.writeUInt32LE(input.sequence);
      }
      const buf2 = writer2.toArray();
      const ret = hash256(buf2);
      return ret;
    };
    function getOutputsHash(outputIndex) {
      const writer2 = new Writer();
      if (typeof outputIndex === "undefined") {
        let script;
        for (const output of params.outputs) {
          writer2.writeUInt64LE(output.satoshis);
          script = output.lockingScript.toBinary();
          writer2.writeVarIntNum(script.length);
          writer2.write(script);
        }
      } else {
        const output = params.outputs[outputIndex];
        writer2.writeUInt64LE(output.satoshis);
        const script = output.lockingScript.toBinary();
        writer2.writeVarIntNum(script.length);
        writer2.write(script);
      }
      const buf2 = writer2.toArray();
      const ret = hash256(buf2);
      return ret;
    }
    let hashPrevouts = new Array(32).fill(0);
    let hashSequence = new Array(32).fill(0);
    let hashOutputs = new Array(32).fill(0);
    if ((params.scope & _TransactionSignature.SIGHASH_ANYONECANPAY) === 0) {
      hashPrevouts = getPrevoutHash();
    }
    if ((params.scope & _TransactionSignature.SIGHASH_ANYONECANPAY) === 0 && (params.scope & 31) !== _TransactionSignature.SIGHASH_SINGLE && (params.scope & 31) !== _TransactionSignature.SIGHASH_NONE) {
      hashSequence = getSequenceHash();
    }
    if ((params.scope & 31) !== _TransactionSignature.SIGHASH_SINGLE && (params.scope & 31) !== _TransactionSignature.SIGHASH_NONE) {
      hashOutputs = getOutputsHash();
    } else if ((params.scope & 31) === _TransactionSignature.SIGHASH_SINGLE && params.inputIndex < params.outputs.length) {
      hashOutputs = getOutputsHash(params.inputIndex);
    }
    const writer = new Writer();
    writer.writeInt32LE(params.transactionVersion);
    writer.write(hashPrevouts);
    writer.write(hashSequence);
    writer.writeReverse(toArray2(params.sourceTXID, "hex"));
    writer.writeUInt32LE(params.sourceOutputIndex);
    writer.writeVarIntNum(params.subscript.toBinary().length);
    writer.write(params.subscript.toBinary());
    writer.writeUInt64LE(params.sourceSatoshis);
    const sequenceNumber = currentInput.sequence;
    writer.writeUInt32LE(sequenceNumber);
    writer.write(hashOutputs);
    writer.writeUInt32LE(params.lockTime);
    writer.writeUInt32LE(params.scope >>> 0);
    const buf = writer.toArray();
    return buf;
  }
  // The format used in a tx
  static fromChecksigFormat(buf) {
    if (buf.length === 0) {
      const r2 = new BigNumber(1);
      const s2 = new BigNumber(1);
      const scope2 = 1;
      return new _TransactionSignature(r2, s2, scope2);
    }
    const scope = buf[buf.length - 1];
    const derbuf = buf.slice(0, buf.length - 1);
    const tempSig = Signature.fromDER(derbuf);
    return new _TransactionSignature(tempSig.r, tempSig.s, scope);
  }
  /**
     * Compares to bitcoind's IsLowDERSignature
     * See also Ecdsa signature algorithm which enforces this.
     * See also Bip 62, "low S values in signatures"
     */
  hasLowS() {
    if (this.s.ltn(1) || this.s.gt(new BigNumber("7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0", "hex"))) {
      return false;
    }
    return true;
  }
  toChecksigFormat() {
    const derbuf = this.toDER();
    return [...derbuf, this.scope];
  }
};
__publicField(_TransactionSignature, "SIGHASH_ALL", 1);
__publicField(_TransactionSignature, "SIGHASH_NONE", 2);
__publicField(_TransactionSignature, "SIGHASH_SINGLE", 3);
__publicField(_TransactionSignature, "SIGHASH_FORKID", 64);
__publicField(_TransactionSignature, "SIGHASH_ANYONECANPAY", 128);
var TransactionSignature = _TransactionSignature;

// node_modules/@bsv/sdk/dist/esm/src/script/OP.js
var OP = {
  // push value
  OP_FALSE: 0,
  OP_0: 0,
  OP_PUSHDATA1: 76,
  OP_PUSHDATA2: 77,
  OP_PUSHDATA4: 78,
  OP_1NEGATE: 79,
  OP_RESERVED: 80,
  OP_TRUE: 81,
  OP_1: 81,
  OP_2: 82,
  OP_3: 83,
  OP_4: 84,
  OP_5: 85,
  OP_6: 86,
  OP_7: 87,
  OP_8: 88,
  OP_9: 89,
  OP_10: 90,
  OP_11: 91,
  OP_12: 92,
  OP_13: 93,
  OP_14: 94,
  OP_15: 95,
  OP_16: 96,
  // control
  OP_NOP: 97,
  OP_VER: 98,
  OP_IF: 99,
  OP_NOTIF: 100,
  OP_VERIF: 101,
  OP_VERNOTIF: 102,
  OP_ELSE: 103,
  OP_ENDIF: 104,
  OP_VERIFY: 105,
  OP_RETURN: 106,
  // stack ops
  OP_TOALTSTACK: 107,
  OP_FROMALTSTACK: 108,
  OP_2DROP: 109,
  OP_2DUP: 110,
  OP_3DUP: 111,
  OP_2OVER: 112,
  OP_2ROT: 113,
  OP_2SWAP: 114,
  OP_IFDUP: 115,
  OP_DEPTH: 116,
  OP_DROP: 117,
  OP_DUP: 118,
  OP_NIP: 119,
  OP_OVER: 120,
  OP_PICK: 121,
  OP_ROLL: 122,
  OP_ROT: 123,
  OP_SWAP: 124,
  OP_TUCK: 125,
  // data manipulation ops
  OP_CAT: 126,
  OP_SUBSTR: 127,
  OP_SPLIT: 127,
  OP_LEFT: 128,
  OP_NUM2BIN: 128,
  OP_RIGHT: 129,
  OP_BIN2NUM: 129,
  OP_SIZE: 130,
  // bit logic
  OP_INVERT: 131,
  OP_AND: 132,
  OP_OR: 133,
  OP_XOR: 134,
  OP_EQUAL: 135,
  OP_EQUALVERIFY: 136,
  OP_RESERVED1: 137,
  OP_RESERVED2: 138,
  // numeric
  OP_1ADD: 139,
  OP_1SUB: 140,
  OP_2MUL: 141,
  OP_2DIV: 142,
  OP_NEGATE: 143,
  OP_ABS: 144,
  OP_NOT: 145,
  OP_0NOTEQUAL: 146,
  OP_ADD: 147,
  OP_SUB: 148,
  OP_MUL: 149,
  OP_DIV: 150,
  OP_MOD: 151,
  OP_LSHIFT: 152,
  OP_RSHIFT: 153,
  OP_BOOLAND: 154,
  OP_BOOLOR: 155,
  OP_NUMEQUAL: 156,
  OP_NUMEQUALVERIFY: 157,
  OP_NUMNOTEQUAL: 158,
  OP_LESSTHAN: 159,
  OP_GREATERTHAN: 160,
  OP_LESSTHANOREQUAL: 161,
  OP_GREATERTHANOREQUAL: 162,
  OP_MIN: 163,
  OP_MAX: 164,
  OP_WITHIN: 165,
  // crypto
  OP_RIPEMD160: 166,
  OP_SHA1: 167,
  OP_SHA256: 168,
  OP_HASH160: 169,
  OP_HASH256: 170,
  OP_CODESEPARATOR: 171,
  OP_CHECKSIG: 172,
  OP_CHECKSIGVERIFY: 173,
  OP_CHECKMULTISIG: 174,
  OP_CHECKMULTISIGVERIFY: 175,
  // expansion
  OP_NOP1: 176,
  OP_NOP2: 177,
  OP_NOP3: 178,
  OP_NOP4: 179,
  OP_NOP5: 180,
  OP_NOP6: 181,
  OP_NOP7: 182,
  OP_NOP8: 183,
  OP_NOP9: 184,
  OP_NOP10: 185,
  OP_NOP11: 186,
  OP_NOP12: 187,
  OP_NOP13: 188,
  OP_NOP14: 189,
  OP_NOP15: 190,
  OP_NOP16: 191,
  OP_NOP17: 192,
  OP_NOP18: 193,
  OP_NOP19: 194,
  OP_NOP20: 195,
  OP_NOP21: 196,
  OP_NOP22: 197,
  OP_NOP23: 198,
  OP_NOP24: 199,
  OP_NOP25: 200,
  OP_NOP26: 201,
  OP_NOP27: 202,
  OP_NOP28: 203,
  OP_NOP29: 204,
  OP_NOP30: 205,
  OP_NOP31: 206,
  OP_NOP32: 207,
  OP_NOP33: 208,
  OP_NOP34: 209,
  OP_NOP35: 210,
  OP_NOP36: 211,
  OP_NOP37: 212,
  OP_NOP38: 213,
  OP_NOP39: 214,
  OP_NOP40: 215,
  OP_NOP41: 216,
  OP_NOP42: 217,
  OP_NOP43: 218,
  OP_NOP44: 219,
  OP_NOP45: 220,
  OP_NOP46: 221,
  OP_NOP47: 222,
  OP_NOP48: 223,
  OP_NOP49: 224,
  OP_NOP50: 225,
  OP_NOP51: 226,
  OP_NOP52: 227,
  OP_NOP53: 228,
  OP_NOP54: 229,
  OP_NOP55: 230,
  OP_NOP56: 231,
  OP_NOP57: 232,
  OP_NOP58: 233,
  OP_NOP59: 234,
  OP_NOP60: 235,
  OP_NOP61: 236,
  OP_NOP62: 237,
  OP_NOP63: 238,
  OP_NOP64: 239,
  OP_NOP65: 240,
  OP_NOP66: 241,
  OP_NOP67: 242,
  OP_NOP68: 243,
  OP_NOP69: 244,
  OP_NOP70: 245,
  OP_NOP71: 246,
  OP_NOP72: 247,
  OP_NOP73: 248,
  OP_NOP77: 252,
  // template matching params
  OP_SMALLDATA: 249,
  OP_SMALLINTEGER: 250,
  OP_PUBKEYS: 251,
  OP_PUBKEYHASH: 253,
  OP_PUBKEY: 254,
  OP_INVALIDOPCODE: 255
};
for (const name in OP) {
  OP[OP[name]] = name;
}
var OP_default = OP;

// node_modules/@bsv/sdk/dist/esm/src/script/Script.js
var Script = class _Script {
  /**
   * @constructor
   * Constructs a new Script object.
   * @param chunks=[] - An array of script chunks to directly initialize the script.
   */
  constructor(chunks = []) {
    __publicField(this, "chunks");
    this.chunks = chunks;
  }
  /**
   * @method fromASM
   * Static method to construct a Script instance from an ASM (Assembly) formatted string.
   * @param asm - The script in ASM string format.
   * @returns A new Script instance.
   * @example
   * const script = Script.fromASM("OP_DUP OP_HASH160 abcd... OP_EQUALVERIFY OP_CHECKSIG")
   */
  static fromASM(asm) {
    const chunks = [];
    const tokens = asm.split(" ");
    let i = 0;
    while (i < tokens.length) {
      const token = tokens[i];
      let opCode;
      let opCodeNum;
      if (token.startsWith("OP_") && typeof OP_default[token] !== "undefined") {
        opCode = token;
        opCodeNum = OP_default[token];
      }
      if (token === "0") {
        opCodeNum = 0;
        chunks.push({
          op: opCodeNum
        });
        i = i + 1;
      } else if (token === "-1") {
        opCodeNum = OP_default.OP_1NEGATE;
        chunks.push({
          op: opCodeNum
        });
        i = i + 1;
      } else if (opCode === void 0) {
        let hex = tokens[i];
        if (hex.length % 2 !== 0) {
          hex = "0" + hex;
        }
        const arr = toArray2(hex, "hex");
        if (encode(arr, "hex") !== hex) {
          throw new Error("invalid hex string in script");
        }
        const len = arr.length;
        if (len >= 0 && len < OP_default.OP_PUSHDATA1) {
          opCodeNum = len;
        } else if (len < Math.pow(2, 8)) {
          opCodeNum = OP_default.OP_PUSHDATA1;
        } else if (len < Math.pow(2, 16)) {
          opCodeNum = OP_default.OP_PUSHDATA2;
        } else if (len < Math.pow(2, 32)) {
          opCodeNum = OP_default.OP_PUSHDATA4;
        }
        chunks.push({
          data: arr,
          op: opCodeNum
        });
        i = i + 1;
      } else if (opCodeNum === OP_default.OP_PUSHDATA1 || opCodeNum === OP_default.OP_PUSHDATA2 || opCodeNum === OP_default.OP_PUSHDATA4) {
        chunks.push({
          data: toArray2(tokens[i + 2], "hex"),
          op: opCodeNum
        });
        i = i + 3;
      } else {
        chunks.push({
          op: opCodeNum
        });
        i = i + 1;
      }
    }
    return new _Script(chunks);
  }
  /**
   * @method fromHex
   * Static method to construct a Script instance from a hexadecimal string.
   * @param hex - The script in hexadecimal format.
   * @returns A new Script instance.
   * @example
   * const script = Script.fromHex("76a9...");
   */
  static fromHex(hex) {
    if (hex.length === 0)
      return _Script.fromBinary([]);
    if (hex.length % 2 !== 0)
      throw new Error("There is an uneven number of characters in the string which suggests it is not hex encoded.");
    if (!/^[0-9a-fA-F]+$/.test(hex))
      throw new Error("Some elements in this string are not hex encoded.");
    return _Script.fromBinary(toArray2(hex, "hex"));
  }
  /**
   * @method fromBinary
   * Static method to construct a Script instance from a binary array.
   * @param bin - The script in binary array format.
   * @returns A new Script instance.
   * @example
   * const script = Script.fromBinary([0x76, 0xa9, ...])
   */
  static fromBinary(bin) {
    bin = [...bin];
    const chunks = [];
    const br = new Reader(bin);
    while (!br.eof()) {
      const op = br.readUInt8();
      let len = 0;
      let data = [];
      if (op > 0 && op < OP_default.OP_PUSHDATA1) {
        len = op;
        chunks.push({
          data: br.read(len),
          op
        });
      } else if (op === OP_default.OP_PUSHDATA1) {
        try {
          len = br.readUInt8();
          data = br.read(len);
        } catch (err) {
          br.read();
        }
        chunks.push({
          data,
          op
        });
      } else if (op === OP_default.OP_PUSHDATA2) {
        try {
          len = br.readUInt16LE();
          data = br.read(len);
        } catch (err) {
          br.read();
        }
        chunks.push({
          data,
          op
        });
      } else if (op === OP_default.OP_PUSHDATA4) {
        try {
          len = br.readUInt32LE();
          data = br.read(len);
        } catch (err) {
          br.read();
        }
        chunks.push({
          data,
          op
        });
      } else {
        chunks.push({
          op
        });
      }
    }
    return new _Script(chunks);
  }
  /**
   * @method toASM
   * Serializes the script to an ASM formatted string.
   * @returns The script in ASM string format.
   */
  toASM() {
    let str = "";
    for (let i = 0; i < this.chunks.length; i++) {
      const chunk = this.chunks[i];
      str += this._chunkToString(chunk);
    }
    return str.slice(1);
  }
  /**
   * @method toHex
   * Serializes the script to a hexadecimal string.
   * @returns The script in hexadecimal format.
   */
  toHex() {
    return encode(this.toBinary(), "hex");
  }
  /**
   * @method toBinary
   * Serializes the script to a binary array.
   * @returns The script in binary array format.
   */
  toBinary() {
    const writer = new Writer();
    for (let i = 0; i < this.chunks.length; i++) {
      const chunk = this.chunks[i];
      const op = chunk.op;
      writer.writeUInt8(op);
      if (chunk.data) {
        if (op < OP_default.OP_PUSHDATA1) {
          writer.write(chunk.data);
        } else if (op === OP_default.OP_PUSHDATA1) {
          writer.writeUInt8(chunk.data.length);
          writer.write(chunk.data);
        } else if (op === OP_default.OP_PUSHDATA2) {
          writer.writeUInt16LE(chunk.data.length);
          writer.write(chunk.data);
        } else if (op === OP_default.OP_PUSHDATA4) {
          writer.writeUInt32LE(chunk.data.length);
          writer.write(chunk.data);
        }
      }
    }
    return writer.toArray();
  }
  /**
   * @method writeScript
   * Appends another script to this script.
   * @param script - The script to append.
   * @returns This script instance for chaining.
   */
  writeScript(script) {
    this.chunks = this.chunks.concat(script.chunks);
    return this;
  }
  /**
   * @method writeOpCode
   * Appends an opcode to the script.
   * @param op - The opcode to append.
   * @returns This script instance for chaining.
   */
  writeOpCode(op) {
    this.chunks.push({ op });
    return this;
  }
  /**
   * @method setChunkOpCode
   * Sets the opcode of a specific chunk in the script.
   * @param i - The index of the chunk.
   * @param op - The opcode to set.
   * @returns This script instance for chaining.
   */
  setChunkOpCode(i, op) {
    this.chunks[i] = { op };
    return this;
  }
  /**
   * @method writeBn
  * Appends a BigNumber to the script as an opcode.
  * @param bn - The BigNumber to append.
  * @returns This script instance for chaining.
   */
  writeBn(bn) {
    if (bn.cmpn(0) === OP_default.OP_0) {
      this.chunks.push({
        op: OP_default.OP_0
      });
    } else if (bn.cmpn(-1) === 0) {
      this.chunks.push({
        op: OP_default.OP_1NEGATE
      });
    } else if (bn.cmpn(1) >= 0 && bn.cmpn(16) <= 0) {
      this.chunks.push({
        op: bn.toNumber() + OP_default.OP_1 - 1
      });
    } else {
      const buf = bn.toSm("little");
      this.writeBin(buf);
    }
    return this;
  }
  /**
   * @method writeBin
   * Appends binary data to the script, determining the appropriate opcode based on length.
   * @param bin - The binary data to append.
   * @returns This script instance for chaining.
   * @throws {Error} Throws an error if the data is too large to be pushed.
   */
  writeBin(bin) {
    let op;
    if (bin.length > 0 && bin.length < OP_default.OP_PUSHDATA1) {
      op = bin.length;
    } else if (bin.length === 0) {
      op = OP_default.OP_0;
    } else if (bin.length < Math.pow(2, 8)) {
      op = OP_default.OP_PUSHDATA1;
    } else if (bin.length < Math.pow(2, 16)) {
      op = OP_default.OP_PUSHDATA2;
    } else if (bin.length < Math.pow(2, 32)) {
      op = OP_default.OP_PUSHDATA4;
    } else {
      throw new Error("You can't push that much data");
    }
    this.chunks.push({
      data: bin,
      op
    });
    return this;
  }
  /**
   * @method writeNumber
   * Appends a number to the script.
   * @param num - The number to append.
   * @returns This script instance for chaining.
   */
  writeNumber(num) {
    this.writeBn(new BigNumber(num));
    return this;
  }
  /**
   * @method removeCodeseparators
   * Removes all OP_CODESEPARATOR opcodes from the script.
   * @returns This script instance for chaining.
   */
  removeCodeseparators() {
    const chunks = [];
    for (let i = 0; i < this.chunks.length; i++) {
      if (this.chunks[i].op !== OP_default.OP_CODESEPARATOR) {
        chunks.push(this.chunks[i]);
      }
    }
    this.chunks = chunks;
    return this;
  }
  /**
   * Deletes the given item wherever it appears in the current script.
   *
   * @param script - The script containing the item to delete from the current script.
   *
   * @returns This script instance for chaining.
   */
  findAndDelete(script) {
    const buf = script.toHex();
    for (let i = 0; i < this.chunks.length; i++) {
      const script2 = new _Script([this.chunks[i]]);
      const buf2 = script2.toHex();
      if (buf === buf2) {
        this.chunks.splice(i, 1);
      }
    }
    return this;
  }
  /**
   * @method isPushOnly
   * Checks if the script contains only push data operations.
   * @returns True if the script is push-only, otherwise false.
   */
  isPushOnly() {
    for (let i = 0; i < this.chunks.length; i++) {
      const chunk = this.chunks[i];
      const opCodeNum = chunk.op;
      if (opCodeNum > OP_default.OP_16) {
        return false;
      }
    }
    return true;
  }
  /**
   * @method isLockingScript
   * Determines if the script is a locking script.
   * @returns True if the script is a locking script, otherwise false.
   */
  isLockingScript() {
    throw new Error("Not implemented");
  }
  /**
   * @method isUnlockingScript
   * Determines if the script is an unlocking script.
   * @returns True if the script is an unlocking script, otherwise false.
   */
  isUnlockingScript() {
    throw new Error("Not implemented");
  }
  /**
   * @private
   * @method _chunkToString
   * Converts a script chunk to its string representation.
   * @param chunk - The script chunk.
   * @returns The string representation of the chunk.
   */
  _chunkToString(chunk) {
    const op = chunk.op;
    let str = "";
    if (typeof chunk.data === "undefined") {
      const val = OP_default[op];
      str = `${str} ${val}`;
    } else {
      str = `${str} ${toHex(chunk.data)}`;
    }
    return str;
  }
};

// node_modules/@bsv/sdk/dist/esm/src/script/LockingScript.js
var LockingScript = class extends Script {
  /**
   * @method isLockingScript
   * Determines if the script is a locking script.
   * @returns {boolean} Always returns true for a LockingScript instance.
   */
  isLockingScript() {
    return true;
  }
  /**
   * @method isUnlockingScript
   * Determines if the script is an unlocking script.
   * @returns {boolean} Always returns false for a LockingScript instance.
   */
  isUnlockingScript() {
    return false;
  }
};

// node_modules/@bsv/sdk/dist/esm/src/script/UnlockingScript.js
var UnlockingScript = class extends Script {
  /**
   * @method isLockingScript
   * Determines if the script is a locking script.
   * @returns {boolean} Always returns false for an UnlockingScript instance.
   */
  isLockingScript() {
    return false;
  }
  /**
   * @method isUnlockingScript
   * Determines if the script is an unlocking script.
   * @returns {boolean} Always returns true for an UnlockingScript instance.
   */
  isUnlockingScript() {
    return true;
  }
};

// node_modules/@bsv/sdk/dist/esm/src/script/Spend.js
var maxScriptElementSize = 1024 * 1024 * 1024;
var maxMultisigKeyCount = Math.pow(2, 31) - 1;
var requireMinimalPush = true;
var requirePushOnlyUnlockingScripts = true;
var requireLowSSignatures = true;
var requireCleanStack = true;
var Spend = class {
  /**
   * @constructor
   * Constructs the Spend object with necessary transaction details.
   * @param {string} params.sourceTXID - The transaction ID of the source UTXO.
   * @param {number} params.sourceOutputIndex - The index of the output in the source transaction.
   * @param {BigNumber} params.sourceSatoshis - The amount of satoshis in the source UTXO.
   * @param {LockingScript} params.lockingScript - The locking script associated with the UTXO.
   * @param {number} params.transactionVersion - The version of the current transaction.
   * @param {Array<{ sourceTXID: string, sourceOutputIndex: number, sequence: number }>} params.otherInputs -
   *        An array of other inputs in the transaction.
   * @param {Array<{ satoshis: BigNumber, lockingScript: LockingScript }>} params.outputs -
   *        The outputs of the current transaction.
   * @param {number} params.inputIndex - The index of this input in the current transaction.
   * @param {UnlockingScript} params.unlockingScript - The unlocking script for this spend.
   * @param {number} params.inputSequence - The sequence number of this input.
   * @param {number} params.lockTime - The lock time of the transaction.
   *
   * @example
   * const spend = new Spend({
   *   sourceTXID: "abcd1234", // sourceTXID
   *   sourceOutputIndex: 0, // sourceOutputIndex
   *   sourceSatoshis: new BigNumber(1000), // sourceSatoshis
   *   lockingScript: LockingScript.fromASM("OP_DUP OP_HASH160 abcd1234... OP_EQUALVERIFY OP_CHECKSIG"),
   *   transactionVersion: 1, // transactionVersion
   *   otherInputs: [{ sourceTXID: "abcd1234", sourceOutputIndex: 1, sequence: 0xffffffff }], // otherInputs
   *   outputs: [{ satoshis: new BigNumber(500), lockingScript: LockingScript.fromASM("OP_DUP...") }], // outputs
   *   inputIndex: 0, // inputIndex
   *   unlockingScript: UnlockingScript.fromASM("3045... 02ab..."),
   *   inputSequence: 0xffffffff // inputSequence
   * });
   */
  constructor(params) {
    __publicField(this, "sourceTXID");
    __publicField(this, "sourceOutputIndex");
    __publicField(this, "sourceSatoshis");
    __publicField(this, "lockingScript");
    __publicField(this, "transactionVersion");
    __publicField(this, "otherInputs");
    __publicField(this, "outputs");
    __publicField(this, "inputIndex");
    __publicField(this, "unlockingScript");
    __publicField(this, "inputSequence");
    __publicField(this, "lockTime");
    __publicField(this, "context");
    __publicField(this, "programCounter");
    __publicField(this, "lastCodeSeparator");
    __publicField(this, "stack");
    __publicField(this, "altStack");
    __publicField(this, "ifStack");
    this.sourceTXID = params.sourceTXID;
    this.sourceOutputIndex = params.sourceOutputIndex;
    this.sourceSatoshis = params.sourceSatoshis;
    this.lockingScript = params.lockingScript;
    this.transactionVersion = params.transactionVersion;
    this.otherInputs = params.otherInputs;
    this.outputs = params.outputs;
    this.inputIndex = params.inputIndex;
    this.unlockingScript = params.unlockingScript;
    this.inputSequence = params.inputSequence;
    this.lockTime = params.lockTime;
    this.reset();
  }
  reset() {
    this.context = "UnlockingScript";
    this.programCounter = 0;
    this.lastCodeSeparator = null;
    this.stack = [];
    this.altStack = [];
    this.ifStack = [];
  }
  step() {
    if (this.context === "UnlockingScript" && this.programCounter >= this.unlockingScript.chunks.length) {
      this.context = "LockingScript";
      this.programCounter = 0;
    }
    let operation;
    if (this.context === "UnlockingScript") {
      operation = this.unlockingScript.chunks[this.programCounter];
    } else {
      operation = this.lockingScript.chunks[this.programCounter];
    }
    const isOpcodeDisabled = (op) => {
      return op === OP_default.OP_2MUL || op === OP_default.OP_2DIV || op === OP_default.OP_VERIF || op === OP_default.OP_VERNOTIF || op === OP_default.OP_VER;
    };
    const isChunkMinimal = (chunk) => {
      const data = chunk.data;
      const op = chunk.op;
      if (!Array.isArray(data)) {
        return true;
      }
      if (data.length === 0) {
        return op === OP_default.OP_0;
      } else if (data.length === 1 && data[0] >= 1 && data[0] <= 16) {
        return op === OP_default.OP_1 + (data[0] - 1);
      } else if (data.length === 1 && data[0] === 129) {
        return op === OP_default.OP_1NEGATE;
      } else if (data.length <= 75) {
        return op === data.length;
      } else if (data.length <= 255) {
        return op === OP_default.OP_PUSHDATA1;
      } else if (data.length <= 65535) {
        return op === OP_default.OP_PUSHDATA2;
      }
      return true;
    };
    const isMinimallyEncoded = (buf4, maxNumSize = Number.MAX_SAFE_INTEGER) => {
      if (buf4.length > maxNumSize) {
        return false;
      }
      if (buf4.length > 0) {
        if ((buf4[buf4.length - 1] & 127) === 0) {
          if (buf4.length <= 1 || (buf4[buf4.length - 2] & 128) === 0) {
            return false;
          }
        }
      }
      return true;
    };
    const minimallyEncode = (buf4) => {
      if (buf4.length === 0) {
        return buf4;
      }
      const last = buf4[buf4.length - 1];
      if ((last & 127) !== 0) {
        return buf4;
      }
      if (buf4.length === 1) {
        return [];
      }
      if ((buf4[buf4.length - 2] & 128) !== 0) {
        return buf4;
      }
      for (let i2 = buf4.length - 1; i2 > 0; i2--) {
        if (buf4[i2 - 1] !== 0) {
          if ((buf4[i2 - 1] & 128) !== 0) {
            buf4[i2++] = last;
          } else {
            buf4[i2 - 1] |= last;
          }
          return buf4.slice(0, i2);
        }
      }
      return [];
    };
    const padDataToSize = (buf4, len) => {
      let b = buf4;
      while (b.length < len) {
        b = [0, ...b];
      }
      return b;
    };
    const isChecksigFormat = (buf4) => {
      if (buf4.length < 9) {
        return false;
      }
      if (buf4.length > 73) {
        return false;
      }
      if (buf4[0] !== 48) {
        return false;
      }
      if (buf4[1] !== buf4.length - 3) {
        return false;
      }
      const nLEnR = buf4[3];
      if (5 + nLEnR >= buf4.length) {
        return false;
      }
      const nLEnS = buf4[5 + nLEnR];
      if (nLEnR + nLEnS + 7 !== buf4.length) {
        return false;
      }
      const R2 = buf4.slice(4);
      if (buf4[4 - 2] !== 2) {
        return false;
      }
      if (nLEnR === 0) {
        return false;
      }
      if ((R2[0] & 128) !== 0) {
        return false;
      }
      if (nLEnR > 1 && R2[0] === 0 && (R2[1] & 128) === 0) {
        return false;
      }
      const S = buf4.slice(6 + nLEnR);
      if (buf4[6 + nLEnR - 2] !== 2) {
        return false;
      }
      if (nLEnS === 0) {
        return false;
      }
      if ((S[0] & 128) !== 0) {
        return false;
      }
      if (nLEnS > 1 && S[0] === 0 && (S[1] & 128) === 0) {
        return false;
      }
      return true;
    };
    const checkSignatureEncoding = (buf4) => {
      if (buf4.length === 0) {
        return true;
      }
      if (!isChecksigFormat(buf4)) {
        this.scriptEvaluationError("The signature format is invalid.");
      }
      const sig2 = TransactionSignature.fromChecksigFormat(buf4);
      if (requireLowSSignatures && !sig2.hasLowS()) {
        this.scriptEvaluationError("The signature must have a low S value.");
      }
      if ((sig2.scope & TransactionSignature.SIGHASH_FORKID) === 0) {
        this.scriptEvaluationError("The signature must use SIGHASH_FORKID.");
        return false;
      }
      return true;
    };
    const checkPublicKeyEncoding = (buf4) => {
      if (buf4.length < 33) {
        this.scriptEvaluationError("The public key is too short, it must be at least 33 bytes.");
      }
      if (buf4[0] === 4) {
        if (buf4.length !== 65) {
          this.scriptEvaluationError("The non-compressed public key must be 65 bytes.");
        }
      } else if (buf4[0] === 2 || buf4[0] === 3) {
        if (buf4.length !== 33) {
          this.scriptEvaluationError("The compressed public key must be 33 bytes.");
        }
      } else {
        this.scriptEvaluationError("The public key is in an unknown format.");
      }
      return true;
    };
    const verifySignature = (sig2, pubkey2, subscript2) => {
      const preimage = TransactionSignature.format({
        sourceTXID: this.sourceTXID,
        sourceOutputIndex: this.sourceOutputIndex,
        sourceSatoshis: this.sourceSatoshis,
        transactionVersion: this.transactionVersion,
        otherInputs: this.otherInputs,
        outputs: this.outputs,
        inputIndex: this.inputIndex,
        subscript: subscript2,
        inputSequence: this.inputSequence,
        lockTime: this.lockTime,
        scope: sig2.scope
      });
      const hash = new BigNumber(hash256(preimage));
      return verify(hash, sig2, pubkey2);
    };
    const isScriptExecuting = !this.ifStack.includes(false);
    let buf, buf1, buf2, buf3, spliced, n, size, rawnum, num, signbit, x1, x2, x3, bn, bn1, bn2, bn3, bufSig, bufPubkey, subscript, bufHash;
    let sig, pubkey, i, fOk, nKeysCount, ikey, ikey2, nSigsCount, isig;
    let fValue, fEqual, fSuccess;
    const currentOpcode = operation.op;
    if (typeof currentOpcode === "undefined") {
      this.scriptEvaluationError(`An opcode is missing in this chunk of the ${this.context}!`);
    }
    if (Array.isArray(operation.data) && operation.data.length > maxScriptElementSize) {
      this.scriptEvaluationError(`It's not currently possible to push data larger than ${maxScriptElementSize} bytes.`);
    }
    if (isScriptExecuting && isOpcodeDisabled(currentOpcode)) {
      this.scriptEvaluationError("This opcode is currently disabled.");
    }
    if (isScriptExecuting && currentOpcode >= 0 && currentOpcode <= OP_default.OP_PUSHDATA4) {
      if (requireMinimalPush && !isChunkMinimal(operation)) {
        this.scriptEvaluationError("This data is not minimally-encoded.");
      }
      if (!Array.isArray(operation.data)) {
        this.stack.push([]);
      } else {
        this.stack.push(operation.data);
      }
    } else if (isScriptExecuting || OP_default.OP_IF <= currentOpcode && currentOpcode <= OP_default.OP_ENDIF) {
      switch (currentOpcode) {
        case OP_default.OP_1NEGATE:
        case OP_default.OP_1:
        case OP_default.OP_2:
        case OP_default.OP_3:
        case OP_default.OP_4:
        case OP_default.OP_5:
        case OP_default.OP_6:
        case OP_default.OP_7:
        case OP_default.OP_8:
        case OP_default.OP_9:
        case OP_default.OP_10:
        case OP_default.OP_11:
        case OP_default.OP_12:
        case OP_default.OP_13:
        case OP_default.OP_14:
        case OP_default.OP_15:
        case OP_default.OP_16:
          n = currentOpcode - (OP_default.OP_1 - 1);
          buf = new BigNumber(n).toScriptNum();
          this.stack.push(buf);
          break;
        case OP_default.OP_NOP:
        case OP_default.OP_NOP2:
        case OP_default.OP_NOP3:
        case OP_default.OP_NOP1:
        case OP_default.OP_NOP4:
        case OP_default.OP_NOP5:
        case OP_default.OP_NOP6:
        case OP_default.OP_NOP7:
        case OP_default.OP_NOP8:
        case OP_default.OP_NOP9:
        case OP_default.OP_NOP10:
        case OP_default.OP_NOP11:
        case OP_default.OP_NOP12:
        case OP_default.OP_NOP13:
        case OP_default.OP_NOP14:
        case OP_default.OP_NOP15:
        case OP_default.OP_NOP16:
        case OP_default.OP_NOP17:
        case OP_default.OP_NOP18:
        case OP_default.OP_NOP19:
        case OP_default.OP_NOP20:
        case OP_default.OP_NOP21:
        case OP_default.OP_NOP22:
        case OP_default.OP_NOP23:
        case OP_default.OP_NOP24:
        case OP_default.OP_NOP25:
        case OP_default.OP_NOP26:
        case OP_default.OP_NOP27:
        case OP_default.OP_NOP28:
        case OP_default.OP_NOP29:
        case OP_default.OP_NOP30:
        case OP_default.OP_NOP31:
        case OP_default.OP_NOP32:
        case OP_default.OP_NOP33:
        case OP_default.OP_NOP34:
        case OP_default.OP_NOP35:
        case OP_default.OP_NOP36:
        case OP_default.OP_NOP37:
        case OP_default.OP_NOP38:
        case OP_default.OP_NOP39:
        case OP_default.OP_NOP40:
        case OP_default.OP_NOP41:
        case OP_default.OP_NOP42:
        case OP_default.OP_NOP43:
        case OP_default.OP_NOP44:
        case OP_default.OP_NOP45:
        case OP_default.OP_NOP46:
        case OP_default.OP_NOP47:
        case OP_default.OP_NOP48:
        case OP_default.OP_NOP49:
        case OP_default.OP_NOP50:
        case OP_default.OP_NOP51:
        case OP_default.OP_NOP52:
        case OP_default.OP_NOP53:
        case OP_default.OP_NOP54:
        case OP_default.OP_NOP55:
        case OP_default.OP_NOP56:
        case OP_default.OP_NOP57:
        case OP_default.OP_NOP58:
        case OP_default.OP_NOP59:
        case OP_default.OP_NOP60:
        case OP_default.OP_NOP61:
        case OP_default.OP_NOP62:
        case OP_default.OP_NOP63:
        case OP_default.OP_NOP64:
        case OP_default.OP_NOP65:
        case OP_default.OP_NOP66:
        case OP_default.OP_NOP67:
        case OP_default.OP_NOP68:
        case OP_default.OP_NOP69:
        case OP_default.OP_NOP70:
        case OP_default.OP_NOP71:
        case OP_default.OP_NOP72:
        case OP_default.OP_NOP73:
        case OP_default.OP_NOP77:
          break;
        case OP_default.OP_IF:
        case OP_default.OP_NOTIF:
          fValue = false;
          if (isScriptExecuting) {
            if (this.stack.length < 1) {
              this.scriptEvaluationError("OP_IF and OP_NOTIF require at least one item on the stack when they are used!");
            }
            buf = this.stacktop(-1);
            fValue = this.castToBool(buf);
            if (currentOpcode === OP_default.OP_NOTIF) {
              fValue = !fValue;
            }
            this.stack.pop();
          }
          this.ifStack.push(fValue);
          break;
        case OP_default.OP_ELSE:
          if (this.ifStack.length === 0) {
            this.scriptEvaluationError("OP_ELSE requires a preceeding OP_IF.");
          }
          this.ifStack[this.ifStack.length - 1] = !this.ifStack[this.ifStack.length - 1];
          break;
        case OP_default.OP_ENDIF:
          if (this.ifStack.length === 0) {
            this.scriptEvaluationError("OP_ENDIF requires a preceeding OP_IF.");
          }
          this.ifStack.pop();
          break;
        case OP_default.OP_VERIFY:
          if (this.stack.length < 1) {
            this.scriptEvaluationError("OP_VERIFY requires at least one item to be on the stack.");
          }
          buf = this.stacktop(-1);
          fValue = this.castToBool(buf);
          if (fValue) {
            this.stack.pop();
          } else {
            this.scriptEvaluationError("OP_VERIFY requires the top stack value to be truthy.");
          }
          break;
        case OP_default.OP_RETURN:
          if (this.context === "UnlockingScript") {
            this.programCounter = this.unlockingScript.chunks.length;
          } else {
            this.programCounter = this.lockingScript.chunks.length;
          }
          this.ifStack = [];
          break;
        case OP_default.OP_TOALTSTACK:
          if (this.stack.length < 1) {
            this.scriptEvaluationError("OP_TOALTSTACK requires at oeast one item to be on the stack.");
          }
          this.altStack.push(this.stack.pop());
          break;
        case OP_default.OP_FROMALTSTACK:
          if (this.altStack.length < 1) {
            this.scriptEvaluationError("OP_FROMALTSTACK requires at least one item to be on the stack.");
          }
          this.stack.push(this.altStack.pop());
          break;
        case OP_default.OP_2DROP:
          if (this.stack.length < 2) {
            this.scriptEvaluationError("OP_2DROP requires at least two items to be on the stack.");
          }
          this.stack.pop();
          this.stack.pop();
          break;
        case OP_default.OP_2DUP:
          if (this.stack.length < 2) {
            this.scriptEvaluationError("OP_2DUP requires at least two items to be on the stack.");
          }
          buf1 = this.stacktop(-2);
          buf2 = this.stacktop(-1);
          this.stack.push([...buf1]);
          this.stack.push([...buf2]);
          break;
        case OP_default.OP_3DUP:
          if (this.stack.length < 3) {
            this.scriptEvaluationError("OP_3DUP requires at least three items to be on the stack.");
          }
          buf1 = this.stacktop(-3);
          buf2 = this.stacktop(-2);
          buf3 = this.stacktop(-1);
          this.stack.push([...buf1]);
          this.stack.push([...buf2]);
          this.stack.push([...buf3]);
          break;
        case OP_default.OP_2OVER:
          if (this.stack.length < 4) {
            this.scriptEvaluationError("OP_2OVER requires at least four items to be on the stack.");
          }
          buf1 = this.stacktop(-4);
          buf2 = this.stacktop(-3);
          this.stack.push([...buf1]);
          this.stack.push([...buf2]);
          break;
        case OP_default.OP_2ROT:
          if (this.stack.length < 6) {
            this.scriptEvaluationError("OP_2ROT requires at least six items to be on the stack.");
          }
          spliced = this.stack.splice(this.stack.length - 6, 2);
          this.stack.push(spliced[0]);
          this.stack.push(spliced[1]);
          break;
        case OP_default.OP_2SWAP:
          if (this.stack.length < 4) {
            this.scriptEvaluationError("OP_2SWAP requires at least four items to be on the stack.");
          }
          spliced = this.stack.splice(this.stack.length - 4, 2);
          this.stack.push(spliced[0]);
          this.stack.push(spliced[1]);
          break;
        case OP_default.OP_IFDUP:
          if (this.stack.length < 1) {
            this.scriptEvaluationError("OP_IFDUP requires at least one item to be on the stack.");
          }
          buf = this.stacktop(-1);
          fValue = this.castToBool(buf);
          if (fValue) {
            this.stack.push([...buf]);
          }
          break;
        case OP_default.OP_DEPTH:
          buf = new BigNumber(this.stack.length).toScriptNum();
          this.stack.push(buf);
          break;
        case OP_default.OP_DROP:
          if (this.stack.length < 1) {
            this.scriptEvaluationError("OP_DROP requires at least one item to be on the stack.");
          }
          this.stack.pop();
          break;
        case OP_default.OP_DUP:
          if (this.stack.length < 1) {
            this.scriptEvaluationError("OP_DUP requires at least one item to be on the stack.");
          }
          this.stack.push([...this.stacktop(-1)]);
          break;
        case OP_default.OP_NIP:
          if (this.stack.length < 2) {
            this.scriptEvaluationError("OP_NIP requires at least two items to be on the stack.");
          }
          this.stack.splice(this.stack.length - 2, 1);
          break;
        case OP_default.OP_OVER:
          if (this.stack.length < 2) {
            this.scriptEvaluationError("OP_OVER requires at least two items to be on the stack.");
          }
          this.stack.push([...this.stacktop(-2)]);
          break;
        case OP_default.OP_PICK:
        case OP_default.OP_ROLL:
          if (this.stack.length < 2) {
            this.scriptEvaluationError(`${OP_default[currentOpcode]} requires at least two items to be on the stack.`);
          }
          buf = this.stacktop(-1);
          bn = BigNumber.fromScriptNum(buf, requireMinimalPush);
          n = bn.toNumber();
          this.stack.pop();
          if (n < 0 || n >= this.stack.length) {
            this.scriptEvaluationError(`${OP_default[currentOpcode]} requires the top stack element to be 0 or a positive number less than the current size of the stack.`);
          }
          buf = this.stacktop(-n - 1);
          if (currentOpcode === OP_default.OP_ROLL) {
            this.stack.splice(this.stack.length - n - 1, 1);
          }
          this.stack.push([...buf]);
          break;
        case OP_default.OP_ROT:
          if (this.stack.length < 3) {
            this.scriptEvaluationError("OP_ROT requires at least three items to be on the stack.");
          }
          x1 = this.stacktop(-3);
          x2 = this.stacktop(-2);
          x3 = this.stacktop(-1);
          this.stack[this.stack.length - 3] = x2;
          this.stack[this.stack.length - 2] = x3;
          this.stack[this.stack.length - 1] = x1;
          break;
        case OP_default.OP_SWAP:
          if (this.stack.length < 2) {
            this.scriptEvaluationError("OP_SWAP requires at least two items to be on the stack.");
          }
          x1 = this.stacktop(-2);
          x2 = this.stacktop(-1);
          this.stack[this.stack.length - 2] = x2;
          this.stack[this.stack.length - 1] = x1;
          break;
        case OP_default.OP_TUCK:
          if (this.stack.length < 2) {
            this.scriptEvaluationError("OP_TUCK requires at least two items to be on the stack.");
          }
          this.stack.splice(this.stack.length - 2, 0, [...this.stacktop(-1)]);
          break;
        case OP_default.OP_SIZE:
          if (this.stack.length < 1) {
            this.scriptEvaluationError("OP_SIZE requires at least one item to be on the stack.");
          }
          bn = new BigNumber(this.stacktop(-1).length);
          this.stack.push(bn.toScriptNum());
          break;
        case OP_default.OP_AND:
        case OP_default.OP_OR:
        case OP_default.OP_XOR:
          if (this.stack.length < 2) {
            this.scriptEvaluationError(`${OP_default[currentOpcode]} requires at least one item to be on the stack.`);
          }
          buf1 = this.stacktop(-2);
          buf2 = this.stacktop(-1);
          if (buf1.length !== buf2.length) {
            this.scriptEvaluationError(`${OP_default[currentOpcode]} requires the top two stack items to be the same size.`);
          }
          switch (currentOpcode) {
            case OP_default.OP_AND:
              for (let i2 = 0; i2 < buf1.length; i2++) {
                buf1[i2] &= buf2[i2];
              }
              break;
            case OP_default.OP_OR:
              for (let i2 = 0; i2 < buf1.length; i2++) {
                buf1[i2] |= buf2[i2];
              }
              break;
            case OP_default.OP_XOR:
              for (let i2 = 0; i2 < buf1.length; i2++) {
                buf1[i2] ^= buf2[i2];
              }
              break;
          }
          this.stack.pop();
          break;
        case OP_default.OP_INVERT:
          if (this.stack.length < 1) {
            this.scriptEvaluationError("OP_INVERT requires at least one item to be on the stack.");
          }
          buf = this.stacktop(-1);
          for (let i2 = 0; i2 < buf.length; i2++) {
            buf[i2] = ~buf[i2];
          }
          break;
        case OP_default.OP_LSHIFT:
        case OP_default.OP_RSHIFT:
          if (this.stack.length < 2) {
            this.scriptEvaluationError(`${OP_default[currentOpcode]} requires at least two items to be on the stack.`);
          }
          buf1 = this.stacktop(-2);
          if (buf1.length === 0) {
            this.stack.pop();
          } else {
            bn1 = new BigNumber(buf1);
            bn2 = BigNumber.fromScriptNum(this.stacktop(-1), requireMinimalPush);
            n = bn2.toNumber();
            if (n < 0) {
              this.scriptEvaluationError(`${OP_default[currentOpcode]} requires the top item on the stack not to be negative.`);
            }
            this.stack.pop();
            this.stack.pop();
            let shifted;
            if (currentOpcode === OP_default.OP_LSHIFT) {
              shifted = bn1.ushln(n);
            }
            if (currentOpcode === OP_default.OP_RSHIFT) {
              shifted = bn1.ushrn(n);
            }
            const bufShifted = padDataToSize([...shifted.toArray().slice(buf1.length * -1)], buf1.length);
            this.stack.push(bufShifted);
          }
          break;
        case OP_default.OP_EQUAL:
        case OP_default.OP_EQUALVERIFY:
          if (this.stack.length < 2) {
            this.scriptEvaluationError(`${OP_default[currentOpcode]} requires at least two items to be on the stack.`);
          }
          buf1 = this.stacktop(-2);
          buf2 = this.stacktop(-1);
          fEqual = toHex(buf1) === toHex(buf2);
          this.stack.pop();
          this.stack.pop();
          this.stack.push(fEqual ? [1] : []);
          if (currentOpcode === OP_default.OP_EQUALVERIFY) {
            if (fEqual) {
              this.stack.pop();
            } else {
              this.scriptEvaluationError("OP_EQUALVERIFY requires the top two stack items to be equal.");
            }
          }
          break;
        case OP_default.OP_1ADD:
        case OP_default.OP_1SUB:
        case OP_default.OP_NEGATE:
        case OP_default.OP_ABS:
        case OP_default.OP_NOT:
        case OP_default.OP_0NOTEQUAL:
          if (this.stack.length < 1) {
            this.scriptEvaluationError(`${OP_default[currentOpcode]} requires at least one items to be on the stack.`);
          }
          buf = this.stacktop(-1);
          bn = BigNumber.fromScriptNum(buf, requireMinimalPush);
          switch (currentOpcode) {
            case OP_default.OP_1ADD:
              bn = bn.addn(1);
              break;
            case OP_default.OP_1SUB:
              bn = bn.subn(1);
              break;
            case OP_default.OP_NEGATE:
              bn = bn.neg();
              break;
            case OP_default.OP_ABS:
              if (bn.cmpn(0) < 0) {
                bn = bn.neg();
              }
              break;
            case OP_default.OP_NOT:
              bn = new BigNumber(bn.cmpn(0) === 0 ? 1 : 0 + 0);
              break;
            case OP_default.OP_0NOTEQUAL:
              bn = new BigNumber(bn.cmpn(0) !== 0 ? 1 : 0 + 0);
              break;
          }
          this.stack.pop();
          this.stack.push(bn.toScriptNum());
          break;
        case OP_default.OP_ADD:
        case OP_default.OP_SUB:
        case OP_default.OP_MUL:
        case OP_default.OP_MOD:
        case OP_default.OP_DIV:
        case OP_default.OP_BOOLAND:
        case OP_default.OP_BOOLOR:
        case OP_default.OP_NUMEQUAL:
        case OP_default.OP_NUMEQUALVERIFY:
        case OP_default.OP_NUMNOTEQUAL:
        case OP_default.OP_LESSTHAN:
        case OP_default.OP_GREATERTHAN:
        case OP_default.OP_LESSTHANOREQUAL:
        case OP_default.OP_GREATERTHANOREQUAL:
        case OP_default.OP_MIN:
        case OP_default.OP_MAX:
          if (this.stack.length < 2) {
            this.scriptEvaluationError(`${OP_default[currentOpcode]} requires at least two items to be on the stack.`);
          }
          bn1 = BigNumber.fromScriptNum(this.stacktop(-2), requireMinimalPush);
          bn2 = BigNumber.fromScriptNum(this.stacktop(-1), requireMinimalPush);
          bn = new BigNumber(0);
          switch (currentOpcode) {
            case OP_default.OP_ADD:
              bn = bn1.add(bn2);
              break;
            case OP_default.OP_SUB:
              bn = bn1.sub(bn2);
              break;
            case OP_default.OP_MUL:
              bn = bn1.mul(bn2);
              break;
            case OP_default.OP_DIV:
              if (bn2.cmpn(0) === 0) {
                this.scriptEvaluationError("OP_DIV cannot divide by zero!");
              }
              bn = bn1.div(bn2);
              break;
            case OP_default.OP_MOD:
              if (bn2.cmpn(0) === 0) {
                this.scriptEvaluationError("OP_MOD cannot divide by zero!");
              }
              bn = bn1.mod(bn2);
              break;
            case OP_default.OP_BOOLAND:
              bn = new BigNumber(bn1.cmpn(0) !== 0 && bn2.cmpn(0) !== 0 ? 1 : 0 + 0);
              break;
            case OP_default.OP_BOOLOR:
              bn = new BigNumber(bn1.cmpn(0) !== 0 || bn2.cmpn(0) !== 0 ? 1 : 0 + 0);
              break;
            case OP_default.OP_NUMEQUAL:
              bn = new BigNumber(bn1.cmp(bn2) === 0 ? 1 : 0 + 0);
              break;
            case OP_default.OP_NUMEQUALVERIFY:
              bn = new BigNumber(bn1.cmp(bn2) === 0 ? 1 : 0 + 0);
              break;
            case OP_default.OP_NUMNOTEQUAL:
              bn = new BigNumber(bn1.cmp(bn2) !== 0 ? 1 : 0 + 0);
              break;
            case OP_default.OP_LESSTHAN:
              bn = new BigNumber(bn1.cmp(bn2) < 0 ? 1 : 0 + 0);
              break;
            case OP_default.OP_GREATERTHAN:
              bn = new BigNumber(bn1.cmp(bn2) > 0 ? 1 : 0 + 0);
              break;
            case OP_default.OP_LESSTHANOREQUAL:
              bn = new BigNumber(bn1.cmp(bn2) <= 0 ? 1 : 0 + 0);
              break;
            case OP_default.OP_GREATERTHANOREQUAL:
              bn = new BigNumber(bn1.cmp(bn2) >= 0 ? 1 : 0 + 0);
              break;
            case OP_default.OP_MIN:
              bn = bn1.cmp(bn2) < 0 ? bn1 : bn2;
              break;
            case OP_default.OP_MAX:
              bn = bn1.cmp(bn2) > 0 ? bn1 : bn2;
              break;
          }
          this.stack.pop();
          this.stack.pop();
          this.stack.push(bn.toScriptNum());
          if (currentOpcode === OP_default.OP_NUMEQUALVERIFY) {
            if (this.castToBool(this.stacktop(-1))) {
              this.stack.pop();
            } else {
              this.scriptEvaluationError("OP_NUMEQUALVERIFY requires the top stack item to be truthy.");
            }
          }
          break;
        case OP_default.OP_WITHIN:
          if (this.stack.length < 3) {
            this.scriptEvaluationError("OP_WITHIN requires at least three items to be on the stack.");
          }
          bn1 = BigNumber.fromScriptNum(this.stacktop(-3), requireMinimalPush);
          bn2 = BigNumber.fromScriptNum(this.stacktop(-2), requireMinimalPush);
          bn3 = BigNumber.fromScriptNum(this.stacktop(-1), requireMinimalPush);
          fValue = bn2.cmp(bn1) <= 0 && bn1.cmp(bn3) < 0;
          this.stack.pop();
          this.stack.pop();
          this.stack.pop();
          this.stack.push(fValue ? [1] : []);
          break;
        case OP_default.OP_RIPEMD160:
        case OP_default.OP_SHA1:
        case OP_default.OP_SHA256:
        case OP_default.OP_HASH160:
        case OP_default.OP_HASH256:
          if (this.stack.length < 1) {
            this.scriptEvaluationError(`${OP_default[currentOpcode]} requires at least one item to be on the stack.`);
          }
          buf = this.stacktop(-1);
          if (currentOpcode === OP_default.OP_RIPEMD160) {
            bufHash = ripemd160(buf);
          } else if (currentOpcode === OP_default.OP_SHA1) {
            bufHash = sha1(buf);
          } else if (currentOpcode === OP_default.OP_SHA256) {
            bufHash = sha256(buf);
          } else if (currentOpcode === OP_default.OP_HASH160) {
            bufHash = hash160(buf);
          } else if (currentOpcode === OP_default.OP_HASH256) {
            bufHash = hash256(buf);
          }
          this.stack.pop();
          this.stack.push(bufHash);
          break;
        case OP_default.OP_CODESEPARATOR:
          this.lastCodeSeparator = this.programCounter;
          break;
        case OP_default.OP_CHECKSIG:
        case OP_default.OP_CHECKSIGVERIFY:
          if (this.stack.length < 2) {
            this.scriptEvaluationError(`${OP_default[currentOpcode]} requires at least two items to be on the stack.`);
          }
          bufSig = this.stacktop(-2);
          bufPubkey = this.stacktop(-1);
          if (!checkSignatureEncoding(bufSig) || !checkPublicKeyEncoding(bufPubkey)) {
            this.scriptEvaluationError(`${OP_default[currentOpcode]} requires correct encoding for the public key and signature.`);
          }
          if (this.context === "UnlockingScript") {
            subscript = new Script(this.unlockingScript.chunks.slice(this.lastCodeSeparator));
          } else {
            subscript = new Script(this.lockingScript.chunks.slice(this.lastCodeSeparator));
          }
          subscript.findAndDelete(new Script().writeBin(bufSig));
          try {
            sig = TransactionSignature.fromChecksigFormat(bufSig);
            pubkey = PublicKey.fromString(toHex(bufPubkey));
            fSuccess = verifySignature(sig, pubkey, subscript);
          } catch (e) {
            fSuccess = false;
          }
          if (!fSuccess && bufSig.length > 0) {
            this.scriptEvaluationError(`${OP_default[currentOpcode]} failed to verify the signature, and requires an empty signature when verification fails.`);
          }
          this.stack.pop();
          this.stack.pop();
          this.stack.push(fSuccess ? [1] : []);
          if (currentOpcode === OP_default.OP_CHECKSIGVERIFY) {
            if (fSuccess) {
              this.stack.pop();
            } else {
              this.scriptEvaluationError("OP_CHECKSIGVERIFY requires that a valid signature is provided.");
            }
          }
          break;
        case OP_default.OP_CHECKMULTISIG:
        case OP_default.OP_CHECKMULTISIGVERIFY:
          i = 1;
          if (this.stack.length < i) {
            this.scriptEvaluationError(`${OP_default[currentOpcode]} requires at least 1 item to be on the stack.`);
          }
          nKeysCount = BigNumber.fromScriptNum(this.stacktop(-i), requireMinimalPush).toNumber();
          if (nKeysCount < 0 || nKeysCount > maxMultisigKeyCount) {
            this.scriptEvaluationError(`${OP_default[currentOpcode]} requires a key count between 0 and ${maxMultisigKeyCount}.`);
          }
          ikey = ++i;
          i += nKeysCount;
          ikey2 = nKeysCount + 2;
          if (this.stack.length < i) {
            this.scriptEvaluationError(`${OP_default[currentOpcode]} requires the number of stack items not to be less than the number of keys used.`);
          }
          nSigsCount = BigNumber.fromScriptNum(this.stacktop(-i), requireMinimalPush).toNumber();
          if (nSigsCount < 0 || nSigsCount > nKeysCount) {
            this.scriptEvaluationError(`${OP_default[currentOpcode]} requires the number of signatures to be no greater than the number of keys.`);
          }
          isig = ++i;
          i += nSigsCount;
          if (this.stack.length < i) {
            this.scriptEvaluationError(`${OP_default[currentOpcode]} requires the number of stack items not to be less than the number of signatures provided.`);
          }
          if (this.context === "UnlockingScript") {
            subscript = new Script(this.unlockingScript.chunks.slice(this.lastCodeSeparator));
          } else {
            subscript = new Script(this.lockingScript.chunks.slice(this.lastCodeSeparator));
          }
          for (let k = 0; k < nSigsCount; k++) {
            bufSig = this.stacktop(-isig - k);
            subscript.findAndDelete(new Script().writeBin(bufSig));
          }
          fSuccess = true;
          while (fSuccess && nSigsCount > 0) {
            bufSig = this.stacktop(-isig);
            bufPubkey = this.stacktop(-ikey);
            if (!checkSignatureEncoding(bufSig) || !checkPublicKeyEncoding(bufPubkey)) {
              this.scriptEvaluationError(`${OP_default[currentOpcode]} requires correct encoding for the public key and signature.`);
            }
            try {
              sig = TransactionSignature.fromChecksigFormat(bufSig);
              pubkey = PublicKey.fromString(toHex(bufPubkey));
              fOk = verifySignature(sig, pubkey, subscript);
            } catch (e) {
              fOk = false;
            }
            if (fOk) {
              isig++;
              nSigsCount--;
            }
            ikey++;
            nKeysCount--;
            if (nSigsCount > nKeysCount) {
              fSuccess = false;
            }
          }
          while (i-- > 1) {
            if (!fSuccess && !ikey2 && this.stacktop(-1).length > 0) {
              this.scriptEvaluationError(`${OP_default[currentOpcode]} failed to verify a signature, and requires an empty signature when verification fails.`);
            }
            if (ikey2 > 0) {
              ikey2--;
            }
            this.stack.pop();
          }
          if (this.stack.length < 1) {
            this.scriptEvaluationError(`${OP_default[currentOpcode]} requires an extra item to be on the stack.`);
          }
          if (this.stacktop(-1).length > 0) {
            this.scriptEvaluationError(`${OP_default[currentOpcode]} requires the extra stack item to be empty.`);
          }
          this.stack.pop();
          this.stack.push(fSuccess ? [1] : []);
          if (currentOpcode === OP_default.OP_CHECKMULTISIGVERIFY) {
            if (fSuccess) {
              this.stack.pop();
            } else {
              this.scriptEvaluationError("OP_CHECKMULTISIGVERIFY requires that a sufficient number of valid signatures are provided.");
            }
          }
          break;
        case OP_default.OP_CAT:
          if (this.stack.length < 2) {
            this.scriptEvaluationError("OP_CAT requires at least two items to be on the stack.");
          }
          buf1 = this.stacktop(-2);
          buf2 = this.stacktop(-1);
          if (buf1.length + buf2.length > maxScriptElementSize) {
            this.scriptEvaluationError(`It's not currently possible to push data larger than ${maxScriptElementSize} bytes.`);
          }
          this.stack[this.stack.length - 2] = [...buf1, ...buf2];
          this.stack.pop();
          break;
        case OP_default.OP_SPLIT:
          if (this.stack.length < 2) {
            this.scriptEvaluationError("OP_SPLIT requires at least two items to be on the stack.");
          }
          buf1 = this.stacktop(-2);
          n = BigNumber.fromScriptNum(this.stacktop(-1), requireMinimalPush).toNumber();
          if (n < 0 || n > buf1.length) {
            this.scriptEvaluationError("OP_SPLIT requires the first stack item to be a non-negative number less than or equal to the size of the second-from-top stack item.");
          }
          buf2 = [...buf1];
          this.stack[this.stack.length - 2] = buf2.slice(0, n);
          this.stack[this.stack.length - 1] = buf2.slice(n);
          break;
        case OP_default.OP_NUM2BIN:
          if (this.stack.length < 2) {
            this.scriptEvaluationError("OP_NUM2BIN requires at least two items to be on the stack.");
          }
          size = BigNumber.fromScriptNum(this.stacktop(-1), requireMinimalPush).toNumber();
          if (size > maxScriptElementSize) {
            this.scriptEvaluationError(`It's not currently possible to push data larger than ${maxScriptElementSize} bytes.`);
          }
          this.stack.pop();
          rawnum = this.stacktop(-1);
          rawnum = minimallyEncode(rawnum);
          if (rawnum.length > size) {
            this.scriptEvaluationError("OP_NUM2BIN requires that the size expressed in the top stack item is large enough to hold the value expressed in the second-from-top stack item.");
          }
          if (rawnum.length === size) {
            this.stack[this.stack.length - 1] = rawnum;
            break;
          }
          signbit = 0;
          if (rawnum.length > 0) {
            signbit = rawnum[rawnum.length - 1] & 128;
            rawnum[rawnum.length - 1] &= 127;
          }
          num = new Array(size);
          num.fill(0);
          for (n = 0; n < size; n++) {
            num[n] = rawnum[n];
          }
          n = rawnum.length - 1;
          while (n++ < size - 2) {
            num[n] = 0;
          }
          num[n] = signbit;
          this.stack[this.stack.length - 1] = num;
          break;
        case OP_default.OP_BIN2NUM:
          if (this.stack.length < 1) {
            this.scriptEvaluationError("OP_BIN2NUM requires at least one item to be on the stack.");
          }
          buf1 = this.stacktop(-1);
          buf2 = minimallyEncode(buf1);
          this.stack[this.stack.length - 1] = buf2;
          if (!isMinimallyEncoded(buf2)) {
            this.scriptEvaluationError("OP_BIN2NUM requires that the resulting number is valid.");
          }
          break;
        default:
          this.scriptEvaluationError("Invalid opcode!");
      }
    }
    this.programCounter++;
  }
  /**
   * @method validate
   * Validates the spend action by interpreting the locking and unlocking scripts.
   * @returns {boolean} Returns true if the scripts are valid and the spend is legitimate, otherwise false.
   * @example
   * if (spend.validate()) {
   *   console.log("Spend is valid!");
   * } else {
   *   console.log("Invalid spend!");
   * }
   */
  validate() {
    if (requirePushOnlyUnlockingScripts && !this.unlockingScript.isPushOnly()) {
      this.scriptEvaluationError("Unlocking scripts can only contain push operations, and no other opcodes.");
    }
    while (true) {
      this.step();
      if (this.context === "LockingScript" && this.programCounter >= this.lockingScript.chunks.length) {
        break;
      }
    }
    if (this.ifStack.length > 0) {
      this.scriptEvaluationError("Every OP_IF must be terminated prior to the end of the script.");
    }
    if (requireCleanStack) {
      if (this.stack.length !== 1) {
        this.scriptEvaluationError("The clean stack rule requires exactly one item to be on the stack after script execution.");
      }
    }
    if (!this.castToBool(this.stacktop(-1))) {
      this.scriptEvaluationError("The top stack element must be truthy after script evaluation.");
    }
    return true;
  }
  stacktop(i) {
    return this.stack[this.stack.length + i];
  }
  castToBool(val) {
    for (let i = 0; i < val.length; i++) {
      if (val[i] !== 0) {
        if (i === val.length - 1 && val[i] === 128) {
          return false;
        }
        return true;
      }
    }
    return false;
  }
  scriptEvaluationError(str) {
    throw new Error(`Script evaluation error: ${str}

Source TXID: ${this.sourceTXID}
Source output index: ${this.sourceOutputIndex}
Context: ${this.context}
Program counter: ${this.programCounter}
Stack size: ${this.stack.length}
Alt stack size: ${this.altStack.length}`);
  }
};

// node_modules/@bsv/sdk/dist/esm/src/script/templates/P2PKH.js
var P2PKH = class {
  /**
   * Creates a P2PKH locking script for a given public key hash or address string
   *
   * @param {number[] | string} pubkeyhash or address - An array or address representing the public key hash.
   * @returns {LockingScript} - A P2PKH locking script.
   */
  lock(pubkeyhash) {
    let data;
    if (typeof pubkeyhash === "string") {
      const hash = fromBase58Check(pubkeyhash);
      if (hash.prefix[0] !== 0 && hash.prefix[0] !== 111)
        throw new Error("only P2PKH is supported");
      data = hash.data;
    } else {
      data = pubkeyhash;
    }
    return new LockingScript([
      { op: OP_default.OP_DUP },
      { op: OP_default.OP_HASH160 },
      { op: data.length, data },
      { op: OP_default.OP_EQUALVERIFY },
      { op: OP_default.OP_CHECKSIG }
    ]);
  }
  /**
   * Creates a function that generates a P2PKH unlocking script along with its signature and length estimation.
   *
   * The returned object contains:
   * 1. `sign` - A function that, when invoked with a transaction and an input index,
   *    produces an unlocking script suitable for a P2PKH locked output.
   * 2. `estimateLength` - A function that returns the estimated length of the unlocking script in bytes.
   *
   * @param {PrivateKey} privateKey - The private key used for signing the transaction.
   * @param {'all'|'none'|'single'} signOutputs - The signature scope for outputs.
   * @param {boolean} anyoneCanPay - Flag indicating if the signature allows for other inputs to be added later.
   * @param {number} sourceSatoshis - Optional. The amount being unlocked. Otherwise the input.sourceTransaction is required.
   * @param {Script} lockingScript - Optional. The lockinScript. Otherwise the input.sourceTransaction is required.
   * @returns {Object} - An object containing the `sign` and `estimateLength` functions.
   */
  unlock(privateKey, signOutputs = "all", anyoneCanPay = false, sourceSatoshis, lockingScript) {
    return {
      sign: async (tx, inputIndex) => {
        var _a, _b, _c;
        let signatureScope = TransactionSignature.SIGHASH_FORKID;
        if (signOutputs === "all") {
          signatureScope |= TransactionSignature.SIGHASH_ALL;
        }
        if (signOutputs === "none") {
          signatureScope |= TransactionSignature.SIGHASH_NONE;
        }
        if (signOutputs === "single") {
          signatureScope |= TransactionSignature.SIGHASH_SINGLE;
        }
        if (anyoneCanPay) {
          signatureScope |= TransactionSignature.SIGHASH_ANYONECANPAY;
        }
        const input = tx.inputs[inputIndex];
        const otherInputs = tx.inputs.filter((_, index) => index !== inputIndex);
        const sourceTXID = input.sourceTXID ? input.sourceTXID : (_a = input.sourceTransaction) == null ? void 0 : _a.id("hex");
        if (!sourceTXID) {
          throw new Error("The input sourceTXID or sourceTransaction is required for transaction signing.");
        }
        sourceSatoshis || (sourceSatoshis = (_b = input.sourceTransaction) == null ? void 0 : _b.outputs[input.sourceOutputIndex].satoshis);
        if (!sourceSatoshis) {
          throw new Error("The sourceSatoshis or input sourceTransaction is required for transaction signing.");
        }
        lockingScript || (lockingScript = (_c = input.sourceTransaction) == null ? void 0 : _c.outputs[input.sourceOutputIndex].lockingScript);
        if (!lockingScript) {
          throw new Error("The lockingScript or input sourceTransaction is required for transaction signing.");
        }
        const preimage = TransactionSignature.format({
          sourceTXID,
          sourceOutputIndex: input.sourceOutputIndex,
          sourceSatoshis,
          transactionVersion: tx.version,
          otherInputs,
          inputIndex,
          outputs: tx.outputs,
          inputSequence: input.sequence,
          subscript: lockingScript,
          lockTime: tx.lockTime,
          scope: signatureScope
        });
        const rawSignature = privateKey.sign(sha256(preimage));
        const sig = new TransactionSignature(rawSignature.r, rawSignature.s, signatureScope);
        const sigForScript = sig.toChecksigFormat();
        const pubkeyForScript = privateKey.toPublicKey().encode(true);
        return new UnlockingScript([
          { op: sigForScript.length, data: sigForScript },
          { op: pubkeyForScript.length, data: pubkeyForScript }
        ]);
      },
      estimateLength: async () => {
        return 106;
      }
    };
  }
};

// node_modules/@bsv/sdk/dist/esm/src/script/templates/RPuzzle.js
var RPuzzle = class {
  /**
   * @constructor
   * Constructs an R Puzzle template instance for a given puzzle type
   *
   * @param {'raw'|'SHA1'|'SHA256'|'HASH256'|'RIPEMD160'|'HASH160'} type Denotes the type of puzzle to create
   */
  constructor(type = "raw") {
    __publicField(this, "type", "raw");
    this.type = type;
  }
  /**
   * Creates an R puzzle locking script for a given R value or R value hash.
   *
   * @param {number[]} value - An array representing the R value or its hash.
   * @returns {LockingScript} - An R puzzle locking script.
   */
  lock(value) {
    const chunks = [
      { op: OP_default.OP_OVER },
      { op: OP_default.OP_3 },
      { op: OP_default.OP_SPLIT },
      { op: OP_default.OP_NIP },
      { op: OP_default.OP_1 },
      { op: OP_default.OP_SPLIT },
      { op: OP_default.OP_SWAP },
      { op: OP_default.OP_SPLIT },
      { op: OP_default.OP_DROP }
    ];
    if (this.type !== "raw") {
      chunks.push({
        op: OP_default["OP_" + this.type]
      });
    }
    chunks.push({ op: value.length, data: value });
    chunks.push({ op: OP_default.OP_EQUALVERIFY });
    chunks.push({ op: OP_default.OP_CHECKSIG });
    return new LockingScript(chunks);
  }
  /**
   * Creates a function that generates an R puzzle unlocking script along with its signature and length estimation.
   *
   * The returned object contains:
   * 1. `sign` - A function that, when invoked with a transaction and an input index,
   *    produces an unlocking script suitable for an R puzzle locked output.
   * 2. `estimateLength` - A function that returns the estimated length of the unlocking script in bytes.
   *
   * @param {BigNumber} k  The K-value used to unlock the R-puzzle.
   * @param {PrivateKey} privateKey - The private key used for signing the transaction. If not provided, a random key will be generated.
   * @param {'all'|'none'|'single'} signOutputs - The signature scope for outputs.
   * @param {boolean} anyoneCanPay - Flag indicating if the signature allows for other inputs to be added later.
   * @returns {Object} - An object containing the `sign` and `estimateLength` functions.
   */
  unlock(k, privateKey, signOutputs = "all", anyoneCanPay = false) {
    return {
      sign: async (tx, inputIndex) => {
        if (typeof privateKey === "undefined") {
          privateKey = PrivateKey.fromRandom();
        }
        let signatureScope = TransactionSignature.SIGHASH_FORKID;
        if (signOutputs === "all") {
          signatureScope |= TransactionSignature.SIGHASH_ALL;
        }
        if (signOutputs === "none") {
          signatureScope |= TransactionSignature.SIGHASH_NONE;
        }
        if (signOutputs === "single") {
          signatureScope |= TransactionSignature.SIGHASH_SINGLE;
        }
        if (anyoneCanPay) {
          signatureScope |= TransactionSignature.SIGHASH_ANYONECANPAY;
        }
        const otherInputs = [...tx.inputs];
        const [input] = otherInputs.splice(inputIndex, 1);
        if (typeof input.sourceTransaction !== "object") {
          throw new Error("The source transaction is needed for transaction signing.");
        }
        const preimage = TransactionSignature.format({
          sourceTXID: input.sourceTransaction.id("hex"),
          sourceOutputIndex: input.sourceOutputIndex,
          sourceSatoshis: input.sourceTransaction.outputs[input.sourceOutputIndex].satoshis,
          transactionVersion: tx.version,
          otherInputs,
          inputIndex,
          outputs: tx.outputs,
          inputSequence: input.sequence,
          subscript: input.sourceTransaction.outputs[input.sourceOutputIndex].lockingScript,
          lockTime: tx.lockTime,
          scope: signatureScope
        });
        const rawSignature = privateKey.sign(sha256(preimage), void 0, true, k);
        const sig = new TransactionSignature(rawSignature.r, rawSignature.s, signatureScope);
        const sigForScript = sig.toChecksigFormat();
        const pubkeyForScript = privateKey.toPublicKey().encode(true);
        return new UnlockingScript([
          { op: sigForScript.length, data: sigForScript },
          { op: pubkeyForScript.length, data: pubkeyForScript }
        ]);
      },
      estimateLength: async () => {
        return 106;
      }
    };
  }
};

// node_modules/@bsv/sdk/dist/esm/src/transaction/fee-models/SatoshisPerKilobyte.js
var SatoshisPerKilobyte = class {
  /**
   * Constructs an instance of the sat/kb fee model.
   *
   * @param {number} value - The number of satoshis per kilobyte to charge as a fee.
   */
  constructor(value) {
    /**
     * @property
     * Denotes the number of satoshis paid per kilobyte of transaction size.
     */
    __publicField(this, "value");
    this.value = value;
  }
  /**
   * Computes the fee for a given transaction.
   *
   * @param tx The transaction for which a fee is to be computed.
   * @returns The fee in satoshis for the transaction, as a BigNumber.
   */
  async computeFee(tx) {
    const getVarIntSize = (i) => {
      if (i > 2 ** 32) {
        return 9;
      } else if (i > 2 ** 16) {
        return 5;
      } else if (i > 253) {
        return 3;
      } else {
        return 1;
      }
    };
    let size = 4;
    size += getVarIntSize(tx.inputs.length);
    for (let i = 0; i < tx.inputs.length; i++) {
      const input = tx.inputs[i];
      size += 40;
      let scriptLength;
      if (typeof input.unlockingScript === "object") {
        scriptLength = input.unlockingScript.toBinary().length;
      } else if (typeof input.unlockingScriptTemplate === "object") {
        scriptLength = await input.unlockingScriptTemplate.estimateLength(tx, i);
      } else {
        throw new Error("All inputs must have an unlocking script or an unlocking script template for sat/kb fee computation.");
      }
      size += getVarIntSize(scriptLength);
      size += scriptLength;
    }
    size += getVarIntSize(tx.outputs.length);
    for (const out of tx.outputs) {
      size += 8;
      const length = out.lockingScript.toBinary().length;
      size += getVarIntSize(length);
      size += length;
    }
    size += 4;
    const fee = Math.ceil(size / 1e3 * this.value);
    return fee;
  }
};

// node_modules/@bsv/sdk/dist/esm/src/transaction/MerklePath.js
var MerklePath = class _MerklePath {
  constructor(blockHeight, path) {
    __publicField(this, "blockHeight");
    __publicField(this, "path");
    this.blockHeight = blockHeight;
    this.path = path;
    const legalOffsets = Array(this.path.length).fill(0).map(() => /* @__PURE__ */ new Set());
    this.path.map((leaves, height) => {
      if (leaves.length === 0 && height === 0) {
        throw new Error(`Empty level at height: ${height}`);
      }
      const offsetsAtThisHeight = /* @__PURE__ */ new Set();
      leaves.map((leaf) => {
        if (offsetsAtThisHeight.has(leaf.offset))
          throw new Error(`Duplicate offset: ${leaf.offset}, at height: ${height}`);
        offsetsAtThisHeight.add(leaf.offset);
        if (height === 0) {
          if (!leaf.duplicate) {
            for (let h = 1; h < this.path.length; h++) {
              legalOffsets[h].add(leaf.offset >> h ^ 1);
            }
          }
        } else {
          if (!legalOffsets[height].has(leaf.offset)) {
            throw new Error(`Invalid offset: ${leaf.offset}, at height: ${height}, with legal offsets: ${Array.from(legalOffsets[height]).join(", ")}`);
          }
        }
      });
    });
    let root;
    this.path[0].map((leaf, idx) => {
      if (idx === 0)
        root = this.computeRoot(leaf.hash);
      if (root !== this.computeRoot(leaf.hash)) {
        throw new Error("Mismatched roots");
      }
    });
  }
  /**
   * Creates a MerklePath instance from a hexadecimal string.
   *
   * @static
   * @param {string} hex - The hexadecimal string representation of the Merkle Path.
   * @returns {MerklePath} - A new MerklePath instance.
   */
  static fromHex(hex) {
    return _MerklePath.fromBinary(toArray2(hex, "hex"));
  }
  static fromReader(reader) {
    const blockHeight = reader.readVarIntNum();
    const treeHeight = reader.readUInt8();
    const path = Array(treeHeight).fill(0).map(() => []);
    let flags, offset, nLeavesAtThisHeight;
    for (let level = 0; level < treeHeight; level++) {
      nLeavesAtThisHeight = reader.readVarIntNum();
      while (nLeavesAtThisHeight) {
        offset = reader.readVarIntNum();
        flags = reader.readUInt8();
        const leaf = { offset };
        if (flags & 1) {
          leaf.duplicate = true;
        } else {
          if (flags & 2) {
            leaf.txid = true;
          }
          leaf.hash = toHex(reader.read(32).reverse());
        }
        path[level].push(leaf);
        nLeavesAtThisHeight--;
      }
      path[level].sort((a, b) => a.offset - b.offset);
    }
    return new _MerklePath(blockHeight, path);
  }
  /**
   * Creates a MerklePath instance from a binary array.
   *
   * @static
   * @param {number[]} bump - The binary array representation of the Merkle Path.
   * @returns {MerklePath} - A new MerklePath instance.
   */
  static fromBinary(bump) {
    const reader = new Reader(bump);
    return _MerklePath.fromReader(reader);
  }
  /**
   * Converts the MerklePath to a binary array format.
   *
   * @returns {number[]} - The binary array representation of the Merkle Path.
   */
  toBinary() {
    const writer = new Writer();
    writer.writeVarIntNum(this.blockHeight);
    const treeHeight = this.path.length;
    writer.writeUInt8(treeHeight);
    for (let level = 0; level < treeHeight; level++) {
      const nLeaves = Object.keys(this.path[level]).length;
      writer.writeVarIntNum(nLeaves);
      for (const leaf of this.path[level]) {
        writer.writeVarIntNum(leaf.offset);
        let flags = 0;
        if (leaf == null ? void 0 : leaf.duplicate) {
          flags |= 1;
        }
        if (leaf == null ? void 0 : leaf.txid) {
          flags |= 2;
        }
        writer.writeUInt8(flags);
        if ((flags & 1) === 0) {
          writer.write(toArray2(leaf.hash, "hex").reverse());
        }
      }
    }
    return writer.toArray();
  }
  /**
   * Converts the MerklePath to a hexadecimal string format.
   *
   * @returns {string} - The hexadecimal string representation of the Merkle Path.
   */
  toHex() {
    return toHex(this.toBinary());
  }
  /**
   * Computes the Merkle root from the provided transaction ID.
   *
   * @param {string} txid - The transaction ID to compute the Merkle root for. If not provided, the root will be computed from an unspecified branch, and not all branches will be validated!
   * @returns {string} - The computed Merkle root as a hexadecimal string.
   * @throws {Error} - If the transaction ID is not part of the Merkle Path.
   */
  computeRoot(txid) {
    if (typeof txid !== "string") {
      txid = this.path[0].find((leaf) => Boolean(leaf == null ? void 0 : leaf.hash)).hash;
    }
    const index = this.path[0].find((l) => l.hash === txid).offset;
    if (typeof index !== "number") {
      throw new Error(`This proof does not contain the txid: ${txid}`);
    }
    const hash = (m) => toHex(hash256(toArray2(m, "hex").reverse()).reverse());
    let workingHash = txid;
    for (let height = 0; height < this.path.length; height++) {
      const leaves = this.path[height];
      const offset = index >> height ^ 1;
      const leaf = this.findOrComputeLeaf(height, offset);
      if (typeof leaf !== "object") {
        throw new Error(`Missing hash for index ${index} at height ${height}`);
      }
      if (leaf.duplicate) {
        workingHash = hash(workingHash + workingHash);
      } else if (offset % 2 !== 0) {
        workingHash = hash(leaf.hash + workingHash);
      } else {
        workingHash = hash(workingHash + leaf.hash);
      }
    }
    return workingHash;
  }
  /**
   * Find leaf with `offset` at `height` or compute from level below, recursively.
   *
   * Does not add computed leaves to path.
   *
   * @param height
   * @param offset
   */
  findOrComputeLeaf(height, offset) {
    const hash = (m) => toHex(hash256(toArray2(m, "hex").reverse()).reverse());
    let leaf = this.path[height].find((l2) => l2.offset === offset);
    if (leaf)
      return leaf;
    if (height === 0)
      return void 0;
    const h = height - 1;
    const l = offset << 1;
    const leaf0 = this.findOrComputeLeaf(h, l);
    if (!leaf0 || !leaf0.hash)
      return void 0;
    const leaf1 = this.findOrComputeLeaf(h, l + 1);
    if (!leaf1)
      return void 0;
    let workinghash;
    if (leaf1.duplicate) {
      workinghash = hash(leaf0.hash + leaf0.hash);
    } else {
      workinghash = hash(leaf1.hash + leaf0.hash);
    }
    leaf = {
      offset,
      hash: workinghash
    };
    return leaf;
  }
  /**
   * Verifies if the given transaction ID is part of the Merkle tree at the specified block height.
   *
   * @param {string} txid - The transaction ID to verify.
   * @param {ChainTracker} chainTracker - The ChainTracker instance used to verify the Merkle root.
   * @returns {boolean} - True if the transaction ID is valid within the Merkle Path at the specified block height.
   */
  async verify(txid, chainTracker) {
    const root = this.computeRoot(txid);
    return await chainTracker.isValidRootForHeight(root, this.blockHeight);
  }
  /**
   * Combines this MerklePath with another to create a compound proof.
   *
   * @param {MerklePath} other - Another MerklePath to combine with this path.
   * @throws {Error} - If the paths have different block heights or roots.
   */
  combine(other) {
    var _a;
    if (this.blockHeight !== other.blockHeight) {
      throw new Error("You cannot combine paths which do not have the same block height.");
    }
    const root1 = this.computeRoot();
    const root2 = other.computeRoot();
    if (root1 !== root2) {
      throw new Error("You cannot combine paths which do not have the same root.");
    }
    const combinedPath = [];
    for (let h = 0; h < this.path.length; h++) {
      combinedPath.push([]);
      for (let l = 0; l < this.path[h].length; l++) {
        combinedPath[h].push(this.path[h][l]);
      }
      for (let l = 0; l < other.path[h].length; l++) {
        if (!combinedPath[h].find((leaf) => leaf.offset === other.path[h][l].offset)) {
          combinedPath[h].push(other.path[h][l]);
        } else {
          if ((_a = other.path[h][l]) == null ? void 0 : _a.txid) {
            const target = combinedPath[h].find((leaf) => leaf.offset === other.path[h][l].offset);
            target.txid = true;
          }
        }
      }
    }
    this.path = combinedPath;
    this.trim();
  }
  /**
   * Remove all internal nodes that are not required by level zero txid nodes.
   * Assumes that at least all required nodes are present.
   * Leaves all levels sorted by increasing offset.
   */
  trim() {
    const pushIfNew = (v, a) => {
      if (a.length === 0 || a.slice(-1)[0] !== v) {
        a.push(v);
      }
    };
    const dropOffsetsFromLevel = (dropOffsets2, level) => {
      for (let i = dropOffsets2.length; i >= 0; i--) {
        const l = this.path[level].findIndex((n) => n.offset === dropOffsets2[i]);
        if (l >= 0) {
          this.path[level].splice(l, 1);
        }
      }
    };
    const nextComputedOffsets = (cos) => {
      const ncos = [];
      for (const o of cos) {
        pushIfNew(o >> 1, ncos);
      }
      return ncos;
    };
    let computedOffsets = [];
    let dropOffsets = [];
    for (let h = 0; h < this.path.length; h++) {
      this.path[h].sort((a, b) => a.offset - b.offset);
    }
    for (let l = 0; l < this.path[0].length; l++) {
      const n = this.path[0][l];
      if (n.txid) {
        pushIfNew(n.offset >> 1, computedOffsets);
      } else {
        const isOdd = n.offset % 2 === 1;
        const peer = this.path[0][l + (isOdd ? -1 : 1)];
        if (!peer.txid) {
          pushIfNew(peer.offset, dropOffsets);
        }
      }
    }
    dropOffsetsFromLevel(dropOffsets, 0);
    for (let h = 1; h < this.path.length; h++) {
      dropOffsets = computedOffsets;
      computedOffsets = nextComputedOffsets(computedOffsets);
      dropOffsetsFromLevel(dropOffsets, h);
    }
  }
};

// node_modules/@bsv/sdk/dist/esm/src/transaction/http/NodejsHttpClient.js
var NodejsHttpClient = class {
  constructor(https) {
    __publicField(this, "https");
    this.https = https;
  }
  async request(url, requestOptions) {
    return await new Promise((resolve, reject) => {
      const req = this.https.request(url, requestOptions, (res) => {
        let body = "";
        res.on("data", (chunk) => {
          body += chunk;
        });
        res.on("end", () => {
          const ok = res.statusCode >= 200 && res.statusCode <= 299;
          const mediaType = res.headers["content-type"];
          const data = body && mediaType.startsWith("application/json") ? JSON.parse(body) : body;
          resolve({
            status: res.statusCode,
            statusText: res.statusMessage,
            ok,
            data
          });
        });
      });
      req.on("error", (error) => {
        reject(error);
      });
      if (!!requestOptions.data) {
        req.write(JSON.stringify(requestOptions.data));
      }
      req.end();
    });
  }
};

// node_modules/@bsv/sdk/dist/esm/src/transaction/http/FetchHttpClient.js
var FetchHttpClient = class {
  constructor(fetch) {
    __publicField(this, "fetch");
    this.fetch = fetch;
  }
  async request(url, options) {
    const fetchOptions = {
      method: options.method,
      headers: options.headers,
      body: JSON.stringify(options.data)
    };
    const res = await this.fetch(url, fetchOptions);
    const mediaType = res.headers.get("Content-Type");
    const data = mediaType.startsWith("application/json") ? await res.json() : await res.text();
    return {
      ok: res.ok,
      status: res.status,
      statusText: res.statusText,
      data
    };
  }
};

// node_modules/@bsv/sdk/dist/esm/src/transaction/http/DefaultHttpClient.js
function defaultHttpClient() {
  const noHttpClient = {
    request(..._) {
      throw new Error("No method available to perform HTTP request");
    }
  };
  if (typeof window !== "undefined" && typeof window.fetch === "function") {
    return new FetchHttpClient(window.fetch);
  } else if (typeof __require !== "undefined") {
    try {
      const https = require_https();
      return new NodejsHttpClient(https);
    } catch (e) {
      return noHttpClient;
    }
  } else {
    return noHttpClient;
  }
}

// node_modules/@bsv/sdk/dist/esm/src/transaction/broadcasters/ARC.js
function defaultDeploymentId() {
  return `ts-sdk-${toHex(Random_default(16))}`;
}
var ARC = class {
  constructor(URL, config) {
    __publicField(this, "URL");
    __publicField(this, "apiKey");
    __publicField(this, "deploymentId");
    __publicField(this, "callbackUrl");
    __publicField(this, "callbackToken");
    __publicField(this, "headers");
    __publicField(this, "httpClient");
    this.URL = URL;
    if (typeof config === "string") {
      this.apiKey = config;
      this.httpClient = defaultHttpClient();
      this.deploymentId = defaultDeploymentId();
      this.callbackToken = void 0;
      this.callbackUrl = void 0;
    } else {
      const { apiKey, deploymentId, httpClient, callbackToken, callbackUrl, headers } = config ?? {};
      this.apiKey = apiKey;
      this.httpClient = httpClient ?? defaultHttpClient();
      this.deploymentId = deploymentId ?? defaultDeploymentId();
      this.callbackToken = callbackToken;
      this.callbackUrl = callbackUrl;
      this.headers = headers;
    }
  }
  /**
   * Broadcasts a transaction via ARC.
   *
   * @param {Transaction} tx - The transaction to be broadcasted.
   * @returns {Promise<BroadcastResponse | BroadcastFailure>} A promise that resolves to either a success or failure response.
   */
  async broadcast(tx) {
    let rawTx;
    try {
      rawTx = tx.toHexEF();
    } catch (error) {
      if (error.message === "All inputs must have source transactions when serializing to EF format") {
        rawTx = tx.toHex();
      } else {
        throw error;
      }
    }
    const requestOptions = {
      method: "POST",
      headers: this.requestHeaders(),
      data: { rawTx }
    };
    try {
      const response = await this.httpClient.request(`${this.URL}/v1/tx`, requestOptions);
      if (response.ok) {
        const { txid, extraInfo, txStatus } = response.data;
        return {
          status: "success",
          txid,
          message: `${txStatus} ${extraInfo}`
        };
      } else {
        const st = typeof response.status;
        const r2 = {
          status: "error",
          code: st === "number" || st === "string" ? response.status.toString() : "ERR_UNKNOWN",
          description: "Unknown error"
        };
        let d = response.data;
        if (typeof d === "string") {
          try {
            d = JSON.parse(response.data);
          } catch {
          }
        }
        if (typeof d === "object") {
          r2.more = d;
          if (typeof d.txid === "string") {
            r2.txid = d.txid;
          }
          if (typeof d.detail === "string") {
            r2.description = d.detail;
          }
        }
        return r2;
      }
    } catch (error) {
      return {
        status: "error",
        code: "500",
        description: typeof error.message === "string" ? error.message : "Internal Server Error"
      };
    }
  }
  requestHeaders() {
    const headers = {
      "Content-Type": "application/json",
      "XDeployment-ID": this.deploymentId
    };
    if (this.apiKey) {
      headers["Authorization"] = `Bearer ${this.apiKey}`;
    }
    if (this.callbackUrl) {
      headers["X-CallbackUrl"] = this.callbackUrl;
    }
    if (this.callbackToken) {
      headers["X-CallbackToken"] = this.callbackToken;
    }
    if (!!this.headers) {
      for (const key in this.headers) {
        headers[key] = this.headers[key];
      }
    }
    return headers;
  }
};

// node_modules/@bsv/sdk/dist/esm/src/transaction/broadcasters/DefaultBroadcaster.js
function defaultBroadcaster() {
  return new ARC("https://arc.taal.com");
}

// node_modules/@bsv/sdk/dist/esm/src/transaction/chaintrackers/WhatsOnChain.js
var WhatsOnChain = class {
  /**
   * Constructs an instance of the WhatsOnChain ChainTracker.
   *
   * @param {'main' | 'test' | 'stn'} network - The BSV network to use when calling the WhatsOnChain API.
   * @param {WhatsOnChainConfig} config - Configuration options for the WhatsOnChain ChainTracker.
   */
  constructor(network = "main", config = {}) {
    __publicField(this, "network");
    __publicField(this, "apiKey");
    __publicField(this, "URL");
    __publicField(this, "httpClient");
    const { apiKey, httpClient } = config;
    this.network = network;
    this.URL = `https://api.whatsonchain.com/v1/bsv/${network}`;
    this.httpClient = httpClient ?? defaultHttpClient();
    this.apiKey = apiKey;
  }
  async isValidRootForHeight(root, height) {
    const requestOptions = {
      method: "GET",
      headers: this.getHeaders()
    };
    const response = await this.httpClient.request(`${this.URL}/block/${height}/header`, requestOptions);
    if (response.ok) {
      const { merkleroot } = response.data;
      return merkleroot === root;
    } else if (response.status === 404) {
      return false;
    } else {
      throw new Error(`Failed to verify merkleroot for height ${height} because of an error: ${JSON.stringify(response.data)} `);
    }
  }
  getHeaders() {
    const headers = {
      "Accept": "application/json"
    };
    if (this.apiKey) {
      headers["Authorization"] = this.apiKey;
    }
    return headers;
  }
};

// node_modules/@bsv/sdk/dist/esm/src/transaction/chaintrackers/DefaultChainTracker.js
function defaultChainTracker() {
  return new WhatsOnChain();
}

// node_modules/@bsv/sdk/dist/esm/src/transaction/Transaction.js
var Transaction = class _Transaction {
  constructor(version = 1, inputs = [], outputs = [], lockTime = 0, metadata = {}, merklePath) {
    __publicField(this, "version");
    __publicField(this, "inputs");
    __publicField(this, "outputs");
    __publicField(this, "lockTime");
    __publicField(this, "metadata");
    __publicField(this, "merklePath");
    __publicField(this, "cachedHash");
    this.version = version;
    this.inputs = inputs;
    this.outputs = outputs;
    this.lockTime = lockTime;
    this.metadata = metadata;
    this.merklePath = merklePath;
  }
  /**
   * Creates a new transaction, linked to its inputs and their associated merkle paths, from a BEEF (BRC-62) structure.
   * @param beef A binary representation of a transaction in BEEF format.
   * @returns An anchored transaction, linked to its associated inputs populated with merkle paths.
   */
  static fromBEEF(beef) {
    const reader = new Reader(beef);
    const version = reader.readUInt32LE();
    if (version !== 4022206465) {
      throw new Error(`Invalid BEEF version. Expected 4022206465, received ${version}.`);
    }
    const numberOfBUMPs = reader.readVarIntNum();
    const BUMPs = [];
    for (let i = 0; i < numberOfBUMPs; i++) {
      BUMPs.push(MerklePath.fromReader(reader));
    }
    const numberOfTransactions = reader.readVarIntNum();
    const transactions = {};
    let lastTXID;
    for (let i = 0; i < numberOfTransactions; i++) {
      const tx = _Transaction.fromReader(reader);
      const obj = { tx };
      const txid = tx.id("hex");
      if (i + 1 === numberOfTransactions) {
        lastTXID = txid;
      }
      const hasBump = Boolean(reader.readUInt8());
      if (hasBump) {
        obj.pathIndex = reader.readVarIntNum();
      }
      transactions[txid] = obj;
    }
    const addPathOrInputs = (obj) => {
      if (typeof obj.pathIndex === "number") {
        const path = BUMPs[obj.pathIndex];
        if (typeof path !== "object") {
          throw new Error("Invalid merkle path index found in BEEF!");
        }
        obj.tx.merklePath = path;
      } else {
        for (let i = 0; i < obj.tx.inputs.length; i++) {
          const input = obj.tx.inputs[i];
          const sourceObj = transactions[input.sourceTXID];
          if (typeof sourceObj !== "object") {
            throw new Error(`Reference to unknown TXID in BUMP: ${input.sourceTXID}`);
          }
          input.sourceTransaction = sourceObj.tx;
          addPathOrInputs(sourceObj);
        }
      }
    };
    addPathOrInputs(transactions[lastTXID]);
    return transactions[lastTXID].tx;
  }
  /**
   * Creates a new transaction, linked to its inputs and their associated merkle paths, from a EF (BRC-30) structure.
   * @param ef A binary representation of a transaction in EF format.
   * @returns An extended transaction, linked to its associated inputs by locking script and satoshis amounts only.
   */
  static fromEF(ef) {
    const br = new Reader(ef);
    const version = br.readUInt32LE();
    if (toHex(br.read(6)) !== "0000000000ef")
      throw new Error("Invalid EF marker");
    const inputsLength = br.readVarIntNum();
    const inputs = [];
    for (let i = 0; i < inputsLength; i++) {
      const sourceTXID = toHex(br.readReverse(32));
      const sourceOutputIndex = br.readUInt32LE();
      const scriptLength = br.readVarIntNum();
      const scriptBin = br.read(scriptLength);
      const unlockingScript = UnlockingScript.fromBinary(scriptBin);
      const sequence = br.readUInt32LE();
      const satoshis = br.readUInt64LEBn().toNumber();
      const lockingScriptLength = br.readVarIntNum();
      const lockingScriptBin = br.read(lockingScriptLength);
      const lockingScript = LockingScript.fromBinary(lockingScriptBin);
      const sourceTransaction = new _Transaction(null, [], [], null);
      sourceTransaction.outputs = Array(sourceOutputIndex + 1).fill(null);
      sourceTransaction.outputs[sourceOutputIndex] = {
        satoshis,
        lockingScript
      };
      inputs.push({
        sourceTransaction,
        sourceTXID,
        sourceOutputIndex,
        unlockingScript,
        sequence
      });
    }
    const outputsLength = br.readVarIntNum();
    const outputs = [];
    for (let i = 0; i < outputsLength; i++) {
      const satoshis = br.readUInt64LEBn().toNumber();
      const scriptLength = br.readVarIntNum();
      const scriptBin = br.read(scriptLength);
      const lockingScript = LockingScript.fromBinary(scriptBin);
      outputs.push({
        satoshis,
        lockingScript
      });
    }
    const lockTime = br.readUInt32LE();
    return new _Transaction(version, inputs, outputs, lockTime);
  }
  /**
   * Since the validation of blockchain data is atomically transaction data validation,
   * any application seeking to validate data in output scripts must store the entire transaction as well.
   * Since the transaction data includes the output script data, saving a second copy of potentially
   * large scripts can bloat application storage requirements.
   *
   * This function efficiently parses binary transaction data to determine the offsets and lengths of each script.
   * This supports the efficient retreival of script data from transaction data.
   *
   * @param bin binary transaction data
   * @returns {
   *   inputs: { vin: number, offset: number, length: number }[]
   *   outputs: { vout: number, offset: number, length: number }[]
   * }
   */
  static parseScriptOffsets(bin) {
    const br = new Reader(bin);
    const inputs = [];
    const outputs = [];
    br.pos += 4;
    const inputsLength = br.readVarIntNum();
    for (let i = 0; i < inputsLength; i++) {
      br.pos += 36;
      const scriptLength = br.readVarIntNum();
      inputs.push({ vin: i, offset: br.pos, length: scriptLength });
      br.pos += scriptLength + 4;
    }
    const outputsLength = br.readVarIntNum();
    for (let i = 0; i < outputsLength; i++) {
      br.pos += 8;
      const scriptLength = br.readVarIntNum();
      outputs.push({ vout: i, offset: br.pos, length: scriptLength });
      br.pos += scriptLength;
    }
    return { inputs, outputs };
  }
  static fromReader(br) {
    const version = br.readUInt32LE();
    const inputsLength = br.readVarIntNum();
    const inputs = [];
    for (let i = 0; i < inputsLength; i++) {
      const sourceTXID = toHex(br.readReverse(32));
      const sourceOutputIndex = br.readUInt32LE();
      const scriptLength = br.readVarIntNum();
      const scriptBin = br.read(scriptLength);
      const unlockingScript = UnlockingScript.fromBinary(scriptBin);
      const sequence = br.readUInt32LE();
      inputs.push({
        sourceTXID,
        sourceOutputIndex,
        unlockingScript,
        sequence
      });
    }
    const outputsLength = br.readVarIntNum();
    const outputs = [];
    for (let i = 0; i < outputsLength; i++) {
      const satoshis = br.readUInt64LEBn().toNumber();
      const scriptLength = br.readVarIntNum();
      const scriptBin = br.read(scriptLength);
      const lockingScript = LockingScript.fromBinary(scriptBin);
      outputs.push({
        satoshis,
        lockingScript
      });
    }
    const lockTime = br.readUInt32LE();
    return new _Transaction(version, inputs, outputs, lockTime);
  }
  /**
   * Creates a Transaction instance from a binary array.
   *
   * @static
   * @param {number[]} bin - The binary array representation of the transaction.
   * @returns {Transaction} - A new Transaction instance.
   */
  static fromBinary(bin) {
    const br = new Reader(bin);
    return _Transaction.fromReader(br);
  }
  /**
   * Creates a Transaction instance from a hexadecimal string.
   *
   * @static
   * @param {string} hex - The hexadecimal string representation of the transaction.
   * @returns {Transaction} - A new Transaction instance.
   */
  static fromHex(hex) {
    return _Transaction.fromBinary(toArray2(hex, "hex"));
  }
  /**
   * Creates a Transaction instance from a hexadecimal string encoded EF.
   *
   * @static
   * @param {string} hex - The hexadecimal string representation of the transaction EF.
   * @returns {Transaction} - A new Transaction instance.
   */
  static fromHexEF(hex) {
    return _Transaction.fromEF(toArray2(hex, "hex"));
  }
  /**
   * Creates a Transaction instance from a hexadecimal string encoded BEEF.
   *
   * @static
   * @param {string} hex - The hexadecimal string representation of the transaction BEEF.
   * @returns {Transaction} - A new Transaction instance.
   */
  static fromHexBEEF(hex) {
    return _Transaction.fromBEEF(toArray2(hex, "hex"));
  }
  /**
   * Adds a new input to the transaction.
   *
   * @param {TransactionInput} input - The TransactionInput object to add to the transaction.
   * @throws {Error} - If the input does not have a sourceTXID or sourceTransaction defined.
   */
  addInput(input) {
    if (typeof input.sourceTXID === "undefined" && typeof input.sourceTransaction === "undefined") {
      throw new Error("A reference to an an input transaction is required. If the input transaction itself cannot be referenced, its TXID must still be provided.");
    }
    if (typeof input.sequence === "undefined") {
      input.sequence = 4294967295;
    }
    this.cachedHash = void 0;
    this.inputs.push(input);
  }
  /**
   * Adds a new output to the transaction.
   *
   * @param {TransactionOutput} output - The TransactionOutput object to add to the transaction.
   */
  addOutput(output) {
    this.cachedHash = void 0;
    this.outputs.push(output);
  }
  /**
   * Updates the transaction's metadata.
   *
   * @param {Record<string, any>} metadata - The metadata object to merge into the existing metadata.
   */
  updateMetadata(metadata) {
    this.metadata = {
      ...this.metadata,
      ...metadata
    };
  }
  /**
   * Computes fees prior to signing.
   * If no fee model is provided, uses a SatoshisPerKilobyte fee model that pays 10 sat/kb.
   * If fee is a number, the transaction uses that value as fee.
   *
   * @param modelOrFee - The initialized fee model to use or fixed fee for the transaction
   * @param changeDistribution - Specifies how the change should be distributed
   * amongst the change outputs
   *
   * TODO: Benford's law change distribution.
   */
  async fee(modelOrFee, changeDistribution = "equal") {
    this.cachedHash = void 0;
    if (typeof modelOrFee === "undefined") {
      modelOrFee = new SatoshisPerKilobyte(10);
    }
    if (typeof modelOrFee === "number") {
      const sats = modelOrFee;
      modelOrFee = {
        computeFee: async () => sats
      };
    }
    const fee = await modelOrFee.computeFee(this);
    let change = 0;
    for (const input of this.inputs) {
      if (typeof input.sourceTransaction !== "object") {
        throw new Error("Source transactions are required for all inputs during fee computation");
      }
      change += input.sourceTransaction.outputs[input.sourceOutputIndex].satoshis;
    }
    change -= fee;
    let changeCount = 0;
    for (const out of this.outputs) {
      if (!out.change) {
        change -= out.satoshis;
      } else {
        changeCount++;
      }
    }
    if (change <= changeCount) {
      for (let i = 0; i < this.outputs.length; i++) {
        if (this.outputs[i].change) {
          this.outputs.splice(i, 1);
          i--;
        }
      }
      return;
    }
    if (changeDistribution === "random") {
      throw new Error("Not yet implemented");
    } else if (changeDistribution === "equal") {
      const perOutput = Math.floor(change / changeCount);
      for (const out of this.outputs) {
        if (out.change) {
          out.satoshis = perOutput;
        }
      }
    }
  }
  /**
   * Utility method that returns the current fee based on inputs and outputs
   *
   * @returns The current transaction fee
   */
  getFee() {
    let totalIn = 0;
    for (const input of this.inputs) {
      if (typeof input.sourceTransaction !== "object") {
        throw new Error("Source transactions or sourceSatoshis are required for all inputs to calculate fee");
      }
      totalIn += input.sourceTransaction.outputs[input.sourceOutputIndex].satoshis;
    }
    let totalOut = 0;
    for (const output of this.outputs) {
      totalOut += output.satoshis || 0;
    }
    return totalIn - totalOut;
  }
  /**
   * Signs a transaction, hydrating all its unlocking scripts based on the provided script templates where they are available.
   */
  async sign() {
    this.cachedHash = void 0;
    for (const out of this.outputs) {
      if (typeof out.satoshis === "undefined") {
        if (out.change) {
          throw new Error("There are still change outputs with uncomputed amounts. Use the fee() method to compute the change amounts and transaction fees prior to signing.");
        } else {
          throw new Error("One or more transaction outputs is missing an amount. Ensure all output amounts are provided before signing.");
        }
      }
    }
    const unlockingScripts = await Promise.all(this.inputs.map(async (x, i) => {
      if (typeof this.inputs[i].unlockingScriptTemplate === "object") {
        return await this.inputs[i].unlockingScriptTemplate.sign(this, i);
      } else {
        return await Promise.resolve(void 0);
      }
    }));
    for (let i = 0, l = this.inputs.length; i < l; i++) {
      if (typeof this.inputs[i].unlockingScriptTemplate === "object") {
        this.inputs[i].unlockingScript = unlockingScripts[i];
      }
    }
  }
  /**
   * Broadcasts a transaction.
   *
   * @param broadcaster The Broadcaster instance wwhere the transaction will be sent
   * @returns A BroadcastResponse or BroadcastFailure from the Broadcaster
   */
  async broadcast(broadcaster = defaultBroadcaster()) {
    return await broadcaster.broadcast(this);
  }
  /**
   * Converts the transaction to a binary array format.
   *
   * @returns {number[]} - The binary array representation of the transaction.
   */
  toBinary() {
    const writer = new Writer();
    writer.writeUInt32LE(this.version);
    writer.writeVarIntNum(this.inputs.length);
    for (const i of this.inputs) {
      if (typeof i.sourceTXID === "undefined") {
        writer.write(i.sourceTransaction.hash());
      } else {
        writer.writeReverse(toArray2(i.sourceTXID, "hex"));
      }
      writer.writeUInt32LE(i.sourceOutputIndex);
      const scriptBin = i.unlockingScript.toBinary();
      writer.writeVarIntNum(scriptBin.length);
      writer.write(scriptBin);
      writer.writeUInt32LE(i.sequence);
    }
    writer.writeVarIntNum(this.outputs.length);
    for (const o of this.outputs) {
      writer.writeUInt64LE(o.satoshis);
      const scriptBin = o.lockingScript.toBinary();
      writer.writeVarIntNum(scriptBin.length);
      writer.write(scriptBin);
    }
    writer.writeUInt32LE(this.lockTime);
    return writer.toArray();
  }
  /**
   * Converts the transaction to a BRC-30 EF format.
   *
   * @returns {number[]} - The BRC-30 EF representation of the transaction.
   */
  toEF() {
    const writer = new Writer();
    writer.writeUInt32LE(this.version);
    writer.write([0, 0, 0, 0, 0, 239]);
    writer.writeVarIntNum(this.inputs.length);
    for (const i of this.inputs) {
      if (typeof i.sourceTransaction === "undefined") {
        throw new Error("All inputs must have source transactions when serializing to EF format");
      }
      if (typeof i.sourceTXID === "undefined") {
        writer.write(i.sourceTransaction.hash());
      } else {
        writer.write(toArray2(i.sourceTXID, "hex").reverse());
      }
      writer.writeUInt32LE(i.sourceOutputIndex);
      const scriptBin = i.unlockingScript.toBinary();
      writer.writeVarIntNum(scriptBin.length);
      writer.write(scriptBin);
      writer.writeUInt32LE(i.sequence);
      writer.writeUInt64LE(i.sourceTransaction.outputs[i.sourceOutputIndex].satoshis);
      const lockingScriptBin = i.sourceTransaction.outputs[i.sourceOutputIndex].lockingScript.toBinary();
      writer.writeVarIntNum(lockingScriptBin.length);
      writer.write(lockingScriptBin);
    }
    writer.writeVarIntNum(this.outputs.length);
    for (const o of this.outputs) {
      writer.writeUInt64LE(o.satoshis);
      const scriptBin = o.lockingScript.toBinary();
      writer.writeVarIntNum(scriptBin.length);
      writer.write(scriptBin);
    }
    writer.writeUInt32LE(this.lockTime);
    return writer.toArray();
  }
  /**
   * Converts the transaction to a hexadecimal string EF.
   *
   * @returns {string} - The hexadecimal string representation of the transaction EF.
   */
  toHexEF() {
    return toHex(this.toEF());
  }
  /**
   * Converts the transaction to a hexadecimal string format.
   *
   * @returns {string} - The hexadecimal string representation of the transaction.
   */
  toHex() {
    return toHex(this.toBinary());
  }
  /**
   * Converts the transaction to a hexadecimal string BEEF.
   *
   * @returns {string} - The hexadecimal string representation of the transaction BEEF.
   */
  toHexBEEF() {
    return toHex(this.toBEEF());
  }
  /**
   * Calculates the transaction's hash.
   *
   * @param {'hex' | undefined} enc - The encoding to use for the hash. If 'hex', returns a hexadecimal string; otherwise returns a binary array.
   * @returns {string | number[]} - The hash of the transaction in the specified format.
   */
  hash(enc) {
    let hash;
    if (this.cachedHash) {
      hash = this.cachedHash;
    } else {
      hash = hash256(this.toBinary());
      this.cachedHash = hash;
    }
    if (enc === "hex") {
      return toHex(hash);
    } else {
      return hash;
    }
  }
  /**
   * Calculates the transaction's ID.
   *
   * @param {'hex' | undefined} enc - The encoding to use for the ID. If 'hex', returns a hexadecimal string; otherwise returns a binary array.
   * @returns {string | number[]} - The ID of the transaction in the specified format.
   */
  id(enc) {
    const id = [...this.hash()];
    id.reverse();
    if (enc === "hex") {
      return toHex(id);
    }
    return id;
  }
  /**
   * Verifies the legitimacy of the Bitcoin transaction according to the rules of SPV by ensuring all the input transactions link back to valid block headers, the chain of spends for all inputs are valid, and the sum of inputs is not less than the sum of outputs.
   *
   * @param chainTracker - An instance of ChainTracker, a Bitcoin block header tracker. If the value is set to 'scripts only', headers will not be verified. If not provided then the default chain tracker will be used.
   *
   * @returns Whether the transaction is valid according to the rules of SPV.
   *
   * @example tx.verify(new WhatsOnChain(), new SatoshisPerKilobyte(1))
   */
  async verify(chainTracker = defaultChainTracker(), feeModel) {
    if (typeof this.merklePath === "object" && chainTracker !== "scripts only") {
      const proofValid = await this.merklePath.verify(this.id("hex"), chainTracker);
      if (proofValid) {
        return true;
      }
    }
    if (typeof feeModel !== "undefined") {
      const cpTx = _Transaction.fromHexEF(this.toHexEF());
      delete cpTx.outputs[0].satoshis;
      cpTx.outputs[0].change = true;
      await cpTx.fee(feeModel);
      if (this.getFee() < cpTx.getFee())
        throw new Error(`Verification failed because the transaction ${this.id("hex")} has an insufficient fee and has not been mined.`);
    }
    let inputTotal = 0;
    for (let i = 0; i < this.inputs.length; i++) {
      const input = this.inputs[i];
      if (typeof input.sourceTransaction !== "object") {
        throw new Error(`Verification failed because the input at index ${i} of transaction ${this.id("hex")} is missing an associated source transaction. This source transaction is required for transaction verification because there is no merkle proof for the transaction spending a UTXO it contains.`);
      }
      if (typeof input.unlockingScript !== "object") {
        throw new Error(`Verification failed because the input at index ${i} of transaction ${this.id("hex")} is missing an associated unlocking script. This script is required for transaction verification because there is no merkle proof for the transaction spending the UTXO.`);
      }
      const sourceOutput = input.sourceTransaction.outputs[input.sourceOutputIndex];
      inputTotal += sourceOutput.satoshis;
      const inputVerified = await input.sourceTransaction.verify(chainTracker, feeModel);
      if (!inputVerified) {
        return false;
      }
      const otherInputs = [...this.inputs];
      otherInputs.splice(i, 1);
      if (typeof input.sourceTXID === "undefined") {
        input.sourceTXID = input.sourceTransaction.id("hex");
      }
      const spend = new Spend({
        sourceTXID: input.sourceTXID,
        sourceOutputIndex: input.sourceOutputIndex,
        lockingScript: sourceOutput.lockingScript,
        sourceSatoshis: sourceOutput.satoshis,
        transactionVersion: this.version,
        otherInputs,
        unlockingScript: input.unlockingScript,
        inputSequence: input.sequence,
        inputIndex: i,
        outputs: this.outputs,
        lockTime: this.lockTime
      });
      const spendValid = spend.validate();
      if (!spendValid) {
        return false;
      }
    }
    let outputTotal = 0;
    for (const out of this.outputs) {
      if (typeof out.satoshis !== "number") {
        throw new Error("Every output must have a defined amount during transaction verification.");
      }
      outputTotal += out.satoshis;
    }
    return outputTotal <= inputTotal;
  }
  /**
   * Serializes this transaction, together with its inputs and the respective merkle proofs, into the BEEF (BRC-62) format. This enables efficient verification of its compliance with the rules of SPV.
   *
   * @returns The serialized BEEF structure
   */
  toBEEF() {
    const writer = new Writer();
    writer.writeUInt32LE(4022206465);
    const BUMPs = [];
    const txs = [];
    const addPathsAndInputs = (tx) => {
      const obj = { tx };
      const hasProof = typeof tx.merklePath === "object";
      if (hasProof) {
        let added = false;
        for (let i = 0; i < BUMPs.length; i++) {
          if (BUMPs[i] === tx.merklePath) {
            obj.pathIndex = i;
            added = true;
            break;
          }
          if (BUMPs[i].blockHeight === tx.merklePath.blockHeight) {
            const rootA = BUMPs[i].computeRoot();
            const rootB = tx.merklePath.computeRoot();
            if (rootA === rootB) {
              BUMPs[i].combine(tx.merklePath);
              obj.pathIndex = i;
              added = true;
              break;
            }
          }
        }
        if (!added) {
          obj.pathIndex = BUMPs.length;
          BUMPs.push(tx.merklePath);
        }
      }
      const duplicate = txs.some((x) => x.tx.id("hex") === tx.id("hex"));
      if (!duplicate) {
        txs.unshift(obj);
      }
      if (!hasProof) {
        for (let i = 0; i < tx.inputs.length; i++) {
          const input = tx.inputs[i];
          if (typeof input.sourceTransaction !== "object") {
            throw new Error("A required source transaction is missing!");
          }
          addPathsAndInputs(input.sourceTransaction);
        }
      }
    };
    addPathsAndInputs(this);
    writer.writeVarIntNum(BUMPs.length);
    for (const b of BUMPs) {
      writer.write(b.toBinary());
    }
    writer.writeVarIntNum(txs.length);
    for (const t of txs) {
      writer.write(t.tx.toBinary());
      if (typeof t.pathIndex === "number") {
        writer.writeUInt8(1);
        writer.writeVarIntNum(t.pathIndex);
      } else {
        writer.writeUInt8(0);
      }
    }
    return writer.toArray();
  }
};

// node_modules/@bsv/sdk/dist/esm/src/transaction/Broadcaster.js
function isBroadcastResponse(r2) {
  return r2.status === "success";
}
function isBroadcastFailure(r2) {
  return r2.status === "error";
}

// node_modules/@bsv/sdk/dist/esm/src/transaction/broadcasters/WhatsOnChainBroadcaster.js
var WhatsOnChainBroadcaster = class {
  /**
   * Constructs an instance of the WhatsOnChain broadcaster.
   *
   * @param {'main' | 'test' | 'stn'} network - The BSV network to use when calling the WhatsOnChain API.
   * @param {HttpClient} httpClient - The HTTP client used to make requests to the API.
   */
  constructor(network = "main", httpClient = defaultHttpClient()) {
    __publicField(this, "network");
    __publicField(this, "URL");
    __publicField(this, "httpClient");
    this.network = network;
    this.URL = `https://api.whatsonchain.com/v1/bsv/${network}/tx/raw`;
    this.httpClient = httpClient;
  }
  /**
   * Broadcasts a transaction via WhatsOnChain.
   *
   * @param {Transaction} tx - The transaction to be broadcasted.
   * @returns {Promise<BroadcastResponse | BroadcastFailure>} A promise that resolves to either a success or failure response.
   */
  async broadcast(tx) {
    let rawTx = tx.toHex();
    const requestOptions = {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "Accept": "text/plain"
      },
      data: { txhex: rawTx }
    };
    try {
      const response = await this.httpClient.request(this.URL, requestOptions);
      if (response.ok) {
        const txid = response.data;
        return {
          status: "success",
          txid,
          message: "broadcast successful"
        };
      } else {
        return {
          status: "error",
          code: response.status.toString() ?? "ERR_UNKNOWN",
          description: response.data ?? "Unknown error"
        };
      }
    } catch (error) {
      return {
        status: "error",
        code: "500",
        description: typeof error.message === "string" ? error.message : "Internal Server Error"
      };
    }
  }
};

// node_modules/@bsv/sdk/dist/esm/src/messages/SignedMessage.js
var SignedMessage_exports = {};
__export(SignedMessage_exports, {
  sign: () => sign2,
  verify: () => verify2
});
var VERSION = "42423301";
var sign2 = (message, signer, verifier) => {
  const recipientAnyone = typeof verifier !== "object";
  if (recipientAnyone) {
    const curve = new Curve();
    const anyone = new PrivateKey(1);
    const anyonePoint = curve.g.mul(anyone);
    verifier = new PublicKey(anyonePoint.x, anyonePoint.y);
  }
  const keyID = Random_default(32);
  const keyIDBase64 = toBase64(keyID);
  const invoiceNumber = `2-message signing-${keyIDBase64}`;
  const signingKey = signer.deriveChild(verifier, invoiceNumber);
  const signature = signingKey.sign(message).toDER();
  const senderPublicKey = signer.toPublicKey().encode(true);
  const version = toArray2(VERSION, "hex");
  return [
    ...version,
    ...senderPublicKey,
    ...recipientAnyone ? [0] : verifier.encode(true),
    ...keyID,
    ...signature
  ];
};
var verify2 = (message, sig, recipient) => {
  const reader = new Reader(sig);
  const messageVersion = toHex(reader.read(4));
  if (messageVersion !== VERSION) {
    throw new Error(`Message version mismatch: Expected ${VERSION}, received ${messageVersion}`);
  }
  const signer = PublicKey.fromString(toHex(reader.read(33)));
  const [verifierFirst] = reader.read(1);
  if (verifierFirst === 0) {
    recipient = new PrivateKey(1);
  } else {
    const verifierRest = reader.read(32);
    const verifierDER = toHex([verifierFirst, ...verifierRest]);
    if (typeof recipient !== "object") {
      throw new Error(`This signature can only be verified with knowledge of a specific private key. The associated public key is: ${verifierDER}`);
    }
    const recipientDER = recipient.toPublicKey().encode(true, "hex");
    if (verifierDER !== recipientDER) {
      throw new Error(`The recipient public key is ${recipientDER} but the signature requres the recipient to have public key ${verifierDER}`);
    }
  }
  const keyID = toBase64(reader.read(32));
  const signatureDER = toHex(reader.read(reader.bin.length - reader.pos));
  const signature = Signature.fromDER(signatureDER, "hex");
  const invoiceNumber = `2-message signing-${keyID}`;
  const signingKey = signer.deriveChild(recipient, invoiceNumber);
  const verified = signingKey.verify(message, signature);
  return verified;
};

// node_modules/@bsv/sdk/dist/esm/src/messages/EncryptedMessage.js
var EncryptedMessage_exports = {};
__export(EncryptedMessage_exports, {
  decrypt: () => decrypt,
  encrypt: () => encrypt
});
var VERSION2 = "42421033";
var encrypt = (message, sender, recipient) => {
  const keyID = Random_default(32);
  const keyIDBase64 = toBase64(keyID);
  const invoiceNumber = `2-message encryption-${keyIDBase64}`;
  const signingPriv = sender.deriveChild(recipient, invoiceNumber);
  const recipientPub = recipient.deriveChild(sender, invoiceNumber);
  const sharedSecret = signingPriv.deriveSharedSecret(recipientPub);
  const symmetricKey = new SymmetricKey(sharedSecret.encode(true).slice(1));
  const encrypted = symmetricKey.encrypt(message);
  const senderPublicKey = sender.toPublicKey().encode(true);
  const version = toArray2(VERSION2, "hex");
  return [
    ...version,
    ...senderPublicKey,
    ...recipient.encode(true),
    ...keyID,
    ...encrypted
  ];
};
var decrypt = (message, recipient) => {
  const reader = new Reader(message);
  const messageVersion = toHex(reader.read(4));
  if (messageVersion !== VERSION2) {
    throw new Error(`Message version mismatch: Expected ${VERSION2}, received ${messageVersion}`);
  }
  const sender = PublicKey.fromString(toHex(reader.read(33)));
  const expectedRecipientDER = toHex(reader.read(33));
  const actualRecipientDER = recipient.toPublicKey().encode(true, "hex");
  if (expectedRecipientDER !== actualRecipientDER) {
    throw new Error(`The encrypted message expects a recipient public key of ${expectedRecipientDER}, but the provided key is ${actualRecipientDER}`);
  }
  const keyID = toBase64(reader.read(32));
  const encrypted = reader.read(reader.bin.length - reader.pos);
  const invoiceNumber = `2-message encryption-${keyID}`;
  const signingPriv = sender.deriveChild(recipient, invoiceNumber);
  const recipientPub = recipient.deriveChild(sender, invoiceNumber);
  const sharedSecret = signingPriv.deriveSharedSecret(recipientPub);
  const symmetricKey = new SymmetricKey(sharedSecret.encode(true).slice(1));
  return symmetricKey.decrypt(encrypted);
};

// node_modules/@bsv/sdk/dist/esm/src/compat/BSM.js
var BSM_exports = {};
__export(BSM_exports, {
  magicHash: () => magicHash,
  sign: () => sign3,
  verify: () => verify3
});
var prefix = "Bitcoin Signed Message:\n";
var magicHash = (messageBuf) => {
  const bw = new Writer();
  bw.writeVarIntNum(prefix.length);
  bw.write(toArray2(prefix, "utf8"));
  bw.writeVarIntNum(messageBuf.length);
  bw.write(messageBuf);
  const buf = bw.toArray();
  const hashBuf = hash256(buf);
  return hashBuf;
};
var sign3 = (message, privateKey) => {
  const hashBuf = magicHash(message);
  return sign(new BigNumber(hashBuf), privateKey, true);
};
var verify3 = (message, sig, pubKey) => {
  const hashBuf = magicHash(message);
  return verify(new BigNumber(hashBuf), sig, pubKey);
};

// node_modules/@bsv/sdk/dist/esm/src/compat/HD.js
var HD = class _HD {
  /**
     * Constructor for the BIP32 HD wallet.
     * Initializes an HD wallet with optional parameters for version bytes, depth, parent fingerprint, child index, chain code, private key, and public key.
     * @param versionBytesNum - Version bytes number for the wallet.
     * @param depth - Depth of the key in the hierarchy.
     * @param parentFingerPrint - Fingerprint of the parent key.
     * @param childIndex - Index of the child key.
     * @param chainCode - Chain code for key derivation.
     * @param privKey - Private key of the wallet.
     * @param pubKey - Public key of the wallet.
     */
  constructor(versionBytesNum, depth, parentFingerPrint, childIndex, chainCode, privKey, pubKey) {
    __publicField(this, "versionBytesNum");
    __publicField(this, "depth");
    __publicField(this, "parentFingerPrint");
    __publicField(this, "childIndex");
    __publicField(this, "chainCode");
    __publicField(this, "privKey");
    __publicField(this, "pubKey");
    __publicField(this, "constants", {
      pubKey: 76067358,
      privKey: 76066276
    });
    this.versionBytesNum = versionBytesNum;
    this.depth = depth;
    this.parentFingerPrint = parentFingerPrint;
    this.childIndex = childIndex;
    this.chainCode = chainCode;
    this.privKey = privKey;
    this.pubKey = pubKey;
  }
  /**
     * Generates a new HD wallet with random keys.
     * This method creates a root HD wallet with randomly generated private and public keys.
     * @returns {HD} The current HD instance with generated keys.
     */
  fromRandom() {
    this.versionBytesNum = this.constants.privKey;
    this.depth = 0;
    this.parentFingerPrint = [0, 0, 0, 0];
    this.childIndex = 0;
    this.chainCode = Random_default(32);
    this.privKey = PrivateKey.fromRandom();
    this.pubKey = this.privKey.toPublicKey();
    return this;
  }
  /**
     * Generates a new HD wallet with random keys.
     * This method creates a root HD wallet with randomly generated private and public keys.
     * @returns {HD} A new HD instance with generated keys.
     * @static
     */
  static fromRandom() {
    return new this().fromRandom();
  }
  /**
   * Initializes the HD wallet from a given base58 encoded string.
   * This method decodes a provided string to set up the HD wallet's properties.
   * @param str - A base58 encoded string representing the wallet.
   * @returns {HD} The new instance with properties set from the string.
   */
  static fromString(str) {
    return new this().fromString(str);
  }
  /**
     * Initializes the HD wallet from a given base58 encoded string.
     * This method decodes a provided string to set up the HD wallet's properties.
     * @param str - A base58 encoded string representing the wallet.
     * @returns {HD} The current instance with properties set from the string.
     */
  fromString(str) {
    const decoded = fromBase58Check(str);
    return this.fromBinary([...decoded.prefix, ...decoded.data]);
  }
  /**
   * Initializes the HD wallet from a seed.
   * This method generates keys and other properties from a given seed, conforming to the BIP32 specification.
   * @param bytes - An array of bytes representing the seed.
   * @returns {HD} The current instance with properties set from the seed.
   */
  static fromSeed(bytes) {
    return new this().fromSeed(bytes);
  }
  /**
     * Initializes the HD wallet from a seed.
     * This method generates keys and other properties from a given seed, conforming to the BIP32 specification.
     * @param bytes - An array of bytes representing the seed.
     * @returns {HD} The current instance with properties set from the seed.
     */
  fromSeed(bytes) {
    if (bytes.length < 128 / 8) {
      throw new Error("Need more than 128 bits of entropy");
    }
    if (bytes.length > 512 / 8) {
      throw new Error("More than 512 bits of entropy is nonstandard");
    }
    const hash = sha512hmac(toArray2("Bitcoin seed", "utf8"), bytes);
    this.depth = 0;
    this.parentFingerPrint = [0, 0, 0, 0];
    this.childIndex = 0;
    this.chainCode = hash.slice(32, 64);
    this.versionBytesNum = this.constants.privKey;
    this.privKey = new PrivateKey(hash.slice(0, 32));
    this.pubKey = this.privKey.toPublicKey();
    return this;
  }
  /**
   * Initializes the HD wallet from a binary buffer.
   * Parses a binary buffer to set up the wallet's properties.
   * @param buf - A buffer containing the wallet data.
   * @returns {HD} The new instance with properties set from the buffer.
   */
  static fromBinary(buf) {
    return new this().fromBinary(buf);
  }
  /**
   * Initializes the HD wallet from a binary buffer.
   * Parses a binary buffer to set up the wallet's properties.
   * @param buf - A buffer containing the wallet data.
   * @returns {HD} The current instance with properties set from the buffer.
   */
  fromBinary(buf) {
    if (buf.length !== 78) {
      throw new Error("incorrect bip32 data length");
    }
    const reader = new Reader(buf);
    this.versionBytesNum = reader.readUInt32BE();
    this.depth = reader.readUInt8();
    this.parentFingerPrint = reader.read(4);
    this.childIndex = reader.readUInt32BE();
    this.chainCode = reader.read(32);
    const keyBytes = reader.read(33);
    const isPrivate = this.versionBytesNum === this.constants.privKey;
    const isPublic = this.versionBytesNum === this.constants.pubKey;
    if (isPrivate && keyBytes[0] === 0) {
      this.privKey = new PrivateKey(keyBytes.slice(1, 33));
      this.pubKey = this.privKey.toPublicKey();
    } else if (isPublic && (keyBytes[0] === 2 || keyBytes[0] === 3)) {
      this.pubKey = PublicKey.fromString(toHex(keyBytes));
    } else {
      throw new Error("Invalid key");
    }
    return this;
  }
  /**
   * Converts the HD wallet to a base58 encoded string.
   * This method provides a string representation of the HD wallet's current state.
   * @returns {string} A base58 encoded string of the HD wallet.
   */
  toString() {
    const bin = this.toBinary();
    return toBase58Check(bin, []);
  }
  /**
     * Derives a child HD wallet based on a given path.
     * The path specifies the hierarchy of the child key to be derived.
     * @param path - A string representing the derivation path (e.g., 'm/0'/1).
     * @returns {HD} A new HD instance representing the derived child wallet.
     */
  derive(path) {
    if (path === "m") {
      return this;
    }
    const e = path.split("/");
    let bip32 = this;
    for (const i in e) {
      const c = e[i];
      if (i === "0") {
        if (c !== "m") {
          throw new Error("invalid path");
        }
        continue;
      }
      if (parseInt(c.replace("'", ""), 10).toString() !== c.replace("'", "")) {
        throw new Error("invalid path");
      }
      const usePrivate = c.length > 1 && c[c.length - 1] === "'";
      let childIndex = parseInt(usePrivate ? c.slice(0, c.length - 1) : c, 10) & 2147483647;
      if (usePrivate) {
        childIndex += 2147483648;
      }
      bip32 = bip32.deriveChild(childIndex);
    }
    return bip32;
  }
  /**
     * Derives a child HD wallet from the current wallet based on an index.
     * This method generates either a private or public child key depending on the current wallet's state.
     * @param i - The index of the child key to derive.
     * @returns {HD} A new HD instance representing the derived child wallet.
     */
  deriveChild(i) {
    if (typeof i !== "number") {
      throw new Error("i must be a number");
    }
    const ibc = [];
    ibc.push(i >> 24 & 255);
    ibc.push(i >> 16 & 255);
    ibc.push(i >> 8 & 255);
    ibc.push(i & 255);
    const ib = [...ibc];
    const usePrivate = (i & 2147483648) !== 0;
    const isPrivate = this.versionBytesNum === this.constants.privKey;
    if (usePrivate && (!this.privKey || !isPrivate)) {
      throw new Error("Cannot do private key derivation without private key");
    }
    let ret = null;
    if (this.privKey) {
      let data = null;
      if (usePrivate) {
        data = [0, ...this.privKey.toArray("be", 32), ...ib];
      } else {
        data = [...this.pubKey.encode(true), ...ib];
      }
      const hash = sha512hmac(this.chainCode, data);
      const il = new BigNumber(hash.slice(0, 32));
      const ir = hash.slice(32, 64);
      const k = il.add(this.privKey).mod(new Curve().n);
      ret = new _HD();
      ret.chainCode = ir;
      ret.privKey = new PrivateKey(k.toArray());
      ret.pubKey = ret.privKey.toPublicKey();
    } else {
      const data = [...this.pubKey.encode(true), ...ib];
      const hash = sha512hmac(this.chainCode, data);
      const il = new BigNumber(hash.slice(0, 32));
      const ir = hash.slice(32, 64);
      const ilG = new Curve().g.mul(il);
      const Kpar = this.pubKey;
      const Ki = ilG.add(Kpar);
      const newpub = new PublicKey(Ki.x, Ki.y);
      ret = new _HD();
      ret.chainCode = ir;
      ret.pubKey = newpub;
    }
    ret.childIndex = i;
    const pubKeyhash = hash160(this.pubKey.encode(true));
    ret.parentFingerPrint = pubKeyhash.slice(0, 4);
    ret.versionBytesNum = this.versionBytesNum;
    ret.depth = this.depth + 1;
    return ret;
  }
  /**
     * Converts the current HD wallet to a public-only wallet.
     * This method strips away the private key information, leaving only the public part.
     * @returns {HD} A new HD instance representing the public-only wallet.
     */
  toPublic() {
    const bip32 = new _HD(this.versionBytesNum, this.depth, this.parentFingerPrint, this.childIndex, this.chainCode, this.privKey, this.pubKey);
    bip32.versionBytesNum = this.constants.pubKey;
    bip32.privKey = void 0;
    return bip32;
  }
  /**
     * Converts the HD wallet into a binary representation.
     * This method serializes the wallet's properties into a binary format.
     * @returns {number[]} An array of numbers representing the binary data of the wallet.
     */
  toBinary() {
    const isPrivate = this.versionBytesNum === this.constants.privKey;
    const isPublic = this.versionBytesNum === this.constants.pubKey;
    if (isPrivate) {
      return new Writer().writeUInt32BE(this.versionBytesNum).writeUInt8(this.depth).write(this.parentFingerPrint).writeUInt32BE(this.childIndex).write(this.chainCode).writeUInt8(0).write(this.privKey.toArray("be", 32)).toArray();
    } else if (isPublic) {
      return new Writer().writeUInt32BE(this.versionBytesNum).writeUInt8(this.depth).write(this.parentFingerPrint).writeUInt32BE(this.childIndex).write(this.chainCode).write(this.pubKey.encode(true)).toArray();
    } else {
      throw new Error("bip32: invalid versionBytesNum byte");
    }
  }
  /**
     * Checks if the HD wallet contains a private key.
     * This method determines whether the wallet is a private key wallet or a public key only wallet.
     * @returns {boolean} A boolean value indicating whether the wallet has a private key (true) or not (false).
     */
  isPrivate() {
    return this.versionBytesNum === this.constants.privKey;
  }
};

// node_modules/@bsv/sdk/dist/esm/src/compat/bip-39-wordlist-en.js
var wordList = {
  value: [
    "abandon",
    "ability",
    "able",
    "about",
    "above",
    "absent",
    "absorb",
    "abstract",
    "absurd",
    "abuse",
    "access",
    "accident",
    "account",
    "accuse",
    "achieve",
    "acid",
    "acoustic",
    "acquire",
    "across",
    "act",
    "action",
    "actor",
    "actress",
    "actual",
    "adapt",
    "add",
    "addict",
    "address",
    "adjust",
    "admit",
    "adult",
    "advance",
    "advice",
    "aerobic",
    "affair",
    "afford",
    "afraid",
    "again",
    "age",
    "agent",
    "agree",
    "ahead",
    "aim",
    "air",
    "airport",
    "aisle",
    "alarm",
    "album",
    "alcohol",
    "alert",
    "alien",
    "all",
    "alley",
    "allow",
    "almost",
    "alone",
    "alpha",
    "already",
    "also",
    "alter",
    "always",
    "amateur",
    "amazing",
    "among",
    "amount",
    "amused",
    "analyst",
    "anchor",
    "ancient",
    "anger",
    "angle",
    "angry",
    "animal",
    "ankle",
    "announce",
    "annual",
    "another",
    "answer",
    "antenna",
    "antique",
    "anxiety",
    "any",
    "apart",
    "apology",
    "appear",
    "apple",
    "approve",
    "april",
    "arch",
    "arctic",
    "area",
    "arena",
    "argue",
    "arm",
    "armed",
    "armor",
    "army",
    "around",
    "arrange",
    "arrest",
    "arrive",
    "arrow",
    "art",
    "artefact",
    "artist",
    "artwork",
    "ask",
    "aspect",
    "assault",
    "asset",
    "assist",
    "assume",
    "asthma",
    "athlete",
    "atom",
    "attack",
    "attend",
    "attitude",
    "attract",
    "auction",
    "audit",
    "august",
    "aunt",
    "author",
    "auto",
    "autumn",
    "average",
    "avocado",
    "avoid",
    "awake",
    "aware",
    "away",
    "awesome",
    "awful",
    "awkward",
    "axis",
    "baby",
    "bachelor",
    "bacon",
    "badge",
    "bag",
    "balance",
    "balcony",
    "ball",
    "bamboo",
    "banana",
    "banner",
    "bar",
    "barely",
    "bargain",
    "barrel",
    "base",
    "basic",
    "basket",
    "battle",
    "beach",
    "bean",
    "beauty",
    "because",
    "become",
    "beef",
    "before",
    "begin",
    "behave",
    "behind",
    "believe",
    "below",
    "belt",
    "bench",
    "benefit",
    "best",
    "betray",
    "better",
    "between",
    "beyond",
    "bicycle",
    "bid",
    "bike",
    "bind",
    "biology",
    "bird",
    "birth",
    "bitter",
    "black",
    "blade",
    "blame",
    "blanket",
    "blast",
    "bleak",
    "bless",
    "blind",
    "blood",
    "blossom",
    "blouse",
    "blue",
    "blur",
    "blush",
    "board",
    "boat",
    "body",
    "boil",
    "bomb",
    "bone",
    "bonus",
    "book",
    "boost",
    "border",
    "boring",
    "borrow",
    "boss",
    "bottom",
    "bounce",
    "box",
    "boy",
    "bracket",
    "brain",
    "brand",
    "brass",
    "brave",
    "bread",
    "breeze",
    "brick",
    "bridge",
    "brief",
    "bright",
    "bring",
    "brisk",
    "broccoli",
    "broken",
    "bronze",
    "broom",
    "brother",
    "brown",
    "brush",
    "bubble",
    "buddy",
    "budget",
    "buffalo",
    "build",
    "bulb",
    "bulk",
    "bullet",
    "bundle",
    "bunker",
    "burden",
    "burger",
    "burst",
    "bus",
    "business",
    "busy",
    "butter",
    "buyer",
    "buzz",
    "cabbage",
    "cabin",
    "cable",
    "cactus",
    "cage",
    "cake",
    "call",
    "calm",
    "camera",
    "camp",
    "can",
    "canal",
    "cancel",
    "candy",
    "cannon",
    "canoe",
    "canvas",
    "canyon",
    "capable",
    "capital",
    "captain",
    "car",
    "carbon",
    "card",
    "cargo",
    "carpet",
    "carry",
    "cart",
    "case",
    "cash",
    "casino",
    "castle",
    "casual",
    "cat",
    "catalog",
    "catch",
    "category",
    "cattle",
    "caught",
    "cause",
    "caution",
    "cave",
    "ceiling",
    "celery",
    "cement",
    "census",
    "century",
    "cereal",
    "certain",
    "chair",
    "chalk",
    "champion",
    "change",
    "chaos",
    "chapter",
    "charge",
    "chase",
    "chat",
    "cheap",
    "check",
    "cheese",
    "chef",
    "cherry",
    "chest",
    "chicken",
    "chief",
    "child",
    "chimney",
    "choice",
    "choose",
    "chronic",
    "chuckle",
    "chunk",
    "churn",
    "cigar",
    "cinnamon",
    "circle",
    "citizen",
    "city",
    "civil",
    "claim",
    "clap",
    "clarify",
    "claw",
    "clay",
    "clean",
    "clerk",
    "clever",
    "click",
    "client",
    "cliff",
    "climb",
    "clinic",
    "clip",
    "clock",
    "clog",
    "close",
    "cloth",
    "cloud",
    "clown",
    "club",
    "clump",
    "cluster",
    "clutch",
    "coach",
    "coast",
    "coconut",
    "code",
    "coffee",
    "coil",
    "coin",
    "collect",
    "color",
    "column",
    "combine",
    "come",
    "comfort",
    "comic",
    "common",
    "company",
    "concert",
    "conduct",
    "confirm",
    "congress",
    "connect",
    "consider",
    "control",
    "convince",
    "cook",
    "cool",
    "copper",
    "copy",
    "coral",
    "core",
    "corn",
    "correct",
    "cost",
    "cotton",
    "couch",
    "country",
    "couple",
    "course",
    "cousin",
    "cover",
    "coyote",
    "crack",
    "cradle",
    "craft",
    "cram",
    "crane",
    "crash",
    "crater",
    "crawl",
    "crazy",
    "cream",
    "credit",
    "creek",
    "crew",
    "cricket",
    "crime",
    "crisp",
    "critic",
    "crop",
    "cross",
    "crouch",
    "crowd",
    "crucial",
    "cruel",
    "cruise",
    "crumble",
    "crunch",
    "crush",
    "cry",
    "crystal",
    "cube",
    "culture",
    "cup",
    "cupboard",
    "curious",
    "current",
    "curtain",
    "curve",
    "cushion",
    "custom",
    "cute",
    "cycle",
    "dad",
    "damage",
    "damp",
    "dance",
    "danger",
    "daring",
    "dash",
    "daughter",
    "dawn",
    "day",
    "deal",
    "debate",
    "debris",
    "decade",
    "december",
    "decide",
    "decline",
    "decorate",
    "decrease",
    "deer",
    "defense",
    "define",
    "defy",
    "degree",
    "delay",
    "deliver",
    "demand",
    "demise",
    "denial",
    "dentist",
    "deny",
    "depart",
    "depend",
    "deposit",
    "depth",
    "deputy",
    "derive",
    "describe",
    "desert",
    "design",
    "desk",
    "despair",
    "destroy",
    "detail",
    "detect",
    "develop",
    "device",
    "devote",
    "diagram",
    "dial",
    "diamond",
    "diary",
    "dice",
    "diesel",
    "diet",
    "differ",
    "digital",
    "dignity",
    "dilemma",
    "dinner",
    "dinosaur",
    "direct",
    "dirt",
    "disagree",
    "discover",
    "disease",
    "dish",
    "dismiss",
    "disorder",
    "display",
    "distance",
    "divert",
    "divide",
    "divorce",
    "dizzy",
    "doctor",
    "document",
    "dog",
    "doll",
    "dolphin",
    "domain",
    "donate",
    "donkey",
    "donor",
    "door",
    "dose",
    "double",
    "dove",
    "draft",
    "dragon",
    "drama",
    "drastic",
    "draw",
    "dream",
    "dress",
    "drift",
    "drill",
    "drink",
    "drip",
    "drive",
    "drop",
    "drum",
    "dry",
    "duck",
    "dumb",
    "dune",
    "during",
    "dust",
    "dutch",
    "duty",
    "dwarf",
    "dynamic",
    "eager",
    "eagle",
    "early",
    "earn",
    "earth",
    "easily",
    "east",
    "easy",
    "echo",
    "ecology",
    "economy",
    "edge",
    "edit",
    "educate",
    "effort",
    "egg",
    "eight",
    "either",
    "elbow",
    "elder",
    "electric",
    "elegant",
    "element",
    "elephant",
    "elevator",
    "elite",
    "else",
    "embark",
    "embody",
    "embrace",
    "emerge",
    "emotion",
    "employ",
    "empower",
    "empty",
    "enable",
    "enact",
    "end",
    "endless",
    "endorse",
    "enemy",
    "energy",
    "enforce",
    "engage",
    "engine",
    "enhance",
    "enjoy",
    "enlist",
    "enough",
    "enrich",
    "enroll",
    "ensure",
    "enter",
    "entire",
    "entry",
    "envelope",
    "episode",
    "equal",
    "equip",
    "era",
    "erase",
    "erode",
    "erosion",
    "error",
    "erupt",
    "escape",
    "essay",
    "essence",
    "estate",
    "eternal",
    "ethics",
    "evidence",
    "evil",
    "evoke",
    "evolve",
    "exact",
    "example",
    "excess",
    "exchange",
    "excite",
    "exclude",
    "excuse",
    "execute",
    "exercise",
    "exhaust",
    "exhibit",
    "exile",
    "exist",
    "exit",
    "exotic",
    "expand",
    "expect",
    "expire",
    "explain",
    "expose",
    "express",
    "extend",
    "extra",
    "eye",
    "eyebrow",
    "fabric",
    "face",
    "faculty",
    "fade",
    "faint",
    "faith",
    "fall",
    "false",
    "fame",
    "family",
    "famous",
    "fan",
    "fancy",
    "fantasy",
    "farm",
    "fashion",
    "fat",
    "fatal",
    "father",
    "fatigue",
    "fault",
    "favorite",
    "feature",
    "february",
    "federal",
    "fee",
    "feed",
    "feel",
    "female",
    "fence",
    "festival",
    "fetch",
    "fever",
    "few",
    "fiber",
    "fiction",
    "field",
    "figure",
    "file",
    "film",
    "filter",
    "final",
    "find",
    "fine",
    "finger",
    "finish",
    "fire",
    "firm",
    "first",
    "fiscal",
    "fish",
    "fit",
    "fitness",
    "fix",
    "flag",
    "flame",
    "flash",
    "flat",
    "flavor",
    "flee",
    "flight",
    "flip",
    "float",
    "flock",
    "floor",
    "flower",
    "fluid",
    "flush",
    "fly",
    "foam",
    "focus",
    "fog",
    "foil",
    "fold",
    "follow",
    "food",
    "foot",
    "force",
    "forest",
    "forget",
    "fork",
    "fortune",
    "forum",
    "forward",
    "fossil",
    "foster",
    "found",
    "fox",
    "fragile",
    "frame",
    "frequent",
    "fresh",
    "friend",
    "fringe",
    "frog",
    "front",
    "frost",
    "frown",
    "frozen",
    "fruit",
    "fuel",
    "fun",
    "funny",
    "furnace",
    "fury",
    "future",
    "gadget",
    "gain",
    "galaxy",
    "gallery",
    "game",
    "gap",
    "garage",
    "garbage",
    "garden",
    "garlic",
    "garment",
    "gas",
    "gasp",
    "gate",
    "gather",
    "gauge",
    "gaze",
    "general",
    "genius",
    "genre",
    "gentle",
    "genuine",
    "gesture",
    "ghost",
    "giant",
    "gift",
    "giggle",
    "ginger",
    "giraffe",
    "girl",
    "give",
    "glad",
    "glance",
    "glare",
    "glass",
    "glide",
    "glimpse",
    "globe",
    "gloom",
    "glory",
    "glove",
    "glow",
    "glue",
    "goat",
    "goddess",
    "gold",
    "good",
    "goose",
    "gorilla",
    "gospel",
    "gossip",
    "govern",
    "gown",
    "grab",
    "grace",
    "grain",
    "grant",
    "grape",
    "grass",
    "gravity",
    "great",
    "green",
    "grid",
    "grief",
    "grit",
    "grocery",
    "group",
    "grow",
    "grunt",
    "guard",
    "guess",
    "guide",
    "guilt",
    "guitar",
    "gun",
    "gym",
    "habit",
    "hair",
    "half",
    "hammer",
    "hamster",
    "hand",
    "happy",
    "harbor",
    "hard",
    "harsh",
    "harvest",
    "hat",
    "have",
    "hawk",
    "hazard",
    "head",
    "health",
    "heart",
    "heavy",
    "hedgehog",
    "height",
    "hello",
    "helmet",
    "help",
    "hen",
    "hero",
    "hidden",
    "high",
    "hill",
    "hint",
    "hip",
    "hire",
    "history",
    "hobby",
    "hockey",
    "hold",
    "hole",
    "holiday",
    "hollow",
    "home",
    "honey",
    "hood",
    "hope",
    "horn",
    "horror",
    "horse",
    "hospital",
    "host",
    "hotel",
    "hour",
    "hover",
    "hub",
    "huge",
    "human",
    "humble",
    "humor",
    "hundred",
    "hungry",
    "hunt",
    "hurdle",
    "hurry",
    "hurt",
    "husband",
    "hybrid",
    "ice",
    "icon",
    "idea",
    "identify",
    "idle",
    "ignore",
    "ill",
    "illegal",
    "illness",
    "image",
    "imitate",
    "immense",
    "immune",
    "impact",
    "impose",
    "improve",
    "impulse",
    "inch",
    "include",
    "income",
    "increase",
    "index",
    "indicate",
    "indoor",
    "industry",
    "infant",
    "inflict",
    "inform",
    "inhale",
    "inherit",
    "initial",
    "inject",
    "injury",
    "inmate",
    "inner",
    "innocent",
    "input",
    "inquiry",
    "insane",
    "insect",
    "inside",
    "inspire",
    "install",
    "intact",
    "interest",
    "into",
    "invest",
    "invite",
    "involve",
    "iron",
    "island",
    "isolate",
    "issue",
    "item",
    "ivory",
    "jacket",
    "jaguar",
    "jar",
    "jazz",
    "jealous",
    "jeans",
    "jelly",
    "jewel",
    "job",
    "join",
    "joke",
    "journey",
    "joy",
    "judge",
    "juice",
    "jump",
    "jungle",
    "junior",
    "junk",
    "just",
    "kangaroo",
    "keen",
    "keep",
    "ketchup",
    "key",
    "kick",
    "kid",
    "kidney",
    "kind",
    "kingdom",
    "kiss",
    "kit",
    "kitchen",
    "kite",
    "kitten",
    "kiwi",
    "knee",
    "knife",
    "knock",
    "know",
    "lab",
    "label",
    "labor",
    "ladder",
    "lady",
    "lake",
    "lamp",
    "language",
    "laptop",
    "large",
    "later",
    "latin",
    "laugh",
    "laundry",
    "lava",
    "law",
    "lawn",
    "lawsuit",
    "layer",
    "lazy",
    "leader",
    "leaf",
    "learn",
    "leave",
    "lecture",
    "left",
    "leg",
    "legal",
    "legend",
    "leisure",
    "lemon",
    "lend",
    "length",
    "lens",
    "leopard",
    "lesson",
    "letter",
    "level",
    "liar",
    "liberty",
    "library",
    "license",
    "life",
    "lift",
    "light",
    "like",
    "limb",
    "limit",
    "link",
    "lion",
    "liquid",
    "list",
    "little",
    "live",
    "lizard",
    "load",
    "loan",
    "lobster",
    "local",
    "lock",
    "logic",
    "lonely",
    "long",
    "loop",
    "lottery",
    "loud",
    "lounge",
    "love",
    "loyal",
    "lucky",
    "luggage",
    "lumber",
    "lunar",
    "lunch",
    "luxury",
    "lyrics",
    "machine",
    "mad",
    "magic",
    "magnet",
    "maid",
    "mail",
    "main",
    "major",
    "make",
    "mammal",
    "man",
    "manage",
    "mandate",
    "mango",
    "mansion",
    "manual",
    "maple",
    "marble",
    "march",
    "margin",
    "marine",
    "market",
    "marriage",
    "mask",
    "mass",
    "master",
    "match",
    "material",
    "math",
    "matrix",
    "matter",
    "maximum",
    "maze",
    "meadow",
    "mean",
    "measure",
    "meat",
    "mechanic",
    "medal",
    "media",
    "melody",
    "melt",
    "member",
    "memory",
    "mention",
    "menu",
    "mercy",
    "merge",
    "merit",
    "merry",
    "mesh",
    "message",
    "metal",
    "method",
    "middle",
    "midnight",
    "milk",
    "million",
    "mimic",
    "mind",
    "minimum",
    "minor",
    "minute",
    "miracle",
    "mirror",
    "misery",
    "miss",
    "mistake",
    "mix",
    "mixed",
    "mixture",
    "mobile",
    "model",
    "modify",
    "mom",
    "moment",
    "monitor",
    "monkey",
    "monster",
    "month",
    "moon",
    "moral",
    "more",
    "morning",
    "mosquito",
    "mother",
    "motion",
    "motor",
    "mountain",
    "mouse",
    "move",
    "movie",
    "much",
    "muffin",
    "mule",
    "multiply",
    "muscle",
    "museum",
    "mushroom",
    "music",
    "must",
    "mutual",
    "myself",
    "mystery",
    "myth",
    "naive",
    "name",
    "napkin",
    "narrow",
    "nasty",
    "nation",
    "nature",
    "near",
    "neck",
    "need",
    "negative",
    "neglect",
    "neither",
    "nephew",
    "nerve",
    "nest",
    "net",
    "network",
    "neutral",
    "never",
    "news",
    "next",
    "nice",
    "night",
    "noble",
    "noise",
    "nominee",
    "noodle",
    "normal",
    "north",
    "nose",
    "notable",
    "note",
    "nothing",
    "notice",
    "novel",
    "now",
    "nuclear",
    "number",
    "nurse",
    "nut",
    "oak",
    "obey",
    "object",
    "oblige",
    "obscure",
    "observe",
    "obtain",
    "obvious",
    "occur",
    "ocean",
    "october",
    "odor",
    "off",
    "offer",
    "office",
    "often",
    "oil",
    "okay",
    "old",
    "olive",
    "olympic",
    "omit",
    "once",
    "one",
    "onion",
    "online",
    "only",
    "open",
    "opera",
    "opinion",
    "oppose",
    "option",
    "orange",
    "orbit",
    "orchard",
    "order",
    "ordinary",
    "organ",
    "orient",
    "original",
    "orphan",
    "ostrich",
    "other",
    "outdoor",
    "outer",
    "output",
    "outside",
    "oval",
    "oven",
    "over",
    "own",
    "owner",
    "oxygen",
    "oyster",
    "ozone",
    "pact",
    "paddle",
    "page",
    "pair",
    "palace",
    "palm",
    "panda",
    "panel",
    "panic",
    "panther",
    "paper",
    "parade",
    "parent",
    "park",
    "parrot",
    "party",
    "pass",
    "patch",
    "path",
    "patient",
    "patrol",
    "pattern",
    "pause",
    "pave",
    "payment",
    "peace",
    "peanut",
    "pear",
    "peasant",
    "pelican",
    "pen",
    "penalty",
    "pencil",
    "people",
    "pepper",
    "perfect",
    "permit",
    "person",
    "pet",
    "phone",
    "photo",
    "phrase",
    "physical",
    "piano",
    "picnic",
    "picture",
    "piece",
    "pig",
    "pigeon",
    "pill",
    "pilot",
    "pink",
    "pioneer",
    "pipe",
    "pistol",
    "pitch",
    "pizza",
    "place",
    "planet",
    "plastic",
    "plate",
    "play",
    "please",
    "pledge",
    "pluck",
    "plug",
    "plunge",
    "poem",
    "poet",
    "point",
    "polar",
    "pole",
    "police",
    "pond",
    "pony",
    "pool",
    "popular",
    "portion",
    "position",
    "possible",
    "post",
    "potato",
    "pottery",
    "poverty",
    "powder",
    "power",
    "practice",
    "praise",
    "predict",
    "prefer",
    "prepare",
    "present",
    "pretty",
    "prevent",
    "price",
    "pride",
    "primary",
    "print",
    "priority",
    "prison",
    "private",
    "prize",
    "problem",
    "process",
    "produce",
    "profit",
    "program",
    "project",
    "promote",
    "proof",
    "property",
    "prosper",
    "protect",
    "proud",
    "provide",
    "public",
    "pudding",
    "pull",
    "pulp",
    "pulse",
    "pumpkin",
    "punch",
    "pupil",
    "puppy",
    "purchase",
    "purity",
    "purpose",
    "purse",
    "push",
    "put",
    "puzzle",
    "pyramid",
    "quality",
    "quantum",
    "quarter",
    "question",
    "quick",
    "quit",
    "quiz",
    "quote",
    "rabbit",
    "raccoon",
    "race",
    "rack",
    "radar",
    "radio",
    "rail",
    "rain",
    "raise",
    "rally",
    "ramp",
    "ranch",
    "random",
    "range",
    "rapid",
    "rare",
    "rate",
    "rather",
    "raven",
    "raw",
    "razor",
    "ready",
    "real",
    "reason",
    "rebel",
    "rebuild",
    "recall",
    "receive",
    "recipe",
    "record",
    "recycle",
    "reduce",
    "reflect",
    "reform",
    "refuse",
    "region",
    "regret",
    "regular",
    "reject",
    "relax",
    "release",
    "relief",
    "rely",
    "remain",
    "remember",
    "remind",
    "remove",
    "render",
    "renew",
    "rent",
    "reopen",
    "repair",
    "repeat",
    "replace",
    "report",
    "require",
    "rescue",
    "resemble",
    "resist",
    "resource",
    "response",
    "result",
    "retire",
    "retreat",
    "return",
    "reunion",
    "reveal",
    "review",
    "reward",
    "rhythm",
    "rib",
    "ribbon",
    "rice",
    "rich",
    "ride",
    "ridge",
    "rifle",
    "right",
    "rigid",
    "ring",
    "riot",
    "ripple",
    "risk",
    "ritual",
    "rival",
    "river",
    "road",
    "roast",
    "robot",
    "robust",
    "rocket",
    "romance",
    "roof",
    "rookie",
    "room",
    "rose",
    "rotate",
    "rough",
    "round",
    "route",
    "royal",
    "rubber",
    "rude",
    "rug",
    "rule",
    "run",
    "runway",
    "rural",
    "sad",
    "saddle",
    "sadness",
    "safe",
    "sail",
    "salad",
    "salmon",
    "salon",
    "salt",
    "salute",
    "same",
    "sample",
    "sand",
    "satisfy",
    "satoshi",
    "sauce",
    "sausage",
    "save",
    "say",
    "scale",
    "scan",
    "scare",
    "scatter",
    "scene",
    "scheme",
    "school",
    "science",
    "scissors",
    "scorpion",
    "scout",
    "scrap",
    "screen",
    "script",
    "scrub",
    "sea",
    "search",
    "season",
    "seat",
    "second",
    "secret",
    "section",
    "security",
    "seed",
    "seek",
    "segment",
    "select",
    "sell",
    "seminar",
    "senior",
    "sense",
    "sentence",
    "series",
    "service",
    "session",
    "settle",
    "setup",
    "seven",
    "shadow",
    "shaft",
    "shallow",
    "share",
    "shed",
    "shell",
    "sheriff",
    "shield",
    "shift",
    "shine",
    "ship",
    "shiver",
    "shock",
    "shoe",
    "shoot",
    "shop",
    "short",
    "shoulder",
    "shove",
    "shrimp",
    "shrug",
    "shuffle",
    "shy",
    "sibling",
    "sick",
    "side",
    "siege",
    "sight",
    "sign",
    "silent",
    "silk",
    "silly",
    "silver",
    "similar",
    "simple",
    "since",
    "sing",
    "siren",
    "sister",
    "situate",
    "six",
    "size",
    "skate",
    "sketch",
    "ski",
    "skill",
    "skin",
    "skirt",
    "skull",
    "slab",
    "slam",
    "sleep",
    "slender",
    "slice",
    "slide",
    "slight",
    "slim",
    "slogan",
    "slot",
    "slow",
    "slush",
    "small",
    "smart",
    "smile",
    "smoke",
    "smooth",
    "snack",
    "snake",
    "snap",
    "sniff",
    "snow",
    "soap",
    "soccer",
    "social",
    "sock",
    "soda",
    "soft",
    "solar",
    "soldier",
    "solid",
    "solution",
    "solve",
    "someone",
    "song",
    "soon",
    "sorry",
    "sort",
    "soul",
    "sound",
    "soup",
    "source",
    "south",
    "space",
    "spare",
    "spatial",
    "spawn",
    "speak",
    "special",
    "speed",
    "spell",
    "spend",
    "sphere",
    "spice",
    "spider",
    "spike",
    "spin",
    "spirit",
    "split",
    "spoil",
    "sponsor",
    "spoon",
    "sport",
    "spot",
    "spray",
    "spread",
    "spring",
    "spy",
    "square",
    "squeeze",
    "squirrel",
    "stable",
    "stadium",
    "staff",
    "stage",
    "stairs",
    "stamp",
    "stand",
    "start",
    "state",
    "stay",
    "steak",
    "steel",
    "stem",
    "step",
    "stereo",
    "stick",
    "still",
    "sting",
    "stock",
    "stomach",
    "stone",
    "stool",
    "story",
    "stove",
    "strategy",
    "street",
    "strike",
    "strong",
    "struggle",
    "student",
    "stuff",
    "stumble",
    "style",
    "subject",
    "submit",
    "subway",
    "success",
    "such",
    "sudden",
    "suffer",
    "sugar",
    "suggest",
    "suit",
    "summer",
    "sun",
    "sunny",
    "sunset",
    "super",
    "supply",
    "supreme",
    "sure",
    "surface",
    "surge",
    "surprise",
    "surround",
    "survey",
    "suspect",
    "sustain",
    "swallow",
    "swamp",
    "swap",
    "swarm",
    "swear",
    "sweet",
    "swift",
    "swim",
    "swing",
    "switch",
    "sword",
    "symbol",
    "symptom",
    "syrup",
    "system",
    "table",
    "tackle",
    "tag",
    "tail",
    "talent",
    "talk",
    "tank",
    "tape",
    "target",
    "task",
    "taste",
    "tattoo",
    "taxi",
    "teach",
    "team",
    "tell",
    "ten",
    "tenant",
    "tennis",
    "tent",
    "term",
    "test",
    "text",
    "thank",
    "that",
    "theme",
    "then",
    "theory",
    "there",
    "they",
    "thing",
    "this",
    "thought",
    "three",
    "thrive",
    "throw",
    "thumb",
    "thunder",
    "ticket",
    "tide",
    "tiger",
    "tilt",
    "timber",
    "time",
    "tiny",
    "tip",
    "tired",
    "tissue",
    "title",
    "toast",
    "tobacco",
    "today",
    "toddler",
    "toe",
    "together",
    "toilet",
    "token",
    "tomato",
    "tomorrow",
    "tone",
    "tongue",
    "tonight",
    "tool",
    "tooth",
    "top",
    "topic",
    "topple",
    "torch",
    "tornado",
    "tortoise",
    "toss",
    "total",
    "tourist",
    "toward",
    "tower",
    "town",
    "toy",
    "track",
    "trade",
    "traffic",
    "tragic",
    "train",
    "transfer",
    "trap",
    "trash",
    "travel",
    "tray",
    "treat",
    "tree",
    "trend",
    "trial",
    "tribe",
    "trick",
    "trigger",
    "trim",
    "trip",
    "trophy",
    "trouble",
    "truck",
    "true",
    "truly",
    "trumpet",
    "trust",
    "truth",
    "try",
    "tube",
    "tuition",
    "tumble",
    "tuna",
    "tunnel",
    "turkey",
    "turn",
    "turtle",
    "twelve",
    "twenty",
    "twice",
    "twin",
    "twist",
    "two",
    "type",
    "typical",
    "ugly",
    "umbrella",
    "unable",
    "unaware",
    "uncle",
    "uncover",
    "under",
    "undo",
    "unfair",
    "unfold",
    "unhappy",
    "uniform",
    "unique",
    "unit",
    "universe",
    "unknown",
    "unlock",
    "until",
    "unusual",
    "unveil",
    "update",
    "upgrade",
    "uphold",
    "upon",
    "upper",
    "upset",
    "urban",
    "urge",
    "usage",
    "use",
    "used",
    "useful",
    "useless",
    "usual",
    "utility",
    "vacant",
    "vacuum",
    "vague",
    "valid",
    "valley",
    "valve",
    "van",
    "vanish",
    "vapor",
    "various",
    "vast",
    "vault",
    "vehicle",
    "velvet",
    "vendor",
    "venture",
    "venue",
    "verb",
    "verify",
    "version",
    "very",
    "vessel",
    "veteran",
    "viable",
    "vibrant",
    "vicious",
    "victory",
    "video",
    "view",
    "village",
    "vintage",
    "violin",
    "virtual",
    "virus",
    "visa",
    "visit",
    "visual",
    "vital",
    "vivid",
    "vocal",
    "voice",
    "void",
    "volcano",
    "volume",
    "vote",
    "voyage",
    "wage",
    "wagon",
    "wait",
    "walk",
    "wall",
    "walnut",
    "want",
    "warfare",
    "warm",
    "warrior",
    "wash",
    "wasp",
    "waste",
    "water",
    "wave",
    "way",
    "wealth",
    "weapon",
    "wear",
    "weasel",
    "weather",
    "web",
    "wedding",
    "weekend",
    "weird",
    "welcome",
    "west",
    "wet",
    "whale",
    "what",
    "wheat",
    "wheel",
    "when",
    "where",
    "whip",
    "whisper",
    "wide",
    "width",
    "wife",
    "wild",
    "will",
    "win",
    "window",
    "wine",
    "wing",
    "wink",
    "winner",
    "winter",
    "wire",
    "wisdom",
    "wise",
    "wish",
    "witness",
    "wolf",
    "woman",
    "wonder",
    "wood",
    "wool",
    "word",
    "work",
    "world",
    "worry",
    "worth",
    "wrap",
    "wreck",
    "wrestle",
    "wrist",
    "write",
    "wrong",
    "yard",
    "year",
    "yellow",
    "you",
    "young",
    "youth",
    "zebra",
    "zero",
    "zone",
    "zoo"
  ],
  space: " "
};

// node_modules/@bsv/sdk/dist/esm/src/compat/Mnemonic.js
var Mnemonic = class _Mnemonic {
  /**
     * Constructs a Mnemonic object.
     * @param {string} [mnemonic] - An optional mnemonic phrase.
     * @param {number[]} [seed] - An optional seed derived from the mnemonic.
     * @param {object} [wordlist=wordList] - An object containing a list of words and space character used in the mnemonic.
     */
  constructor(mnemonic, seed, wordlist = wordList) {
    __publicField(this, "mnemonic");
    __publicField(this, "seed");
    __publicField(this, "Wordlist");
    this.mnemonic = mnemonic;
    this.seed = seed;
    this.Wordlist = wordlist;
  }
  /**
     * Converts the mnemonic and seed into a binary representation.
     * @returns {number[]} The binary representation of the mnemonic and seed.
     */
  toBinary() {
    const bw = new Writer();
    if (this.mnemonic) {
      const buf = toArray2(this.mnemonic, "utf8");
      bw.writeVarIntNum(buf.length);
      bw.write(buf);
    } else {
      bw.writeVarIntNum(0);
    }
    if (this.seed) {
      bw.writeVarIntNum(this.seed.length);
      bw.write(this.seed);
    } else {
      bw.writeVarIntNum(0);
    }
    return bw.toArray();
  }
  /**
     * Loads a mnemonic and seed from a binary representation.
     * @param {number[]} bin - The binary representation of a mnemonic and seed.
     * @returns {this} The Mnemonic instance with loaded mnemonic and seed.
     */
  fromBinary(bin) {
    const br = new Reader(bin);
    const mnemoniclen = br.readVarIntNum();
    if (mnemoniclen > 0) {
      this.mnemonic = encode(br.read(mnemoniclen), "utf8");
    }
    const seedlen = br.readVarIntNum();
    if (seedlen > 0) {
      this.seed = br.read(seedlen);
    }
    return this;
  }
  /**
     * Generates a random mnemonic from a given bit length.
     * @param {number} [bits=128] - The bit length for the random mnemonic (must be a multiple of 32 and at least 128).
     * @returns {this} The Mnemonic instance with the new random mnemonic.
     * @throws {Error} If the bit length is not a multiple of 32 or is less than 128.
     */
  fromRandom(bits) {
    if (!bits) {
      bits = 128;
    }
    if (bits % 32 !== 0) {
      throw new Error("bits must be multiple of 32");
    }
    if (bits < 128) {
      throw new Error("bits must be at least 128");
    }
    const buf = Random_default(bits / 8);
    this.entropy2Mnemonic(buf);
    this.mnemonic2Seed();
    return this;
  }
  /**
     * Static method to generate a Mnemonic instance with a random mnemonic.
     * @param {number} [bits=128] - The bit length for the random mnemonic.
     * @returns {Mnemonic} A new Mnemonic instance.
     */
  static fromRandom(bits) {
    return new this().fromRandom(bits);
  }
  /**
     * Converts given entropy into a mnemonic phrase.
     * This method is used to generate a mnemonic from a specific entropy source.
     * @param {number[]} buf - The entropy buffer, must be at least 128 bits.
     * @returns {this} The Mnemonic instance with the mnemonic set from the given entropy.
     * @throws {Error} If the entropy is less than 128 bits.
     */
  fromEntropy(buf) {
    this.entropy2Mnemonic(buf);
    return this;
  }
  /**
     * Static method to create a Mnemonic instance from a given entropy.
     * @param {number[]} buf - The entropy buffer.
     * @returns {Mnemonic} A new Mnemonic instance.
     */
  static fromEntropy(buf) {
    return new this().fromEntropy(buf);
  }
  /**
     * Sets the mnemonic for the instance from a string.
     * @param {string} mnemonic - The mnemonic phrase as a string.
     * @returns {this} The Mnemonic instance with the set mnemonic.
     */
  fromString(mnemonic) {
    this.mnemonic = mnemonic;
    return this;
  }
  /**
     * Static method to create a Mnemonic instance from a mnemonic string.
     * @param {string} str - The mnemonic phrase.
     * @returns {Mnemonic} A new Mnemonic instance.
     */
  static fromString(str) {
    return new this().fromString(str);
  }
  /**
     * Converts the instance's mnemonic to a string representation.
     * @returns {string} The mnemonic phrase as a string.
     */
  toString() {
    return this.mnemonic;
  }
  /**
     * Converts the mnemonic to a seed.
     * The mnemonic must pass the validity check before conversion.
     * @param {string} [passphrase=''] - An optional passphrase for additional security.
     * @returns {number[]} The generated seed.
     * @throws {Error} If the mnemonic is invalid.
     */
  toSeed(passphrase) {
    this.mnemonic2Seed(passphrase);
    return this.seed;
  }
  /**
     * Converts entropy to a mnemonic phrase.
     * This method takes a buffer of entropy and converts it into a corresponding
     * mnemonic phrase based on the Mnemonic wordlist. The entropy should be at least 128 bits.
     * The method applies a checksum and maps the entropy to words in the wordlist.
     * @param {number[]} buf - The entropy buffer to convert. Must be at least 128 bits.
     * @returns {this} The Mnemonic instance with the mnemonic set from the entropy.
     * @throws {Error} If the entropy is less than 128 bits or if it's not an even multiple of 11 bits.
     */
  entropy2Mnemonic(buf) {
    if (buf.length < 128 / 8) {
      throw new Error("Entropy is less than 128 bits. It must be 128 bits or more.");
    }
    const hash = sha256(buf);
    let bin = "";
    const bits = buf.length * 8;
    for (let i = 0; i < buf.length; i++) {
      bin = bin + ("00000000" + buf[i].toString(2)).slice(-8);
    }
    let hashbits = hash[0].toString(2);
    hashbits = ("00000000" + hashbits).slice(-8).slice(0, bits / 32);
    bin = bin + hashbits;
    if (bin.length % 11 !== 0) {
      throw new Error("internal error - entropy not an even multiple of 11 bits - " + bin.length);
    }
    let mnemonic = "";
    for (let i = 0; i < bin.length / 11; i++) {
      if (mnemonic !== "") {
        mnemonic = mnemonic + this.Wordlist.space;
      }
      const wi = parseInt(bin.slice(i * 11, (i + 1) * 11), 2);
      mnemonic = mnemonic + this.Wordlist.value[wi];
    }
    this.mnemonic = mnemonic;
    return this;
  }
  /**
     * Validates the mnemonic phrase.
     * Checks for correct length, absence of invalid words, and proper checksum.
     * @returns {boolean} True if the mnemonic is valid, false otherwise.
     * @throws {Error} If the mnemonic is not an even multiple of 11 bits.
     */
  check() {
    const mnemonic = this.mnemonic;
    const words = mnemonic.split(this.Wordlist.space);
    let bin = "";
    for (let i = 0; i < words.length; i++) {
      const ind = this.Wordlist.value.indexOf(words[i]);
      if (ind < 0) {
        return false;
      }
      bin = bin + ("00000000000" + ind.toString(2)).slice(-11);
    }
    if (bin.length % 11 !== 0) {
      throw new Error("internal error - entropy not an even multiple of 11 bits - " + bin.length);
    }
    const cs = bin.length / 33;
    const hashBits = bin.slice(-cs);
    const nonhashBits = bin.slice(0, bin.length - cs);
    const buf = [];
    for (let i = 0; i < nonhashBits.length / 8; i++) {
      buf.push(parseInt(bin.slice(i * 8, (i + 1) * 8), 2));
    }
    const hash = sha256(buf.slice(0, nonhashBits.length / 8));
    let expectedHashBits = hash[0].toString(2);
    expectedHashBits = ("00000000" + expectedHashBits).slice(-8).slice(0, cs);
    return expectedHashBits === hashBits;
  }
  /**
     * Converts a mnemonic to a seed.
     * This method takes the instance's mnemonic phrase, combines it with a passphrase (if provided),
     * and uses PBKDF2 to generate a seed. It also validates the mnemonic before conversion.
     * This seed can then be used for generating deterministic keys.
     * @param {string} [passphrase=''] - An optional passphrase for added security.
     * @returns {this} The Mnemonic instance with the seed generated from the mnemonic.
     * @throws {Error} If the mnemonic does not pass validation or if the passphrase is not a string.
     */
  mnemonic2Seed(passphrase = "") {
    let mnemonic = this.mnemonic;
    if (!this.check()) {
      throw new Error("Mnemonic does not pass the check - was the mnemonic typed incorrectly? Are there extra spaces?");
    }
    if (typeof passphrase !== "string") {
      throw new Error("passphrase must be a string or undefined");
    }
    mnemonic = mnemonic.normalize("NFKD");
    passphrase = passphrase.normalize("NFKD");
    const mbuf = toArray2(mnemonic, "utf8");
    const pbuf = [...toArray2("mnemonic", "utf8"), ...toArray2(passphrase, "utf8")];
    this.seed = pbkdf2(mbuf, pbuf, 2048, 64, "sha512");
    return this;
  }
  /**
     * Determines the validity of a given passphrase with the mnemonic.
     * This method is useful for checking if a passphrase matches with the mnemonic.
     * @param {string} [passphrase=''] - The passphrase to validate.
     * @returns {boolean} True if the mnemonic and passphrase combination is valid, false otherwise.
     */
  isValid(passphrase = "") {
    let isValid;
    try {
      isValid = !!this.mnemonic2Seed(passphrase);
    } catch (err) {
      isValid = false;
    }
    return isValid;
  }
  /**
     * Static method to check the validity of a given mnemonic and passphrase combination.
     * @param {string} mnemonic - The mnemonic phrase.
     * @param {string} [passphrase=''] - The passphrase to validate.
     * @returns {boolean} True if the combination is valid, false otherwise.
     */
  static isValid(mnemonic, passphrase = "") {
    return new _Mnemonic(mnemonic).isValid(passphrase);
  }
};

// node_modules/@bsv/sdk/dist/esm/src/compat/ECIES.js
function AES2(key) {
  if (!this._tables[0][0][0])
    this._precompute();
  let tmp, encKey, decKey;
  const sbox = this._tables[0][4];
  const decTable = this._tables[1];
  const keyLen = key.length;
  let rcon = 1;
  if (keyLen !== 4 && keyLen !== 6 && keyLen !== 8) {
    throw new Error("invalid aes key size");
  }
  this._key = [encKey = key.slice(0), decKey = []];
  for (var i = keyLen; i < 4 * keyLen + 28; i++) {
    tmp = encKey[i - 1];
    if (i % keyLen === 0 || keyLen === 8 && i % keyLen === 4) {
      tmp = sbox[tmp >>> 24] << 24 ^ sbox[tmp >> 16 & 255] << 16 ^ sbox[tmp >> 8 & 255] << 8 ^ sbox[tmp & 255];
      if (i % keyLen === 0) {
        tmp = tmp << 8 ^ tmp >>> 24 ^ rcon << 24;
        rcon = rcon << 1 ^ (rcon >> 7) * 283;
      }
    }
    encKey[i] = encKey[i - keyLen] ^ tmp;
  }
  for (let j = 0; i; j++, i--) {
    tmp = encKey[j & 3 ? i : i - 4];
    if (i <= 4 || j < 4) {
      decKey[j] = tmp;
    } else {
      decKey[j] = decTable[0][sbox[tmp >>> 24]] ^ decTable[1][sbox[tmp >> 16 & 255]] ^ decTable[2][sbox[tmp >> 8 & 255]] ^ decTable[3][sbox[tmp & 255]];
    }
  }
}
AES2.prototype = {
  /**
     * Encrypt an array of 4 big-endian words.
     * @param {Array} data The plaintext.
     * @return {Array} The ciphertext.
     */
  encrypt: function(data) {
    return this._crypt(data, 0);
  },
  /**
     * Decrypt an array of 4 big-endian words.
     * @param {Array} data The ciphertext.
     * @return {Array} The plaintext.
     */
  decrypt: function(data) {
    return this._crypt(data, 1);
  },
  /**
     * The expanded S-box and inverse S-box tables.  These will be computed
     * on the client so that we don't have to send them down the wire.
     *
     * There are two tables, _tables[0] is for encryption and
     * _tables[1] is for decryption.
     *
     * The first 4 sub-tables are the expanded S-box with MixColumns.  The
     * last (_tables[01][4]) is the S-box itself.
     *
     * @private
     */
  _tables: [
    [new Uint32Array(256), new Uint32Array(256), new Uint32Array(256), new Uint32Array(256), new Uint32Array(256)],
    [new Uint32Array(256), new Uint32Array(256), new Uint32Array(256), new Uint32Array(256), new Uint32Array(256)]
  ],
  // Expand the S-box tables.
  _precompute: function() {
    const encTable = this._tables[0];
    const decTable = this._tables[1];
    const sbox = encTable[4];
    const sboxInv = decTable[4];
    let i;
    let x;
    let xInv;
    const d = new Uint8Array(256);
    const th = new Uint8Array(256);
    let x2;
    let x4;
    let x8;
    let s2;
    let tEnc;
    let tDec;
    for (i = 0; i < 256; i++) {
      th[(d[i] = i << 1 ^ (i >> 7) * 283) ^ i] = i;
    }
    for (x = xInv = 0; !sbox[x]; x ^= x2 || 1, xInv = th[xInv] || 1) {
      s2 = xInv ^ xInv << 1 ^ xInv << 2 ^ xInv << 3 ^ xInv << 4;
      s2 = s2 >> 8 ^ s2 & 255 ^ 99;
      sbox[x] = s2;
      sboxInv[s2] = x;
      x8 = d[x4 = d[x2 = d[x]]];
      tDec = x8 * 16843009 ^ x4 * 65537 ^ x2 * 257 ^ x * 16843008;
      tEnc = d[s2] * 257 ^ s2 * 16843008;
      for (i = 0; i < 4; i++) {
        encTable[i][x] = tEnc = tEnc << 24 ^ tEnc >>> 8;
        decTable[i][s2] = tDec = tDec << 24 ^ tDec >>> 8;
      }
    }
  },
  /**
     * Encryption and decryption core.
     * @param {Array} input Four words to be encrypted or decrypted.
     * @param dir The direction, 0 for encrypt and 1 for decrypt.
     * @return {Array} The four encrypted or decrypted words.
     * @private
     */
  _crypt: function(input, dir) {
    if (input.length !== 4) {
      throw new Error("invalid aes block size");
    }
    const key = this._key[dir];
    let a = input[0] ^ key[0];
    let b = input[dir ? 3 : 1] ^ key[1];
    let c = input[2] ^ key[2];
    let d = input[dir ? 1 : 3] ^ key[3];
    let a2;
    let b2;
    let c2;
    const nInnerRounds = key.length / 4 - 2;
    let i;
    let kIndex = 4;
    const out = new Uint32Array(4);
    const table = this._tables[dir];
    const t0 = table[0];
    const t1 = table[1];
    const t2 = table[2];
    const t3 = table[3];
    const sbox = table[4];
    for (i = 0; i < nInnerRounds; i++) {
      a2 = t0[a >>> 24] ^ t1[b >> 16 & 255] ^ t2[c >> 8 & 255] ^ t3[d & 255] ^ key[kIndex];
      b2 = t0[b >>> 24] ^ t1[c >> 16 & 255] ^ t2[d >> 8 & 255] ^ t3[a & 255] ^ key[kIndex + 1];
      c2 = t0[c >>> 24] ^ t1[d >> 16 & 255] ^ t2[a >> 8 & 255] ^ t3[b & 255] ^ key[kIndex + 2];
      d = t0[d >>> 24] ^ t1[a >> 16 & 255] ^ t2[b >> 8 & 255] ^ t3[c & 255] ^ key[kIndex + 3];
      kIndex += 4;
      a = a2;
      b = b2;
      c = c2;
    }
    for (i = 0; i < 4; i++) {
      out[dir ? 3 & -i : i] = sbox[a >>> 24] << 24 ^ sbox[b >> 16 & 255] << 16 ^ sbox[c >> 8 & 255] << 8 ^ sbox[d & 255] ^ key[kIndex++];
      a2 = a;
      a = b;
      b = c;
      c = d;
      d = a2;
    }
    return out;
  }
};
var AESWrapper = class _AESWrapper {
  static encrypt(messageBuf, keyBuf) {
    const key = _AESWrapper.buf2Words(keyBuf);
    const message = _AESWrapper.buf2Words(messageBuf);
    const a = new AES2(key);
    const enc = a.encrypt(message);
    const encBuf = _AESWrapper.words2Buf(enc);
    return encBuf;
  }
  static decrypt(encBuf, keyBuf) {
    const enc = _AESWrapper.buf2Words(encBuf);
    const key = _AESWrapper.buf2Words(keyBuf);
    const a = new AES2(key);
    const message = a.decrypt(enc);
    const messageBuf = _AESWrapper.words2Buf(message);
    return messageBuf;
  }
  static buf2Words(buf) {
    if (buf.length % 4) {
      throw new Error("buf length must be a multiple of 4");
    }
    const words = [];
    for (let i = 0; i < buf.length / 4; i++) {
      const val = buf[i * 4] * 16777216 + // Shift the first byte by 24 bits
      (buf[i * 4 + 1] << 16 | // Shift the second byte by 16 bits
      buf[i * 4 + 2] << 8 | // Shift the third byte by 8 bits
      buf[i * 4 + 3]);
      words.push(val);
    }
    return words;
  }
  static words2Buf(words) {
    const buf = new Array(words.length * 4);
    for (let i = 0; i < words.length; i++) {
      const word = words[i];
      buf[i * 4] = word >>> 24 & 255;
      buf[i * 4 + 1] = word >>> 16 & 255;
      buf[i * 4 + 2] = word >>> 8 & 255;
      buf[i * 4 + 3] = word & 255;
    }
    return buf;
  }
};
var CBC = class _CBC {
  static buf2BlocksBuf(buf, blockSize) {
    const bytesize = blockSize / 8;
    const blockBufs = [];
    for (let i = 0; i <= buf.length / bytesize; i++) {
      let blockBuf = buf.slice(i * bytesize, i * bytesize + bytesize);
      if (blockBuf.length < blockSize) {
        blockBuf = _CBC.pkcs7Pad(blockBuf, blockSize);
      }
      blockBufs.push(blockBuf);
    }
    return blockBufs;
  }
  static blockBufs2Buf(blockBufs) {
    let last = blockBufs[blockBufs.length - 1];
    last = _CBC.pkcs7Unpad(last);
    blockBufs[blockBufs.length - 1] = last;
    const buf = blockBufs.flat();
    return buf;
  }
  static encrypt(messageBuf, ivBuf, blockCipher, cipherKeyBuf) {
    const blockSize = ivBuf.length * 8;
    const blockBufs = _CBC.buf2BlocksBuf(messageBuf, blockSize);
    const encBufs = _CBC.encryptBlocks(blockBufs, ivBuf, blockCipher, cipherKeyBuf);
    const encBuf = encBufs.flat();
    return encBuf;
  }
  static decrypt(encBuf, ivBuf, blockCipher, cipherKeyBuf) {
    const bytesize = ivBuf.length;
    const encBufs = [];
    for (let i = 0; i < encBuf.length / bytesize; i++) {
      encBufs.push(encBuf.slice(i * bytesize, i * bytesize + bytesize));
    }
    const blockBufs = _CBC.decryptBlocks(encBufs, ivBuf, blockCipher, cipherKeyBuf);
    const buf = _CBC.blockBufs2Buf(blockBufs);
    return buf;
  }
  static encryptBlock(blockBuf, ivBuf, blockCipher, cipherKeyBuf) {
    const xorbuf = _CBC.xorBufs(blockBuf, ivBuf);
    const encBuf = blockCipher.encrypt(xorbuf, cipherKeyBuf);
    return encBuf;
  }
  static decryptBlock(encBuf, ivBuf, blockCipher, cipherKeyBuf) {
    const xorbuf = blockCipher.decrypt(encBuf, cipherKeyBuf);
    const blockBuf = _CBC.xorBufs(xorbuf, ivBuf);
    return blockBuf;
  }
  static encryptBlocks(blockBufs, ivBuf, blockCipher, cipherKeyBuf) {
    const encBufs = [];
    for (let i = 0; i < blockBufs.length; i++) {
      const blockBuf = blockBufs[i];
      const encBuf = _CBC.encryptBlock(blockBuf, ivBuf, blockCipher, cipherKeyBuf);
      encBufs.push(encBuf);
      ivBuf = encBuf;
    }
    return encBufs;
  }
  static decryptBlocks(encBufs, ivBuf, blockCipher, cipherKeyBuf) {
    const blockBufs = [];
    for (let i = 0; i < encBufs.length; i++) {
      const encBuf = encBufs[i];
      const blockBuf = _CBC.decryptBlock(encBuf, ivBuf, blockCipher, cipherKeyBuf);
      blockBufs.push(blockBuf);
      ivBuf = encBuf;
    }
    return blockBufs;
  }
  static pkcs7Pad(buf, blockSize) {
    const bytesize = blockSize / 8;
    const padbytesize = bytesize - buf.length;
    const pad = new Array(padbytesize);
    pad.fill(padbytesize);
    const paddedbuf = [...buf, ...pad];
    return paddedbuf;
  }
  static pkcs7Unpad(paddedbuf) {
    const padlength = paddedbuf[paddedbuf.length - 1];
    const padbuf = paddedbuf.slice(paddedbuf.length - padlength, paddedbuf.length);
    const padbuf2 = new Array(padlength);
    padbuf2.fill(padlength);
    if (toHex(padbuf) !== toHex(padbuf2)) {
      throw new Error("invalid padding");
    }
    return paddedbuf.slice(0, paddedbuf.length - padlength);
  }
  static xorBufs(buf1, buf2) {
    if (buf1.length !== buf2.length) {
      throw new Error("bufs must have the same length");
    }
    const buf = new Array(buf1.length);
    for (let i = 0; i < buf1.length; i++) {
      buf[i] = buf1[i] ^ buf2[i];
    }
    return buf;
  }
};
var AESCBC = class {
  static encrypt(messageBuf, cipherKeyBuf, ivBuf, concatIvBuf = true) {
    ivBuf = ivBuf || new Array(128 / 8).fill(0) || Random_default(128 / 8);
    const ctBuf = CBC.encrypt(messageBuf, ivBuf, AESWrapper, cipherKeyBuf);
    if (concatIvBuf) {
      return [...ivBuf, ...ctBuf];
    } else {
      return [...ctBuf];
    }
  }
  static decrypt(encBuf, cipherKeyBuf, ivBuf) {
    if (!ivBuf) {
      ivBuf = encBuf.slice(0, 128 / 8);
      const ctBuf = encBuf.slice(128 / 8);
      return CBC.decrypt(ctBuf, ivBuf, AESWrapper, cipherKeyBuf);
    } else {
      const ctBuf = encBuf;
      return CBC.decrypt(ctBuf, ivBuf, AESWrapper, cipherKeyBuf);
    }
  }
};
var ECIES = class _ECIES {
  /**
     * Generates the initialization vector (iv), encryption key (kE), and MAC key (kM)
     * using the sender's private key and receiver's public key.
     *
     * @param {PrivateKey} privKey - The sender's private key.
     * @param {PublicKey} pubKey - The receiver's public key.
     * @returns {Object} An object containing the iv, kE, and kM as number arrays.
     */
  static ivkEkM(privKey, pubKey) {
    const r2 = privKey;
    const KB = pubKey;
    const P = KB.mul(r2);
    const S = new PublicKey(P.x, P.y);
    const Sbuf = S.encode(true);
    const hash = sha512(Sbuf);
    return {
      iv: hash.slice(0, 16),
      kE: hash.slice(16, 32),
      kM: hash.slice(32, 64)
    };
  }
  /**
     * Encrypts a given message using the Electrum ECIES method.
     *
     * @param {number[]} messageBuf - The message to be encrypted, in number array format.
     * @param {PublicKey} toPublicKey - The public key of the recipient.
     * @param {PrivateKey} [fromPrivateKey] - The private key of the sender. If not provided, a random private key is used.
     * @param {boolean} [noKey=false] - If true, does not include the sender's public key in the encrypted message.
     * @returns {number[]} The encrypted message as a number array.
     */
  static electrumEncrypt(messageBuf, toPublicKey, fromPrivateKey, noKey = false) {
    let Rbuf;
    if (fromPrivateKey === null) {
      fromPrivateKey = PrivateKey.fromRandom();
    }
    if (!noKey) {
      Rbuf = fromPrivateKey.toPublicKey().encode(true);
    }
    const { iv, kE, kM } = _ECIES.ivkEkM(fromPrivateKey, toPublicKey);
    const ciphertext = AESCBC.encrypt(messageBuf, kE, iv, false);
    const BIE1 = toArray2("BIE1", "utf8");
    let encBuf;
    if (Rbuf) {
      encBuf = [...BIE1, ...Rbuf, ...ciphertext];
    } else {
      encBuf = [...BIE1, ...ciphertext];
    }
    const hmac = sha256hmac(kM, encBuf);
    return [...encBuf, ...hmac];
  }
  /**
     * Decrypts a message encrypted using the Electrum ECIES method.
     *
     * @param {number[]} encBuf - The encrypted message buffer.
     * @param {PrivateKey} toPrivateKey - The private key of the recipient.
     * @param {PublicKey} [fromPublicKey=null] - The public key of the sender. If not provided, it is extracted from the message.
     * @returns {number[]} The decrypted message as a number array.
     */
  static electrumDecrypt(encBuf, toPrivateKey, fromPublicKey = null) {
    const tagLength = 32;
    const magic = encBuf.slice(0, 4);
    if (encode(magic, "utf8") !== "BIE1") {
      throw new Error("Invalid Magic");
    }
    let offset = 4;
    if (fromPublicKey === null) {
      const pub = encBuf.slice(4, 37);
      fromPublicKey = PublicKey.fromString(toHex(pub));
      offset = 37;
    }
    const { iv, kE, kM } = _ECIES.ivkEkM(toPrivateKey, fromPublicKey);
    const ciphertext = encBuf.slice(offset, encBuf.length - tagLength);
    const hmac = encBuf.slice(encBuf.length - tagLength, encBuf.length);
    const hmac2 = sha256hmac(kM, encBuf.slice(0, encBuf.length - tagLength));
    if (toHex(hmac) !== toHex(hmac2)) {
      throw new Error("Invalid checksum");
    }
    return AESCBC.decrypt(ciphertext, kE, iv);
  }
  /**
     * Encrypts a given message using the Bitcore variant of ECIES.
     *
     * @param {number[]} messageBuf - The message to be encrypted, in number array format.
     * @param {PublicKey} toPublicKey - The public key of the recipient.
     * @param {PrivateKey} [fromPrivateKey] - The private key of the sender. If not provided, a random private key is used.
     * @param {number[]} [ivBuf] - The initialization vector for encryption. If not provided, a random IV is used.
     * @returns {number[]} The encrypted message as a number array.
     */
  static bitcoreEncrypt(messageBuf, toPublicKey, fromPrivateKey, ivBuf) {
    if (!fromPrivateKey) {
      fromPrivateKey = PrivateKey.fromRandom();
    }
    const r2 = fromPrivateKey;
    const RPublicKey = fromPrivateKey.toPublicKey();
    const RBuf = RPublicKey.encode(true);
    const KB = toPublicKey;
    const P = KB.mul(r2);
    const S = P.getX();
    const Sbuf = S.toArray("be", 32);
    const kEkM = sha512(Sbuf);
    const kE = kEkM.slice(0, 32);
    const kM = kEkM.slice(32, 64);
    const c = AESCBC.encrypt(messageBuf, kE, ivBuf);
    const d = sha256hmac(kM, [...c]);
    const encBuf = [...RBuf, ...c, ...d];
    return encBuf;
  }
  /**
     * Decrypts a message encrypted using the Bitcore variant of ECIES.
     *
     * @param {number[]} encBuf - The encrypted message buffer.
     * @param {PrivateKey} toPrivateKey - The private key of the recipient.
     * @returns {number[]} The decrypted message as a number array.
     */
  static bitcoreDecrypt(encBuf, toPrivateKey) {
    const kB = toPrivateKey;
    const fromPublicKey = PublicKey.fromString(toHex(encBuf.slice(0, 33)));
    const R2 = fromPublicKey;
    const P = R2.mul(kB);
    if (P.eq(new Point(0, 0))) {
      throw new Error("P equals 0");
    }
    const S = P.getX();
    const Sbuf = S.toArray("be", 32);
    const kEkM = sha512(Sbuf);
    const kE = kEkM.slice(0, 32);
    const kM = kEkM.slice(32, 64);
    const c = encBuf.slice(33, encBuf.length - 32);
    const d = encBuf.slice(encBuf.length - 32, encBuf.length);
    const d2 = sha256hmac(kM, c);
    if (toHex(d) !== toHex(d2)) {
      throw new Error("Invalid checksum");
    }
    const messageBuf = AESCBC.decrypt(c, kE);
    return [...messageBuf];
  }
};

// node_modules/@bsv/sdk/dist/esm/src/compat/Utxo.js
function fromUtxo(utxo, unlockingScriptTemplate) {
  const sourceTransaction = new Transaction(0, [], [], 0);
  sourceTransaction.outputs = Array(utxo.vout + 1).fill(null);
  sourceTransaction.outputs[utxo.vout] = {
    satoshis: utxo.satoshis,
    lockingScript: LockingScript.fromHex(utxo.script)
  };
  return {
    sourceTransaction,
    sourceTXID: utxo.txid,
    sourceOutputIndex: utxo.vout,
    unlockingScriptTemplate,
    sequence: 4294967295
  };
}

// node_modules/@bsv/sdk/dist/esm/src/totp/totp.js
var TOTP = class {
  /**
   * Generates a Time-based One-Time Password (TOTP).
   * @param {number[]} secret - The secret key for TOTP.
   * @param {TOTPOptions} options - Optional parameters for TOTP.
   * @returns {string} The generated TOTP.
   */
  static generate(secret, options) {
    const _options = this.withDefaultOptions(options);
    const counter = this.getCounter(_options.timestamp, _options.period);
    const otp = generateHOTP(secret, counter, _options);
    return otp;
  }
  /**
   * Validates a Time-based One-Time Password (TOTP).
   * @param {number[]} secret - The secret key for TOTP.
   * @param {string} passcode - The passcode to validate.
   * @param {TOTPValidateOptions} options - Optional parameters for TOTP validation.
   * @returns {boolean} A boolean indicating whether the passcode is valid.
   */
  static validate(secret, passcode, options) {
    const _options = this.withDefaultValidateOptions(options);
    passcode = passcode.trim();
    if (passcode.length != _options.digits) {
      return false;
    }
    const counter = this.getCounter(_options.timestamp, _options.period);
    const counters = [counter];
    for (let i = 1; i <= _options.skew; i++) {
      counters.push(counter + i);
      counters.push(counter - i);
    }
    for (const c of counters) {
      if (passcode === generateHOTP(secret, c, _options)) {
        return true;
      }
    }
    return false;
  }
  static getCounter(timestamp, period) {
    const epochSeconds = Math.floor(timestamp / 1e3);
    const counter = Math.floor(epochSeconds / period);
    return counter;
  }
  static withDefaultOptions(options) {
    return {
      digits: 2,
      algorithm: "SHA-1",
      period: 30,
      timestamp: Date.now(),
      ...options
    };
  }
  static withDefaultValidateOptions(options) {
    return { skew: 1, ...this.withDefaultOptions(options) };
  }
};
function generateHOTP(secret, counter, options) {
  const timePad = new BigNumber(counter).toArray("be", 8);
  console.log({ timePad });
  const hmac = calcHMAC(secret, timePad, options.algorithm);
  const signature = hmac.digest();
  const offset = signature[signature.length - 1] & 15;
  const fourBytesRange = signature.slice(offset, offset + 4);
  const mask = 2147483647;
  const masked = new BigNumber(fourBytesRange).toNumber() & mask;
  const otp = masked.toString().slice(-options.digits);
  return otp;
}
function calcHMAC(secret, timePad, algorithm) {
  switch (algorithm) {
    case "SHA-1":
      return new SHA1HMAC(secret).update(timePad);
    case "SHA-256":
      return new SHA256HMAC(secret).update(timePad);
    case "SHA-512":
      return new SHA512HMAC(secret).update(timePad);
    default:
      throw new Error("unsupported HMAC algorithm");
  }
}
export {
  ARC,
  BSM_exports as BSM,
  BigNumber,
  Curve,
  ECDSA_exports as ECDSA,
  ECIES,
  EncryptedMessage_exports as EncryptedMessage,
  FetchHttpClient,
  HD,
  Hash_exports as Hash,
  LockingScript,
  MerklePath,
  Mnemonic,
  NodejsHttpClient,
  OP_default as OP,
  P2PKH,
  Point,
  PrivateKey,
  PublicKey,
  RPuzzle,
  Random_default as Random,
  SatoshisPerKilobyte,
  Script,
  Signature,
  SignedMessage_exports as SignedMessage,
  Spend,
  SymmetricKey,
  TOTP,
  Transaction,
  TransactionSignature,
  UnlockingScript,
  utils_exports as Utils,
  WhatsOnChain,
  WhatsOnChainBroadcaster,
  defaultBroadcaster,
  defaultChainTracker,
  defaultHttpClient,
  fromUtxo,
  isBroadcastFailure,
  isBroadcastResponse
};
//# sourceMappingURL=@bsv_sdk.js.map
